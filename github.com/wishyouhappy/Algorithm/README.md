


### Overview
* [1 Two Sum](#1-two-sum)
* [2 Add Two Numbers](#2-add-two-numbers)
* [3 Longest Substring without Repeating Characters](#3-longest-substring-without-repeating-characters)
* [4 Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
* [5 Longest Palindromic Substring](#5-longest-palindromic-substring)
* [6 Zigzag Conversion](#6-zigzag-conversion)
* [7 Reverse Integer](#7-reverse-integer)
* [8 String to Integer atoi](#8-string-to-integer-atoi)
* [9 Palindrome Number](#9-palindrome-number)
* [10 Regular Expression Matching](#10-regular-expression-matching)
* [11 Container with Most Water](#11-container-with-most-water)
* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)
* [14 Longest Common Prefix](#14-longest-common-prefix)
* [15 3Sum](#15-3sum)
* [16 3Sum Closest](#16-3sum-closest)
* [17 Number Combinations of a Phone Number](#17-number-combinations-of-a-phone-number)
* [18 4Sum](#18-4sum)
* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20 Valid Parentheses](#20-valid-parentheses)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [22 Generate Parentheses](#22-generate-parentheses)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [25 Reverse Nodes in kGroup](#25-reverse-nodes-in-kgroup)
* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [28 Implement strStr](#28-implement-strstr)
* [29 Divide Two Integers](#29-divide-two-integers)
* [30 Substring with Concatenation of All Words](#30-substring-with-concatenation-of-all-words)
* [31 Next Permutation](#31-next-permutation)
* [32 Longest Valid Parentheses](#32-longest-valid-parentheses)
* [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
* [34 Search for a Range](#34-search-for-a-range)
* [35 Search Insert Position](#35-search-insert-position)
* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)
* [38 Count and Say](#38-count-and-say)
* [39 Combination Sum](#39-combination-sum)
* [40 Combination Sum II](#40-combination-sum-ii)
* [41 First Missing Positive](#41-first-missing-positive)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [43 Multiply Strings](#43-multiply-strings)
* [44 Wildcard Matching](#44-wildcard-matching)
* [45 Jump Game II](#45-jump-game-ii)
* [46 Permutations](#46-permutations)
* [47 Permutations II](#47-permutations-ii)
* [48 Rotate Image](#48-rotate-image)
* [49 Group Anagrams](#49-group-anagrams)
* [50 Pow](#50-pow)
* [51 N Queens](#51-n-queens)
* [52 N Queens II](#52-n-queens-ii)
* [53 Maximum Subarray](#53-maximum-subarray)
* [54 Spiral Matrix](#54-spiral-matrix)
* [55 Jump Game](#55-jump-game)
* [56 Merge Intervals](#56-merge-intervals)
* [57 Insert Interval](#57-insert-interval)
* [58 Length of Last Word](#58-length-of-last-word)
* [59 Spiral Matrix II](#59-spiral-matrix-ii)
* [60 Permutation Sequence](#60-permutation-sequence)
* [61 Rotate List](#61-rotate-list)
* [62 Unique Paths](#62-unique-paths)
* [63 Unique Paths II](#63-unique-paths-ii)
* [64 Minimum Path Sum](#64-minimum-path-sum)
* [65 Valid Number](#65-valid-number)
* [66 Plus One](#66-plus-one)
* [67 Add Binary](#67-add-binary)
* [68 Text Justification](#68-text-justification)
* [69 Sqrt](#69-sqrt)
* [70 Climbing Stairs](#70-climbing-stairs)
* [71 Simplify Path](#71-simplify-path)
* [72 Edit Distance](#72-edit-distance)
* [73 Set Matrix Zeroes](#73-set-matrix-zeroes)
* [74 Search a 2D Matrix](#74-search-a-2d-matrix)
* [75 Sort Colors](#75-sort-colors)
* [76 Minimum Window Substring](#76-minimum-window-substring)
* [77 Combinations](#77-combinations)
* [78 Subsets](#78-subsets)
* [79 Word Search](#79-word-search)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array)
* [81 Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-ii)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [84 Largest Rectangle in Histogram](#84-largest-rectangle-in-histogram)
* [85 Maximal Rectangle](#85-maximal-rectangle)
* [86 Partition List](#86-partition-list)
* [87 Scramble String](#87-sramble-string)
* [89 Gray Code](#89-gray-code)
* [90 Subsets II](#90-subsets-ii)
* [91 Decode Ways](#91-decode-ways)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [93 Restore IP Addresses](#93-restore-ip-addresses)
* [94 Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
* [95 Unique Binary Search Trees](#95-unique-binary-search-trees)
* [96 Unique Binary Search Trees II](#96-unique-binary-search-trees)
* [97 Interleaving String](#97-interleaving-string)
* [98 Validate Binary Search Tree](#98-validate-binary-search-tree)
* [99 Recover Binary Search Tree](#99-recover-binary-search-tree)
* [100 Same Tree](#100-same-tree)
* [101 Symmetric Tree](#101-symmetric-tree)
* [102 Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversal)
* [103 Binary Tree Zigzag Level Order Traversal](#103-binary-tree-zigzag-level-order-traversal)
* [104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
* [105 Construct Binary Tree from Preorder and Inorder Traversal](#105-construct-binary-tree-from-preorder-and-inorder-traversal)
* [106 Construct Binary Tree from Inorder and Postorder Traversal](#106-construct-binary-tree-from-inorder-and-postorder-traversal)
* [107 Binary Tree Level Order Traversal II](#107-binary-tree-level-order-traversal-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [110 Balanced Binary Tree](#110-balanced-binary-tree)
* [111 Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-tree)
* [112 Path Sum](#112-path-sum)
* [113 Path Sum II](#113-path-sum-ii)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [115 Distinct Subsequences](#115-distinct-subsequences)
* [116 Populating Next Right Pointers in Each Node](#116-populating-next-right-pointers-in-each-node)
* [117 Populating Next Right Pointers in Each Node II](#117-populating-next-right-pointers-in-each-node-ii)
* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)
* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [124 Binary Tree Maximum Path Sum](#124-binary-tree-maximum-path-sum)
* [125 Valid Palindrome](#125-valid-palindrome)
* [126 Word Ladder](#126-word-ladder)
* [127 Word Ladder II](#127-word-ladder-ii)
* [128 Longest Consecutive Sequence](#128-longest-consecutive-sequence)
* [129 Sum Root to Leaf Numbers](#129-sum-root-to-leaf-numbers)
* [130 Surrounded Regions](#130-Surrounded-regions)
* [131 Parlindrome partitioning](#131-parlindrome-partitioning)
* [132 Parlindrome partitioning II](#132-parlindrome-partitioning-ii)
* [133 Clone Graph](#133-clone-graph)
* [134 Gas Station](#134-gas-station)
* [135 Candy](#135-candy)
* [136 Single Number](#136-single-number)
* [137 Single Number II](#136-single-number-ii)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [139 Word Break](#139-word-break)
* [140 Word Break II](#140-word-break-ii)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [144 Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
* [145 Binary Tree Postorder Traversal](#145-binary-tree-postorder-traversal)
* [146 LRU Cache](#146-lru-cache)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [149 Max Points on a Line](#149-max-points-on-a-line)
* [150 Evaluate Reverse Polish Notation](#150-Evaluate-Reverse-Polish-Notation)
* [151 Reverse Words in a String](#151-reverse-words-in-a-string)
* [152 Maximum Product Subarray](#152-maximum-product-subarray)
* [153 Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
* [154 Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
* [155 Min Stack](#155-min-stack)
* [156 Binary Tree Upside Down](#156-binary-tree-upside-down)
* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characters-given-read4-ii-call-multiple-times) 
* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
* [161 One edit distance](#161-one-edit-distance)
* [162 Find Peak Element](#162-find-peak-element)
* [163 Missing Ranges](#163-missing-ranges)
* [164 Maximum Gap](#164-maximum-gap)
* [165 Compare Version Numbers](#165-compare-version-numbers)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [168 Excel Sheet Column Title](#168-excel-sheet-column-title)
* [169 Majority Element](#169-majority-element)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)
* [171 Excel Sheet Column Number](#171-excel-sheet-column-number)
* [172 Factorial Trailing zeros](#172-factorial-trailing-zeros)
* [173 Binary Search Tree Iterator](#173-binary-search-tree-iterator)
* [174 Dungeon Game](#174-dungeon-game)
* [179 Largest Number](#179-largest-number)
* [186 Reverse Words in a String II](#186-reverse-words-in-a-string-ii)
* [187 Repeated DNA Sequences](#187-repeated-dna-sequences) 
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
* [189 Rotate Array](#189-rotate-array)
* [190 Reverse Bits](#190-reverse-bits)
* [191 Number of 1 Bits](#191-number-of-1-bits)
* [198 House Robber](#198-house-robber)
* [199 Binary Tree Right Side View](#199-binary-tree-right-side-view)
* [200 Number of Islands](#200-number-of-islands)
* [201 Bitwise AND of Numbers Range](#201-bitwise-and-of-numbers-range)
* [202 Happy Number](#202-happy-number)
* [203 Remove Linked List Elements](#203-remove-linked-list-elements)
* [204 Count Primes](#204-count-primes)
* [205 Isomorphic Strings](#205-isomorphic-strings)
* [206 Reverse Linked List](#206-reverse-linked-list)
* [207 Course Schedule](#207-course-schedule)
* [208 Implement Trie Prefix Tree](#208-implement-trie-prefix-tree)
* [209 Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
* [210 Course Schedule II](#210-course-schedule-ii)
* [211 Add and Search Word Data structure design](#211-add-and-search-word-data-structure-design)
* [212 Word Search II](#212-word-search-ii)
* [213 House Robber II](#213-house-robber-ii)
* [214 Shortest Palindrome](#214-shortest-palindrome)
* [215 Kth Largest Element in an Array](#215-kth-largest-element-in-an-array)
* [216 Combination Sum III](#216-combination-sum-iii)
* [217 Contains Duplicate](#217-contains-duplicates)
* [218 The Skyline Problem](#218-the-skyline-problem)
* [219 Contains Duplicate II](#219-contains-duplicates-ii)
* [220 Contains Duplicate III](#220-contains-duplicates-iii)
* [221 Maximal Square](#221-maximal-square)
* [222 Count Complete Tree Nodes](#222-count-complete-tree-nodes)
* [223 Rectangle Area](#223-rectangle-area)
* [224 Basic Calculator](#224-basic-calculator)
* [225 Implement Stack using Queues](#225-implement-stack-using-queues)
* [226 Invert Binary Tree](#226-invert-binary-tree)
* [227 Basic Calculator II](#227-basic-calculator)
* [228 Summary Ranges](#228-summary-ranges)
* [229 Majority Element II](#229-majority-element-ii)
* [230 Kth Smallest Element in a BST](#230-kth-smallest-element-in-a-bst)
* [231 Power of Two](#231-power-of-two)
* [232 Implement Queue using Stacks](#232-implement-queue-using-stacks)
* [233 Number of Digit One](#233-number-of-digit-one)
* [234 Palindrome Linked List](#234-palindrome-linked-list)
* [235 Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-tree)
* [236 Lowest Common Ancestor of a Binary Tree](#236-lowest-common-ancestor-of-a-binary-tree)
* [237 Delete Node in a Linked List](#237-delete-node-in-a-linked-list)
* [238 Product of Array Except Self](#238-product-of-array-except-self)
* [239 Sliding Window Maximum](#239-sliding-window-maximum)
* [240 Search a 2D Matrix II](#240-search-a-2d-matrix-ii)
* [241 Different Ways to Add Parentheses](#241-different-ways-to-add-parentheses)
* [242 Valid Anagram](#242-Valid Anagram)
* [243 Shortest Word Distance](#243-shortest-word-distance)
* [244 Shortest Word Distance II](#244-shortest-word-distance-ii)
* [245 Shortest Word Distance III](#245-shortest-word-distance-iii)
* [246 Strobogrammatic Number](#246-strobogrammatic-number)
* [247 Strobogrammatic Number](#247-strobogrammatic-number-ii)
* [248 Strobogrammatic Number](#248-strobogrammatic-number-iii)
* [249 Group Shifted Strings](#249-group-shifted-strings)
* [250 Count Univalue Subtrees](#250-count-univalue-subtrees)
* [251 Flatten 2D Vector](#251-flatten-2d-vector)
* [252 Meeting Rooms](#252-meeting-rooms)
* [253 Meeting Rooms II](#253-meeting-rooms-ii)
* [254 Factor Combinations](#254-factor-combinations)
* [255 Verify Preorder Sequence in Binary Search Tree](#255-verify-preorder-sequence-in-binary-search-tree)
* [256 Paint House](#256-paint-house)
* [257 Binary Tree Paths](#257-binary-tree-paths)
* [258 Add Digits](#258-add-digits)
* [259 3Sum Smaller](#259-3sum-smaller)
* [260 Single Number III](#260-single-number-iii)
* [261 Graph Valid Tree](#261-graph-valid-tree)
* [263 Ugly Number](#263-ugly-number)
* [264 Ugly Number II](#264-ugly-number-ii)
* [265 Paint House II](#265-paint-house-ii)
* [266 Palindrome Permutation](#266-palindrome-permutation)
* [267 Palindrome Permutation II](#267-palindrome-permutation-ii)
* [268 Missing Number](#268-missing-number)
* [269 Alien Dictionary](#269-alien-dictionary)
* [270 Closest Binary Search Tree Value](#270-Closest Binary Search Tree Value)
* [271 Encode and Decode Strings](#271-encode-and-encode-strings)
* [272 Closest Binary Search Tree Value II](#270-Closest Binary Search Tree Value II)
* [273 Integer to English Words](#273-integer-to-english-words)
* [274 H-Index](#274-h-index)
* [275 H-Index II](#275-h-index-ii)
* [276 Paint Fence](#276-Paint-fence)
* [277 Find the Celebrity](#277-Find the Celebrity)
* [278 First Bad Version](#278-first-bad-version)
* [279 Perfect Squares](#279-perfect-squares)
* [280 Wiggle Sort](#280-wiggle-sort)
* [281 Zigzag Iterator](#281-zigzag-iterator)
* [282 Expression Add Operators](#282-expression-add-operators)
* [283 Move Zeroes](#283-move-zeroes)
* [284 Peeking Iterator](#284-peeking-iterator)
* [285 Inorder Successor in BST](#285-inorder0-successor-in-bst)
* [286 Walls and Gates](#286-walls-and-gates)
* [287 Find the Duplicate Number](#287-find-the-duplicate-number)
* [288 Unique Word Abbreviation](#288-unique-word-abbreviation)
* [289 Game of Life](#289-game-of-life)
* [290 Word Pattern](#290-word-pattern)
* [291 Word Pattern II](#291-word-pattern-ii)
* [292 Nim Game](#292-nim-game)
* [293 Flip Game](#293-flip-game)
* [294 Flip Game II](#294-flip-game)
* [295 Find Median from Data Stream](#295-find-median-from-data-stream)
* [296 Best Meeting Point](#296-best-meeting-point)

###Others

* [1 Search a 2D Matrix II](#1-search-a-2d-matrix-ii)
* [2 First Bad Version](#2-first-bad-version)
* [3 Compare Strings](#3-compare-strings)
* [4 Longest Common Substring](#4-longest-common-substring)
* [5 Insert in Sorted Linked List](#5-insert-in-sorted-linked-list)
* [6 Is Bipartite](#6-is-bipartite)
* [7 Lowest Common Ancestor](#7-lowest-common-ancestor)
* [8 Median tracker](#8-median-tracker)
* [9 95 Percentile](#9-95-percentile)
* [10 Perfect shuffle](#10-perfect-shuffle)
* [11 Reservoir sample](#11-reservoir-sample)
* [12 Random7 Using Random5](#12-random7-using-random5)
* [13 Random1000 using random5](#13-random1000-using-random5)
* [14 Array deduplication](#14-array-deduplication)
* [15 Move 0s to the end](#15-move-0s-to-the-end)
* [16 Largest and Samllest](#16-largest-and-smallest)
* [17 Sort in specific order](#17-sort-in-specific-order)
* [18 Closest number in binary search tree](#18-closest-number-in-binary-search-tree)
* [19 Delete In Binary Search Tree](＃19-delete-in-binary-search-tree)
* [20 Cutting wood](#20-cutting-wood)
* [21 Merge stone](#21-merge-stone)
* [22 Binary Tree Path Sum To Target](#22-binary-tree-path-sum-to-target)
* [23 Common Elements in Three Sorted Array](#23-common-elements-in-three-sorted-array)
* [24 Kth smallest number in sorted matrix](#24-kth-smallest-number-in-sorted-matrix)
* [25 String Abbreviation Matching](#25-string-abbreviation-matching)
* [26 Permutation index](#26-permutation-index)
* [27 Permutation index II](#27-permutation-index-ii)
* [28 SellTicket](#28-sellticket)
* [29 Uneaten leaves](#29-uneaten-leaves)
* [30 Longest Chain](#30-longest-chain)
* [31 Friend Circle](#31-friend-circle)
* [32 Stock Max](#32-stock-max)
* [33 Flipping bits](#33-flipping-bits)
* [34 Hamming distance](#34-hamming-distance)
* [35 Find a pair with given sum in a Balanced BST](#35-Find-a-pair-with-given-sum-in-a-Balanced-BST)
* [36 Sliding window maximum](#36-sliding-window-maximum)



<br>


### 1 Two Sum
>Given an array of integers, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

>You may assume that each input would have exactly one solution.

>Input: numbers={2, 7, 11, 15}, target=9

>Output: index1=1, index2=2

**Solution1**: Use hashmap to record the number and its index, each time check if map containsKey target - num[i].

**Time complexity** O(n)

**Space** O(n)

```java
   public int[] twoSum(int[] numbers, int target) {
        //use hashmap
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int[] result = new int[2];
        if(numbers == null || numbers.length == 0) return result;
        
        for(int i = 0; i < numbers.length; i++){
            if(map.containsKey(target - numbers[i])){
                result[0] = map.get(target - numbers[i]) + 1;
                result[1] = i + 1;
                return result;
            }
            map.put(numbers[i], i);
        }
        return result;
    }
```    
	
**Solution2**: We can first sort the numbers. Then use two pointers, the first pointer points to the begining and the second points to the end. Each time compares the target and num[p1]+num[p2], if target is bigger, p1++, else p2--. But it doesn't work for this problem, because we need to return the index. If we are requested to return the nunbers, we can use the following way.

**Time**: O(nlgn)

**Space**: O(1)

```java
    //this function returns the numbers, not the index
    public int[] twoSum(int[] numbers, int target) {
        //First sort, then use two pointers
        int[] res = new int[2];
        if(numbers == null || numbers.length <= 1) return res;
        Arrays.sort(numbers);
        int l = 0;
        int r = numbers.length -1;
        while(l < r){
            if(numbers[l] + numbers[r] == target){
                res[0] = numbers[l];
                res[1] = numbers[r];
                return res;
            }else if(numbers[l] + numbers[r] > target)
                r--;
            else l++;
        }
        return res;
    }

```

<br>

**Related**: Return all pairs 's indexs.

> for example: given {3, 5, 3, 2, 4, 4}, target = 7, return [[1, 3], [0, 4], [2, 4], [0, 5], [2, 5]]

```java
  public List<List<Integer>> allPairs(int[] array, int target) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (array == null || array.length == 0) {
      return res;
    }
    Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
    for (int i = 0; i < array.length; i++) {
      List<Integer> indexs = map.get(target - array[i]);
      if (indexs != null) {
        for (Integer j : indexs) {
          List<Integer> cur = new ArrayList<Integer>();
          cur.add(j);
          cur.add(i);
          res.add(cur);
        }
      }
      List<Integer> temp = map.get(array[i]);
      if (temp == null) {
        map.put(array[i], new ArrayList<Integer>());
      }
      map.get(array[i]).add(i);
    }
    return res;
  }

```

<br>

**Related**: return all distinct pairs.

> for example: given {2, 1, 3, 2, 4, 3, 4, 2}, target = 4, return [[1, 3], [2, 2]]

```java
  public List<List<Integer>> allPairs(int[] array, int target) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (array == null || array.length == 0) {
      return res;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i : array) {
      Integer temp = map.get(target - i);
      if (temp != null && temp == 1) {
        List<Integer> cur = new ArrayList<Integer>();
        cur.add(target - i);
        cur.add(i);
        res.add(cur);
        map.put(target - i, 0);
        map.put(i, 0);
      }
      if (!map.containsKey(i)) {
        map.put(i, 1);
      }
    }
    return res;
  }

```

<br>
<br>

### 2 Add Two Numbers

> You are given two linked lists representing two non-negative numbers.
> The digits are stored in reverse order and each of their nodes contain a single digit.
> Add the two numbers and return it as a linked list.
>
> **`Input:`** `(2 -> 4 -> 3) + (5 -> 6 -> 4)`
>
> **`Output`** `(7 -> 0 -> 8)`

**Idea**: 

Digits are stored in reverse order, that means `(2 -> 4 -> 3)` is `342`. When it reaches 10 after addition, the next node shall add 1 and current node shall only keep the unit number: `(3 -> 2) + (9 -> 1) = (2 -> 4)`; if one integer doesn't have more numbers, add the remaining digits to  result.


**Attention**: After both l1 and l2 reach to the end, check the carry. If carry != 0, add an additional node to the result. 

**More**: What if the numbers are store in order? It's a little complicated than the question above. One way is add the corresponding digits, notice that the numbers might have different number of bits, so we can not add from beginning. The other stupid method is first reverse the linkedlist, then use the method above. 

**java code**:

```java

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        ListNode fakeHead = new ListNode(-1);
        ListNode res = fakeHead;
        int carry = 0;
        while(l1 != null && l2 != null){
            int sum = l1.val + l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            res = res.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1 != null){
            int sum = l1.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l1 = l1.next;
            res = res.next;
        }
        while(l2 != null){
            int sum = l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            res.next = new ListNode(mod);
            l2 = l2.next;
            res = res.next;
        }
        if(carry != 0)
            res.next = new ListNode(carry);
        return fakeHead.next;
    }

```



**c++ Code**:

``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *p1 = l1, *p2 = l2;
        ListNode *r = new ListNode(0);
        ListNode *begin = r;
        int sum = 0;
        
        while (p1 && p2) {
            sum = p1->val + p2->val + sum / 10;
            r->next = new ListNode(sum % 10);
            p1 = p1->next;
            p2 = p2->next;
            r = r->next;
        }
        
        ListNode *px = NULL;
        if (p1) { px = p1; }
        else if (p2) { px = p2; }
        
        while (px) {
            sum = sum / 10 + px->val;
            r->next = new ListNode(sum % 10);
            px = px->next;
            r = r->next;
        }
        if (sum >= 10) { r->next = new ListNode(sum / 10); }
        
        return begin->next;
    }
    
};
```

The time complexity is O(m+n) and space complexity is O(m+n).

<br>
<br>

###3 Longest Substring without Repeating Characters
>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.


**Idea**: if encounter duplicates, start from the character after the dulicate appear at the first time. eg: abcab, at index 4 a is duplicated, we start count from index 1(after the first a).

//assume s is not null.

```java
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int l = 0;
        int r = 0;
        int max = 0;
        char[] arr = s.toCharArray();
        while (r < s.length()) {
            if (set.contains(arr[r])) {
                max = Math.max(max, r - l);
                while (set.contains(arr[r])) {
                    set.remove(arr[l++]);
                } 
            }
            set.add(arr[r++]);
        }
        return Math.max(max, r - l);
    }
```

There is another solution use primitive string methods, such as indexOf, subString and contains. Because indexOf and contains take O(n*m), so it's really slow. It can be AC by leetcode, but when network is bad, it may time limit exceeded.

```java

    public int lengthOfLongestSubstring(String s) {
    	if(s == null || s.length() == 0) return 0;  	
    	int longest = 0;
    	int current = 0;
    	StringBuilder sBuilder = new StringBuilder();
    	for(int i = 0, len = s.length(); i < len; i++){

    		if(sBuilder.toString().contains(s.charAt(i)+"")){
    			longest = Math.max(longest, current);
    			int index = sBuilder.indexOf(s.charAt(i)+"");
    			sBuilder = new StringBuilder(sBuilder.substring(index+1));
    			sBuilder.append(s.charAt(i));
    			current = sBuilder.length();
    		}else{
    			sBuilder.append(s.charAt(i));
    			current++;
    		}
    	}
    	longest = Math.max(longest, current);
   		return longest;        
    }

```
<br>




<br>

###4 Median of Two Sorted Arrays

>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

**Idea**: We need to find the median, thus if (lenA + lenB) % 2 == 1, we need to find the ((lenA + lenB)/2 + 1)th smallest element. If  (lenA + lenB) % 2 == 0, we return ( (lenA + lenB)/2)th + (lenA + lenB)/2 + 1)th)/ 2. So we can use the idea in find the kth element in an array. The steps are as follows:

- 1) find the k/2 element of A and B
- 2) when B[k/2 -1] = A[k/2 -1], then the kth element is A[k/2 -1]
- 3) if A[k/2 -1] < B[k/2 -1], then the kth element is not in A[0.....k/2 -1] and  B[k/2.....B.length -1]
- 4) if A[k/2 -1] > B[k/2 -1], then the kth element is not in B[0.....k/2 -1] and  A[k/2.....A.length -1]

**Time complexity ** O(log(m+n))



**Attention**: There are cases when one array is really longer than the other one, so we need to check the length of k/2 and length of array. Otherwise, there might be indexoutofbound exception. 


```java

    public double findMedianSortedArrays(int A[], int B[]) {
        if(A == null && B == null) return 0;
        if(A == null) return B.length % 2 == 0 ? (B[B.length/2 -1] + B[B.length/2])/2 : B[B.length/2];
        if(B == null) return A.length % 2 == 0 ? (A[A.length/2 -1] + A[A.length/2])/2 : A[A.length/2];
        return ((A.length + B.length) % 2 == 1) ? helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1):((helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 )) + helper(A, B, 0, A.length-1, 0, B.length-1, (A.length + B.length)/2 + 1))/2;
    }
    
    public double helper(int[] A, int[] B, int startA, int endA, int startB, int endB, int k){
        int lenA = endA - startA + 1;
        int lenB = endB - startB + 1;
        if(lenA > lenB) return helper(B, A, startB, endB, startA, endA, k);
        if(lenA == 0) return B[startB + k - 1];
        if(lenB == 0) return A[startA + k - 1];
        if(k == 1) return Math.min(A[startA], B[startB]);
        int posA = Math.min(k/2, lenA);
        int posB = k - posA;
        if(A[startA + posA -1] == B[startB + posB -1]) return A[startA + posA -1];
        if(A[startA + posA -1] < B[startB + posB -1]) return helper(A, B, posA+startA, endA, startB, posB+startB-1, k - posA);
        else return helper(A, B, startA, posA + startA -1, startB + posB, endB, k - posB);
        
    }

```

Another solution: not as efficient as above solution:

//assume nums1 is not null and nums2 is not null
```java
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {

        int len = nums1.length + nums2.length;
        if (len % 2 == 1) {
            return findMedianSortedArrays(nums1, nums2, len / 2 + 1, 0, nums1.length - 1, 0, nums2.length - 1);
        } else {
            return (findMedianSortedArrays(nums1, nums2, len / 2, 0, nums1.length - 1, 0, nums2.length - 1) + 
            findMedianSortedArrays(nums1, nums2, len / 2 + 1, 0, nums1.length - 1, 0, nums2.length - 1)) / (double)2;
        }
    }
    private int  findMedianSortedArrays(int[] nums1, int[] nums2, int k, int start1, int end1, int start2, int end2) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        if (len1 > len2) {
            return findMedianSortedArrays(nums2, nums1, k, start2, end2, start1, end1);
        } 
        if (len1 <= 0) {
            return nums2[start2 + k - 1];
        }
        if (k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }

        int compareLen = Math.min(len1, k/2);
        if (nums1[start1 + compareLen - 1] < nums2[start2 + compareLen - 1]) {
            return findMedianSortedArrays(nums1, nums2, k - compareLen, start1 + compareLen, end1, start2, end2);
        } else {
            return findMedianSortedArrays(nums1, nums2, k - compareLen, start1, end1, start2 + compareLen, end2);
        }
    }
```

Here is the python code for this problem. We defined two extra functions: `median()` will find the median from *one* given array. `shrink()` will get two shrinked arrays, while one is from the left side and the other is the right side from the given arrays. Because either array may contains the median with exactly the middle two items in the array. So the shrinking size of array will be slightly less.

For example, for array [1,2,6,7] and [3,4,5,8]. The median of two arrays is 4.5 . `median(A)` is 4, `median(B)` is 4.5. So we will shrink the left side of A, and shrink the right side of B. So `shrink(A, B, true)` will be `[2,6,7], [3,4,5]`.

``` python
class Solution:
    def median(self, array):
        n = len(array)
        if n == 1:
            return array[0]
        elif n % 2 == 0:
            return float((array[n/2] + array[n/2 - 1])) / 2
        else:
            return array[n/2]
            
    def shrink(self, A, B, A_isleft):
        a, b = len(A), len(B)
        n = (b-1) / 2 if a > b else (a-1) / 2
        if A_isleft:
            return A[:a-n], B[n:]
        else:
            return A[n:], B[:b-n]
    
    # @return a float
    def findMedianSortedArrays(self, A, B):
        if not A and not B: raise ValueError(message="Two empty arrays")
        
        if not A:
            return self.median(B)
        
        if not B:
            return self.median(A)
            
        if len(A) <= 2 or len(B) <= 2:
            return self.median(sorted(A+B))
        
        A_isleft = self.median(A) > self.median(B)
        a, b = self.shrink(A, B, A_isleft)
        return self.findMedianSortedArrays(a, b)
```




<br>
<br>


###5 Longest Palindromic Substring
>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

**Idea**:

- 1) solution1: use dp, we dp[j][i] == true represents that j...i is a parlindromic substring.
- 2) solution2: for each character s[i], we find the longest substring whose center is s[i] 

**solution1 code**

```java
    public String longestPalindrome(String s) {
        boolean[][] arr = new boolean[s.length()][s.length()];
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (s.charAt(j) == s.charAt(i) && (i - j <= 2 || arr[j + 1][i - 1])) {
                    arr[j][i] = true;
                    if (i - j + 1 > res.length()) {
                        res = s.substring(j, i + 1);
                    }
                }
            }
        }
        return res;
    }

```


**solution2 code**

```java

    public String longestPalindrome(String s) {
        if(s == null || s.length() <= 1) return s;
        int max = 0;
        String res = "";
        for(int i = 0; i < s.length(); i++){
            String mid = helper(s, i-1, i+1);
            String left =  helper(s, i-1, i);
            String right =  helper(s, i, i+1);
            String temp = mid.length() > left.length() ? mid : left;
            temp = temp.equals(mid) ? (mid.length() > right.length() ? mid : right) : (left.length() > right.length() ? left : right);
            if(temp.length() > max){
                max = temp.length();
                res = temp;
            }
        }
        return res;
  	}
  	
  	public String helper(String s, int l, int r){
  	    while(l >= 0 && r < s.length()){
  	        if(s.charAt(l) == s.charAt(r)) {
  	            l--;
  	            r++;
  	        }else{
  	            return s.substring(l+1, r);
  	        }
  	    }
  	    return s.substring(l+1, r);
  	}
  	

```

###6 Zigzag Conversion
>The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
<pre>

P   A   H   N
A P L S I I G
Y   I   R

</pre>
And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

string convert(string text, int nRows);
convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".


** Idea**: 

size of zigzag: 2 * nRows - 2;

index of middle element : size - i + j - i ; i is the row number, j is the starting index of each row.

**code**:

```java

    public String convert(String s, int nRows) {
        if(s == null || nRows == 1) return s;
        StringBuilder res = new StringBuilder();
        int size = nRows * 2 - 2;
        for(int i = 0; i < nRows; i++){
            for(int j = i; j < s.length(); j += size){
                res.append(s.charAt(j));
                if(i != 0 && i != nRows-1 && ((size - i + j - i) < s.length()))
                    res.append(s.charAt(size - i + j - i));
            }
        }
        return res.toString();
    }

```

<br>
<br>

###7 Reverse Integer

> Reverse digits of an integer.

>Example1: x = 123, return 321

>Example2: x = -123, return -321

**Idea**: Record the sign of the number then take abs of the number. Move the lsb to the msb each time until the number change to 0.

**Attention**: After reverse, the number might overflow, then we need to check during reverse. When overflow, we return 0;

```java
    public int reverse(int x) {
        boolean sign = x > 0;
        x = Math.abs(x);
        int res = 0;
        while (x > 0) {
            if (res > (Integer.MAX_VALUE - x % 10) / 10) {
                return 0;
            }
            res = res * 10 + x % 10;
            x = x / 10;
        }
        return sign ? res : -res;
    }

```


###8 String to Integer atoi

>Implement atoi to convert a string to an integer.

>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.


**Some rules**: 

1) if can not convert, return 0;

2) if value if out of range, return INT_MAX or INT_MIN

3) discard any whitespace until first non-whitespace character is found

4) takes as many characters as possible to form a valid character until encounter an unvalid

```java
    public int myAtoi(String str) {
        str = str.trim();
        boolean positive = false;
        int res = 0;
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (i == 0) {
                if (c == '+') {
                    positive = true;
                } else if (isNum(c)) {
                    positive = true;
                    res = res * 10 + (c - '0');
                } else if (c != '-') {
                    break;
                }
                continue;
            }
            if (!isNum(c)) {
                break;
            }
            if (res > (Integer.MAX_VALUE - (c - '0')) / 10) {
                return positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res = res * 10 + (c - '0');
        }
        return positive ? res : -res;
    }
    private boolean isNum(char c) {
        return c >= '0' && c <= '9';
    }

```

5) python accepts integer larger than INT_MAX and integer smaller than INT_MIN, so make an if-else on that.

``` python
class Solution:
    INT_MIN = -2147483648
    INT_MAX = 2147483647

    if num < self.INT_MIN:
        return self.INT_MIN
    elif num > self.INT_MAX:
        return self.INT_MAX
```

<br>
<br>


###9 Palindrome Number

> Determine whether an integer is a palindrome. Do this without extra space.


**Idea**: Just like check if a string is a palindrom, we need to have two pointers, one from beginning and one from end. The difference is that for a integer, we can not use charAt. But we can still get the number of the two pointers use divide and mod. 


**Jave Code**

```java

    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        int digits = 1;
        int temp = x;
        while (temp >= 10) {
            digits *= 10;
            temp /= 10;
        }
        while (x != 0) {
            int left = x / digits;
            int right = x % 10;
            if (left != right) {
                return false;
            }
            x = (x % digits) / 10;
            digits /= 100;
        }
        return true;
    }

```

<br>
<br>


###10 Regular Expression Matching


>Implement regular expression matching with support for '.' and '*'.

<pre>
'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

</pre>

**Idea**:

-  Solution1: We divide it into two cases: 1) p[j+1] == '\*'  2)p[j+1] != '\*'. In the first case, it's a little complicated. Because * can match 0 or more characters. Thus we need to check match(s, p, i, j+2), match(s, p, i+1, j+2)....... In the second case we just need to compare s[i] and p[j], if s[i] == p[j] or p[j] == '.', we continue to compare(s, p, i+1, j+1).


**Solution1 code**:

```java

    public boolean isMatch(String s, String p) {
        return isMatch(s, p, 0, 0);
    }
    private boolean isMatch(String s, String p, int i, int j) {
        if (j == p.length()) {
            return i == s.length();
        }
        if (j < p.length() - 1 && p.charAt(j + 1) == '*') {
            while (i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')) {
                if (isMatch(s, p, i++, j + 2)) {
                    return true;
                }
            }
            return isMatch(s, p, i, j + 2);
        } else {
            if (i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')) {
                return isMatch(s, p, i + 1, j + 1);
            } else {
                return false;
            }
        }
    }
```


**Solution2**:

```java
    public boolean isMatch(String s, String p) {
        if((s == null && p == null) || p.equals(".*")) return true;
        boolean[][] dp = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        for(int i = 2; i <= p.length(); i++){
            if(p.charAt(i-1) == '*') dp[0][i] = dp[0][i-2];
        }
        for(int i = 1; i <= s.length(); i++){
            for(int j = 1; j <= p.length(); j++){
                if(p.charAt(j-1) != '*'){
                    if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.') dp[i][j] = dp[i-1][j-1];
                }else{
                   if(j > 1 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'))
                         dp[i][j] = dp[i][j-2] || dp[i-1][j];
                   else dp[i][j] = dp[i][j-2];
                }
            }
        }
        return dp[s.length()][p.length()];
     }

```


 

<br>
<br>

###11 Container with Most Water

>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.

**Idea**: Thea easiest way we can do is brute force. We calcuate the possible value with element with all the values after it. The time complexity is O(n^2). We have another efficient way. We set a window, l = 0, r = size -1. Each time we calculate the container of l r, then we compare the height[l] and height[r]. if(height[l] > height[r]), r--. Because we know that height[l] > height[r], if we move l pointer, then the volumn would decrease.


```java

    public int maxArea(int[] height) {
    	if(height == null || height.length == 0) return 0;
    	int left = 0;
    	int right = height.length-1;
    	int max = 0;
    	while(left < right){
    		max = Math.max(max, Math.min(height[left], height[right]) * (right-left));
    		if(height[right] > height[left]) left++;
    		else right--;
    	}
    	return max;
    }


```



<br>
<br>

###12 Integer to Roman

**Rules**:

See detailed rules at [12 Integer to Roman](#12-integer-to-roman)

**Idea**: Just calculate each digit and append it to result string.

**Code**:

```java
    public String intToRoman1(int num) {
        if(num <= 0 || num >= 4000) return "";
        int divide = 1000;
        int[] digits = new int[4];
        StringBuilder res = new StringBuilder();
        for(int i = 3; i >= 0 && num > 0; i--){
            digits[i] = num/divide;
            num = num % divide;
            divide /= 10;
        }
        res.append(helper(digits[3], 'M', ' ', ' '));
        res.append(helper(digits[2], 'C', 'D', 'M'));
        res.append(helper(digits[1], 'X', 'L', 'C'));
        res.append(helper(digits[0], 'I', 'V', 'X'));
        return res.toString();
    }
    
    public String helper(int i, char one, char five, char ten){
        StringBuilder res = new StringBuilder();
        switch(i){
            case 9: res.append(one + "" + ten); break;
            case 8: res.append(five + "" + one + "" + one + "" + one); break;
            case 7: res.append(five + "" + one + "" + one); break;
            case 6: res.append(five + "" + one); break;
            case 5: res.append(five); break;
            case 4: res.append(one + "" + five); break;
            case 3: res.append(one + "" + one + "" + one); break;
            case 2: res.append(one + "" + one); break;
            case 1: res.append(one);
        }
        return res.toString();
    }
```


**Better code on appending part**:

```java

    public String intToRoman(int num) {
    	if(num <= 0 || num >= 4000) return "";
    	int divide = 1000;
    	int[] digits = new int[4];
    	for(int i = 3; i >= 0 && num > 0; i--){
             digits[i] = num/divide;
             num = num % divide;
             divide /= 10;
         }
    	StringBuilder result = new StringBuilder();
    	result.append(convert(digits[3], 'M', ' ', ' '));
    	result.append(convert(digits[2], 'C', 'D', 'M'));
    	result.append(convert(digits[1], 'X', 'L', 'C'));
    	result.append(convert(digits[0], 'I', 'V', 'X'));
        
    	return result.toString();
    }
    
    public String convert(int digit, char one, char five, char ten){
    	StringBuilder result = new StringBuilder();
    	switch(digit)
    	{
    		case 9:
    			result.append(one);
    			result.append(ten);
    			break;
    		case 8:
    		case 7:
    		case 6:
    		case 5:
    			result.append(five);
    			for(int i = 5; i < digit; i++) result.append(one);
    			break;
    		case 4: 
    			result.append(one);
    			result.append(five);
    			break;
    		case 3:
    		case 2:
    		case 1:
    			for(int i = 0; i < digit; i++) result.append(one);
    			break;
    		default:
    			break;
    	}
    	return result.toString();
    }

```


<br>

<br>


###13 Roman to Integer 


>Given an integer, convert it to a roman numeral.

>Input is guaranteed to be within the range from 1 to 3999.


**Some rules about Roman**:

*Numbers*:

- I : 1
- V : 5
- X : 10
- L : 50
- C : 100
- D : 500
- M : 1000


*specific rules*: 

- When a larger number add some smaller numbers on its right side: larger + smaller
- when a larger number add some smaller numbers on its left side : larger - smaller
- when add a line on top of roman number, it means the number * 1000
- The same roman code can repeat at most three times eg: XL: 40, we cannot write it as XXXX


**Some Example**:

- I : 1
- II : 2
- III : 3
- IV : 4
- V : 5
- VI : 6
- VII: 7
- VIII : 8
- IX : 9
- X: 10
- XI : 11
- ......
- XC: 90
- CD : 400
- DCCC: 800
- .....

**Idea**:

- 1) Solution1: The most straight forward way is we add the value of each character. There are two cases to consider. 1. character I 2. character V, X....... For the first case, we just need to add I to the result. For the second case, we need to check if there are smaller characters before it. For example IV if 4, we need first add 1 then add 5 -2.

- 2)  Solution2 : We add a map for each pair. These additional space can help make our code more concisely.

**Solution1 code**:

```java
    public int romanToInt1(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') res += 1;
            else if( c == 'V'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 3;
                else res += 5;
            }else if(c == 'X'){
                if(i > 0 && s.charAt(i-1) == 'I') res += 8;
                else res += 10;
            }else if(c == 'L'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 30;
                else res += 50;
            }else if(c == 'C'){
                if(i > 0 && s.charAt(i-1) == 'X') res += 80;
                else res += 100;
            }else if(c == 'D'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 300;
                else res += 500;
            }else if (c == 'M'){
                if(i > 0 && s.charAt(i-1) == 'C') res += 800;
                else res += 1000;
            }
        }
        return res;
    }

```


**Solution2 code**: Use hashmap

```java

    public int romanToInt(String s) {
        if(s == null || s.length() == 0) return 0;
        int res = 0;
        Map<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == 'I') {
                res += map.get(c);
                continue;
            }
            if(i > 0 && map.get(s.charAt(i-1)) < map.get(c)) res = res + map.get(c) - 2 * map.get(s.charAt(i-1));
            else res += map.get(c);
        }
        return res;
    }

```



<br>

<br>


###14 Longest Common Prefix

> Write a function to find the longest common prefix string amongst an array of strings.

**Idea**: Choose the first string, then compare each of its character with the strings in strs. Return result when a mismatch happens.

**Time complexity**: O(n * m), n is the length of prefix string. M is the length of strs. 


**Java code**:


```java

    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
        StringBuilder res = new StringBuilder();
        String s = strs[0];
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            for(int j= 1; j < strs.length; j++){
                if((i < strs[j].length() && c != strs[j].charAt(i)) || i >= strs[j].length()) return res.toString();
            }
            res.append(c);
        }
        return res.toString();
    }


```


<br>

<br>


###15 3Sum

>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

>Note:

- Elements in a triplet (a,b,c) must be in **non-descending order**. (ie, a ≤ b ≤ c)

- The solution set **must not contain duplicate triplets**.
    
    
    
  		For example, given array S = {-1 0 1 2 -1 -4},
    	A solution set is:
    	(-1, 0, 1)
    	(-1, -1, 2)
    
**Idea**: We need to find the three numbers triplets that sum to 0. We can change to this problem to two subproblems. Target + (-target) = 0, num1 + num2 = - target.
Thus we can use the method in two sum to solve this problem. For each number num1 in the array, we find the other two numbers that sum to -num1. 

We first need to sort the array, then use two pointers to find the two sum numbers sum to -num1.

**Time** O(n ^ 2)

**Space** O(n ^ 2)

**Attention**: 

1) Silly check: num is null or num's length less than 3

2) *Duplication*: Both the threeSum and twoSum helper function need to check the duplication. If just need to check if the current is equal to the number before it. 

3) Non-descending order

```java
    public List<List<Integer>> threeSum(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length < 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 3; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = twoSum(num, i+1, -num[i]);
            for(List<Integer> l : current ){
                l.add(0, num[i]);
            }
            list.addAll(current);
        }
        return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
        int r = num.length -1;
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        int l = start;
        while(l < r){
            if(target == num[l] + num[r]){
                List<Integer> cur = new ArrayList<Integer>();
                cur.add(num[l]);
                cur.add(num[r]);
                list.add(cur);
                l++;
                r--;
                while(l < r && num[l] == num[l-1]) l++;
                while(l < r && num[r] == num[r+1]) r--;
            }else if(target < num[l] + num[r])
                r--;
            else l++;
        }
        return list;
    }
   
```


<br>
<br>


###16 3Sum Closest


>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. **You may assume that each input would have exactly one solution**.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
    
**Idea**: It's much similar with the method in three sum, the only difference here is that we calculate the minimum difference use the twosum helper funtion for each item in the array. 

**Attention**: 

1) Each time we compare the **abs** of the difference 

**Time** O(n ^ 2)

**Space** O(1)

```java
    public int threeSumClosest(int[] num, int target) {
	    if(num == null || num.length == 0) return 0;
	    int res = Integer.MAX_VALUE;
	    Arrays.sort(num);
	    for(int i = 0; i <= num.length -3; i++){
	        if(i != 0 && num[i] == num[i-1]) continue;
	        int dif = twoSumClosest(num, i + 1, target-num[i]);
	        if(Math.abs(dif) < Math.abs(res)) res = dif;
	    }
	    return res+target;
	}
	
	public int twoSumClosest(int[] num, int start, int target){
	    int r = num.length - 1;
	    int l = start;
	    int res = Integer.MAX_VALUE;
	    while(l < r){
	        if(Math.abs(num[l] + num[r] - target) < Math.abs(res))
	            res = num[l] + num[r] - target;
	        if(num[l] + num[r] == target)
	            return 0;
	        else if(num[l] + num[r] > target)
	            r--;
	        else 
	            l++;
	        
	    }
	    return res;
	}
	
```


<br>
<br>



###17 Number Combinations of a Phone Number

>  Given a digit string, return all possible letter combinations that the number could represent.

> A mapping of digit to letters (just like on the telephone buttons) is given below.

<pre>

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</pre>

> Note:

> Although the above answer is in lexicographical order, your answer could be in any order you want.


**Idea**: This problem is much similar to calculate the combinations. Each time we add each character of a string to all existing strings in the set. Then we go to the next String.

**Time Complexity** : O(k ^ n), k is possible choice of each digit, n is the length of digits


```java

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<String>();
        if(digits == null || digits.length() == 0) return res;
        for(int i = 0; i < digits.length(); i++){
            String cur = getLetters(digits.charAt(i));
            List<String> temp = new ArrayList<String>();
            if(res.size() == 0){
                for(int j = 0; j < cur.length(); j++){
                    res.add(cur.charAt(j) + "");
                }
            }else{
                for(String s : res){
                    for(int k = 0; k < cur.length(); k++){
                        temp.add(s + cur.charAt(k));
                    }
                }
                res = temp;      
            }
        }
        return res;
        
    }
    
    public String getLetters(char digit){
        switch(digit){
            case '9' : return "wxyz";
            case '8' : return "tuv";
            case '7' : return "pqrs";
            case '6' : return "mno";
            case '5' : return "jkl";
            case '4' : return "ghi";
            case '3' : return "def";
         case '2' : return "abc";
            default: return "";
        }
    }

```

<br>

<br>

###18 4Sum

>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

>Note:

- Elements in a quadruplet (a,b,c,d) must be in **non-descending order**. (ie, a ≤ b ≤ c ≤ d)

- The solution set must **not contain duplicate quadruplets**.
 
 
 For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

        A solution set is:
   	    (-1,  0, 0, 1)
        (-2, -1, 1, 2)
        (-2,  0, 0, 2)
    
<br>

**Idea**: Use the 3Sum to calculate 4Sum. 

**Time** O(n ^ 3)

**Space** O(n ^ 2)
```java
    public List<List<Integer>> fourSum(int[] num, int target) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if(num == null || num.length <= 3) return list;
        Arrays.sort(num);
        for(int i = 0; i <= num.length - 4; i++){
            if(i != 0 && num[i] == num[i-1]) continue;
            List<List<Integer>> current = threeSum(num, i+1, target - num[i]);
            for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
        }
        return list;
    }
    
    public List<List<Integer>> threeSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         for(int i = start; i <= num.length - 3; i++){
             if(i != start && num[i] == num[i-1]) continue;
             List<List<Integer>> current = twoSum(num, i+1, target - num[i]);
              for(List<Integer> l : current){
                l.add(0, num[i]);
            }
            list.addAll(current);
         }
         return list;
    }
    
    public List<List<Integer>> twoSum(int[] num, int start, int target){
         List<List<Integer>> list = new ArrayList<List<Integer>>();
         int r = num.length -1;
         int l = start;
         while(l < r){
             if(num[l] + num[r] == target){
                 List<Integer> cur = new ArrayList<Integer>();
                 cur.add(num[l]);
                 cur.add(num[r]);
                 list.add(cur);
                 l++;
                 r--;
                 while(l < r && num[l] == num[l-1]) l++;
                 while(l < r && num[r] == num[r+1]) r--;
             }else if(num[l] + num[r] < target) l++;
             else r--;
         }
         return list;
    }
 
``` 

**Similar solution based on two sum**:

```java
 public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Set<List<Integer>> set = new HashSet<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                int l = j + 1;
                int r = nums.length - 1;
                while (l < r) {
                    if (nums[i] + nums[j] + nums[l] + nums[r] == target) {
                        List<Integer> cur = new ArrayList<>();
                        cur.add(nums[i]);
                        cur.add(nums[j]);
                        cur.add(nums[l]);
                        cur.add(nums[r]);
                        if (!set.contains(cur)) {
                            set.add(cur);
                            res.add(cur);
                        }
                        l++;
                        r--;
                    } else if (nums[i] + nums[j] + nums[l] + nums[r] < target) {
                        l++;
                    } else {
                        r--;
                    }
                }
            }
        }
        return res;
    }
```
 
 **Other Idea**: we can twoSum combine twoSum to calculate 4Sum. 

 ```java
public class Solution {
    class Pair {
        public int firstIndex;
        public int secondIndex;
        public Pair(int firstIndex, int secondIndex) {
            this.firstIndex = firstIndex;
            this.secondIndex = secondIndex;
        }
    }
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums == null || nums.length < 4) {
            return res;
        }
        Map<Integer, List<Pair>> map = new HashMap<>();
        Arrays.sort(nums);
        generatePairs(nums, map);
        generateQuards(nums, map, target, res);
        return res;
    }
    private void generateQuards(int[] nums, Map<Integer, List<Pair>> map, int target, List<List<Integer>>  res) {
        Set<List<Integer>> set = new HashSet<>();
        for (Map.Entry<Integer, List<Pair>> entry : map.entrySet()) {
            int twoSum = entry.getKey();
            int compensate = target - twoSum;
            if (map.containsKey(compensate)) {
                List<Pair> list1 = map.get(twoSum);
                List<Pair> list2 = map.get(compensate);
                for (Pair p1 : list1) {
                    for (Pair p2 : list2) {
                        if (isValidFourSum(p1, p2)) {
                            List<Integer> cur = new ArrayList<>();
                            cur.add(nums[p1.firstIndex]);
                            cur.add(nums[p1.secondIndex]);
                            cur.add(nums[p2.firstIndex]);
                            cur.add(nums[p2.secondIndex]);
                            if (!set.contains(cur)) {
                                res.add(cur);
                                set.add(cur);
                            }
                        }
                    }
                }
            }
        }
    }
    private void generatePairs(int[] nums, Map<Integer, List<Pair>> map) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                int twoSum = nums[i] + nums[j];
                if (!map.containsKey(twoSum)) {
                    map.put(twoSum, new ArrayList<Pair>());
                }
                Pair pair = new Pair(i, j);
                map.get(twoSum).add(pair);
            }
        }
    }
    private boolean isValidFourSum(Pair el1, Pair el2) {
          return el1.secondIndex < el2.firstIndex;
    }
    private boolean isSameValuePair(Pair el1, Pair el2, int[] nums) {
        return nums[el1.firstIndex] == nums[el2.firstIndex] && nums[el1.secondIndex] == nums[el2.secondIndex];
    }
}

 ```
 

    

<br>
<br>



###19 Remove Nth Node From End of List
>Given a linked list, remove the nth node from the end of list and return its head.

For example,

   Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.
Try to do this in one pass.

**Idea**: Use two pointers, p1, p2. First move p1 k steps, then move p1 and p2 together until p1 change to null. At this time, p2 points to the node we need to delete. 

**Attention**: 

- 1) if after k steps, p1 is null, then return head.next
- 2) record pre

<br>
```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
    	if(head == null) return null;
    	ListNode l1 = head;
    	ListNode l2 = head;
    	while(n > 0){
    	    l1 = l1.next;
    	    n--;
    	}
    	if(l1 == null) return head.next;
    	ListNode pre = null;
    	while(l1 != null){
    	    pre = l2;
    	    l2 = l2.next;
    	    l1 = l1.next;
    	}
    	pre.next = l2.next;
    	return head;
    }

```


<br>
<br>

###20 Valid Parentheses

> Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

> The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.


**Idea**: Use a stack to record parentheses. When encounter ( , [, { push to stack.
when encounter ), ], } pop corresponding parentheses.


**Java code**:


```java


public boolean isValid(String s) {
    Deque<Character> stack = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);
        } else {
            if (!stack.isEmpty() && ((c == ')' && stack.peek() == '(') || (c == ']' && stack.peek() == '[') || (c == '}' && stack.peek() == '{'))) {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.isEmpty();
}


```



<br>


<br>



###21 Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Attention**:

- 1) Use a fake head, thus we don't need to check if head is null


```java
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }  
```


<br>
<br>


###22 Generate Parentheses

> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

> For example, given n = 3, a solution set is:

> "((()))", "(()())", "(())()", "()(())", "()()()"

**Idea**: insert "\(\)" to possible spots of every parentheses string. eg : (), we have three spaces to insert. Inspite of duplicates, there are two possible ()() or (()). 

**DFS Solution**: Number of ) shoule <= number of ( so far.

```java
  public List<String> validParentheses(int n) {
    List<String> res = new ArrayList<>();
    validParentheses(0, 0, n, res, new StringBuilder());
    return res;
  }
  private void validParentheses(int l, int r, int n, List<String> res, StringBuilder sb) {
    if (l + r == 2 * n) {
      res.add(sb.toString());
      return;
    }
    if (l < n) {
      validParentheses(l + 1, r, n, res, sb.append("("));
      sb.deleteCharAt(sb.length() - 1);
    }
    if (r < l) {
      validParentheses(l, r + 1, n, res, sb.append(")"));
      sb.deleteCharAt(sb.length() - 1);
    }
  }
```

**Iterative code **:

```java
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<String>();
        res.add("");
        if(n <= 0) return res;
        for(int i = 0; i < n; i++){
            List<String> cur = new ArrayList<String>();
            for(String s : res){
                for(int j = 0; j <= s.length(); j++){
                    String temp =  s.substring(0, j) + "()" + s.substring(j, s.length());
                    if(!cur.contains(temp)) cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    }

```


**Recursion**:

```java

    public List<String> generateParenthesis1(int n) {
    	List<String> list = new ArrayList<String>();
    	if(n == 0){
    		list.add("");
    		return list;
    	}else if (n == 1){
    		list.add("()");
    		return list;
    	}
    	
    	return helper(n);
    	
    }
    
    public List<String> helper(int n){
    	if(n == 0){
    		List<String> list = new ArrayList<String>();
    		list.add("");
    		return list;
    	}
    	List<String> list  = helper(n-1);
    	List<String> result = new ArrayList<String>();
    	for(String s : list){
    		for(int i = 0, len = s.length(); i <= len; i++){
    			String newS = s.substring(0, i) + "()" + s.substring(i, s.length());
    			if(!result.contains(newS)) result.add(newS);
    		}
    	}
    	return result;
    }

```

<br>

<br>


###23 Merge k Sorted Lists

> Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

**Idea**:

1) Solution1:

Use priorityqueue, add the head of k lists two queue, each time poll the smallest element from the queue then add the smallest.next to the queue until queue is empty. We need to to give another another parameter to priorityqueue when initialize.

```java

	PriorityQueue queue = new PriorityQueue(size, new Comparator<ListNode>(){
		public int compare(ListNode arg1, ListNode arg2){
			return arg1 - arg2;
		}
	});
	
```	


**Time complexity: nklgk** (lgk for insert element, nk elements).

**Space** O(k)

2) Solution2:

Use the idea in merge sort and use the method in [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists) to merge two elements.

**Time**: O(knlgk)

**Solution1 code**:

<br>
```java
    public static ListNode mergeKLists(List<ListNode> lists){
        if(lists == null || lists.size() == 0) return null;
        ListNode res = new ListNode(-1);
        ListNode h1 = res;
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){
            public int compare(ListNode l1, ListNode l2){
                return l1.val - l2.val;
            }
        });
        for(ListNode l : lists){
            if(l != null) queue.add(l);
        }
        while(!queue.isEmpty()){
            ListNode current = queue.poll();
            h1.next = current;
            h1 = h1.next;
            if(current.next != null)
                queue.offer(current.next);
        }
        return res.next;
	}
```

**Solution 2 code**
```java
	public  ListNode mergeKLists1(List<ListNode> lists){
		  if(lists == null || lists.size() == 0) return null;
		  return helper(lists, 0, lists.size()-1);
		}
		public ListNode helper(List<ListNode> lists, int start, int end){
		    if(start >= end) return lists.get(start);
		    int mid = (start + end)/2;
		    return mergeTwoLists(helper(lists, start, mid), helper(lists, mid+1, end));
		}
		
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	    if(l1 == null) return l2;
	    if(l2 == null) return l1;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(l1 != null && l2 != null){
	        if(l1.val > l2.val){
	            temp.next = l2;
	            l2 = l2.next;
	        }else{
	            temp.next = l1;
	            l1 = l1.next;
	        }
	        temp = temp.next;
	    }
	    if(l1 != null) temp.next = l1;
	    if(l2 != null) temp.next = l2;
	    return fakeHead.next;
    }
```

**Brute force** time limit exceeded

```java
method1: each time find the minimum from the k nodes, and add it to the result list. Time k * n * k = O(k^2*n)

	 /* Brute force: time limit exceeded*/
		public  ListNode mergeKLists2(List<ListNode> lists){
		    if(lists == null || lists.size() == 0) return null;
		    ListNode head = new ListNode(-1);
		    ListNode temp = head;
		    List<ListNode> l = new ArrayList<ListNode>();
		    for(int i = 0; i < lists.size(); i++){
		        if(lists.get(i) != null) l.add(lists.get(i));
		    }
		    while(l.size() > 0){
		    	int min = 0;
		        for(int i = 0; i < l.size(); i++){
		            if(l.get(i) == null) l.remove(i);
		            else {
		            	if(l.get(i).val < l.get(min).val) min = i;
		            }
		        }
		        if(l.size() > 0){
		        	temp.next = l.get(min);
		        	if(l.get(min).next != null) l.set(min,l.get(min).next);
		        	else l.remove(min);
		        	temp = temp.next;
		        }
		    }
		    return head.next;
		}
	
```

method2: each time merge two lists, until all lists are merged.
```java
	/*Brute force, use merge2 method */
	public  ListNode mergeKLists3(List<ListNode> lists) {
		if( lists == null || lists.size() == 0) return null;
		ListNode result = lists.get(0);
		for(int i = 1; i < lists.size(); i++){
			ListNode currentList = lists.get(i);
			result = mergeTwoLists(result, currentList);

		}
		
		return result;
	}

```

<br>


**Related**: Merge k sorted array.

**Idea**: for array, there is a difference with linkedlist, since linkedlist has the next pointer, which let us easily find the next element. For array, we need to record the index.

**Solution**:


```java
public class Solution {
  class Element {
    int row;
    int col;
    int val;
    Element(int row, int col, int val) {
      this.row = row;
      this.col = col;
      this.val = val;
    }
  }
  public int[] merge(int[][] arrayOfArrays) {
    if (arrayOfArrays == null) {
      return null;
    }
    if (arrayOfArrays.length == 0) {
      return new int[0];
    }
    PriorityQueue<Element> queue = new PriorityQueue<Element>(arrayOfArrays.length, new Comparator<Element>() {
      public int compare(Element e1, Element e2) {
        return e1.val - e2.val;
      }
    });
    int len = 0;
    for (int i = 0; i < arrayOfArrays.length; i++) {
      if (arrayOfArrays[i] != null && arrayOfArrays[i].length != 0) {
        len += arrayOfArrays[i].length;
        queue.offer(new Element(i, 0, arrayOfArrays[i][0]));
      }
    }
    int[] res = new int[len];
    int i = 0;
    while(!queue.isEmpty()) {
      Element e = queue.poll();
      res[i++] = e.val;
      if (e.col + 1 < arrayOfArrays[e.row].length) {
        queue.offer(new Element(e.row, e.col + 1, arrayOfArrays[e.row][e.col + 1]));
      }
    }
    return res;
  }
}

```





<br>
<br>


###24 Swap Nodes in Pairs

>Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

**Idea**: Just swap pair each time until end. 

**Attention**: If the number of nodes is odd, we need to add the last node to the list.

```java
   public ListNode swapPairs(ListNode head) {
	    if(head == null || head.next == null) return head;
	    ListNode fakeHead = new ListNode(-1);
	    ListNode temp = fakeHead;
	    while(head != null && head.next != null){
	        ListNode nextnext = head.next.next;
	        temp.next = head.next;
	        temp.next.next = head;
	        temp = head;
	        head = nextnext;
	    }
	    temp.next = head;
	    return fakeHead.next;
	  }
```

<br>
**Recursive way**:

```java
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        ListNode nextNext = head.next.next;
        next.next = head;
        head.next = swapPairs(nextNext);
        return next;
    }
```




<br>
<br>


###25 Reverse Nodes in kGroup

> Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
>
>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
>
>You may not alter the values in the nodes, only nodes itself may be changed.
>
>Only constant memory is allowed.
>

>For example,

>Given this linked list: 1->2->3->4->5

>For k = 2, you should return: 2->1->4->3->5

>For k = 3, you should return: 3->2->1->4->5r



**Idea**: Reverse k nodes each time then catenenate the current reverse list with the previous reverse list.


**Attention**:

- 1)the left-out nodes less than k nodes should remain the same.
- 2)For the first node of each reverse list, we should set it's next to null to avoid cycle or double linked list. 



```java

    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null || k <= 1) return head;
        int len = 0;
        ListNode temp = head;
        while(temp != null){
            len++;
            temp = temp.next;
        }
        if(k > len) return head;
        ListNode res = null, cur = null, pre = null, next = null, savehead = null;
        for(int i = 1; i <= len && i + k <= len+1; i += k){
            savehead = head;
            for(int j = 1; j <= k; j++){
                next = head.next;
                if(cur == null) {
                    cur = head;
                    cur.next = null;
                }else{
                    head.next = cur;
                    cur = head;
                }
                head = next;
            }
            if(res == null) res = cur;
            else{
                pre.next = cur;
            }
            pre = savehead;
            cur = null;
        }
        
        if(head != null) pre.next = head;
        return res;
    }

```



<br>

<br>



### 26 Remove Duplicates from Sorted Array

>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
>
>Do not allocate extra space for another array, you must do this in place with constant memory.
>
>For example,
>
>Given input array A = [1,1,2],
>
>Your function should return length = 2, and A is now [1,2].

**Idea**: Record an index, all element before this index contains no duplicates. Insert the new unduplicate element at index. 


**Java code**:

```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 1) return A.length;
        int count = 1;
        int pre = A[0];
        for(int i = 1; i < A.length; i++){
            if(A[i] == pre) continue;
            A[count++] = A[i];
            pre = A[i];
        }
        return count;
    }

```

**Use two pointers**:

```java
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int l = 0;
        int r = 1;
        while (r < nums.length) {
            if (nums[r] != nums[l]) {
                nums[++l] = nums[r++];
            } else {
                r++;
            }
        }
        return l + 1;
    }
```


<br>

<br>


###27 Remove Element

>Given an array and a value, remove all instances of that value in place and return the new length.

>The order of elements can be changed. It doesn't matter what you leave beyond the new length

**Idea**: if A[i] != elem, copy element to record index. 

**Java Code**:


```java

    public int removeElement(int[] A, int elem) {
        if(A == null || A.length == 0) return 0;
        int count = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == elem) continue;
            A[count++] = A[i];
        }
        return count;
    }


```

<br>

**Related**: Remove Adjacent Repeated Characters

> eg: “aaaabbbc” : “abc”

**Idea**: Left and right pointer

```java
  public String deDup(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int l = 0;
    int r = 1;
    while (r < input.length()) {
      if (arr[r] == arr[l]) {
        r++;
      } else {
        arr[l + 1] = arr[r++];
        l++;
      }
    } 
    return new String(arr, 0, l+1);
  } 

```

<br>

**Related**: Remove spaces

> eg: “   I     love MTV ” --> “I love MTV”

```java
  public String removeSpaces(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 0; i < arr.length; i++) {
      if ((i == 0 || arr[i-1] == ' ') && arr[i] == ' ') {
        continue;
      }
      arr[r++] = arr[i];
    }
    // check if last character is " "
    if (r != 0 && arr[r - 1] == ' ') {
      return new String(arr, 0, r - 1);
    }
    return new String(arr, 0, r);
  }

```
<br>

**Related**: remove certain characters:

>eg: input = "abcd", t = "ab" ===> "cd".

```java
  public String remove(String input, String t) {
    if (input == null || t == null || t.length() == 0) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 0; i < input.length(); i++) {
      boolean found = false;
      for (int j = 0; j < t.length(); j++) {
        if (arr[i] == t.charAt(j)) {
          found = true;
          break;
        }
      }
      if (!found) {
        arr[r++] = arr[i];
      }
    }
    return new String(arr, 0, r);
  }

```

<br>
**Related**: Remove Adjacent Repeated Characters

> eg: "abbbaaccz" → "aaaccz" → "ccz" → "z"

```java
  public String deDup(String input) {
    if (input == null || input.length() <= 1) {
      return input;
    }
    char[] arr = input.toCharArray();
    int r = 0;
    for (int i = 1; i < input.length(); i++) {
      if (r == -1 || arr[i] != arr[r]) {
        arr[++r] = arr[i];
      } else {
        --r;
        while (i < input.length() - 1 && arr[i] == arr[i+1]) {
          i++;
        } 
      }
    }
    return new String(arr, 0, r + 1);
  }
```


<br>

<br>


###28 Implement strStr

> Implement strStr().
>
>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
>
>Update (2014-11-02):

>The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.

**Idea**: It asks us to implement a function like indexOf(string) in java. The easiest way is a O(n^2) solution, just like the time complexity of indexOf. We begin from the first chracter of haystack, check if it has the needle begin at index i. We can also use KMP string match algorithm to implement it in O(n) time. See detail at [kmp](http://wishyouhappy.github.io/2014/12/26/kmp%20algorithm\(knuth-morris-pratt\)).

**Code of solution1**: O(n^2)


```java
	 public int strStr(String haystack, String needle) {
        if (haystack == null || needle == null || haystack.length() < needle.length()) {
            return -1;
        }
        for (int i = 0; i <= haystack.length() - needle.length(); i++) {
            boolean exist = true;
            for (int j = 0; j < needle.length(); j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    exist = false;
                }
            }
            if (exist) {
                return i;
            }
        }
        return -1;
    }

```
**Code of solution2**: O(n^2), use the library substring method

```java

    public int strStr(String haystack, String needle) {
       if (haystack == null || needle == null) {
           return -1;
       }
       for (int i = 0; i <= haystack.length() - needle.length(); i++) {
           String temp = haystack.substring(i, needle.length() + i);
           if (temp.equals(needle)) {
               return i;
           }
       }
       return -1;
    }

```

**Code of solution3**: O(n), KMP
 
```java

	public int strStr(String haystack, String needle){
		if (haystack == null || needle == null || (haystack.length() < needle.length())) { 
		    return -1;
		}
		if (needle.equals("")) {
		    return 0;
		}
		int[] helper = getHelperArray(needle);
		int i = 0;
		int j = 0;
		int textLen = haystack.length();
		int patternLen = needle.length();
		while (i < textLen && j < patternLen){
			if(haystack.charAt(i) == needle.charAt(j)){
				j++;
				i++;
			}
			if(j == patternLen){
				return i - patternLen;
				//j = helper[j-1]; //if we want find all matches. 
			} else if ((i < textLen && j < patternLen) &&haystack.charAt(i) != needle.charAt(j)){
				if(j != 0) {
				    j = helper[j-1];
				} else {
				    i++;
				}
			}
		}
		return -1;
	}
	
	public int[] getHelperArray(String pattern){
		int i = 1; //suffix
		int	j = 0; //prefix
		int len = pattern.length();
		int[] helper = new int[len];
		helper[0] = 0;
		
		while (i < len){
			if (pattern.charAt(i) == pattern.charAt(j)) {
				j++;
				helper[i] = j;
				i++;
			} else {
				if (j != 0) {
				    j = helper[j-1];
				} else{
					helper[i] = 0;
					i++;
				}
			}
		}
		return helper; 
	}

```

**Solution 4: Rolling hash**: Using this method, hash value might exceed long, we can use Biginteger or improve it use Rabin Karp

```java
    public int strStr(String haystack, String needle) {
        //assume haystack and needle is not null.
        if (haystack.length() < needle.length()) {
            return -1;
        }
        int base = 13;
        long needleHash = 0;
        long hayHash = 0;
        long temp = 1;
        for (int i = 0; i < needle.length(); i++) {
            needleHash += (int) needle.charAt(i) * temp;
            hayHash += (int) haystack.charAt(i) * temp;
            temp *= base;
        }
        if (needleHash == hayHash) {
            return 0;
        }
        temp = temp / base;
        for (int i = needle.length(); i < haystack.length(); i++) {
            hayHash -= (int) haystack.charAt(i - needle.length());
            hayHash /= base;
            hayHash += (int) haystack.charAt(i) * temp;
            if (needleHash == hayHash) {
                return i - needle.length() + 1;
            }
        }
        return -1;
    }
```


<br>

<br>




###29 Divide Two Integers

>Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.


**Idea**: Each integer can be represent as binary format, so n = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

We can respresent the result = (0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......

Thus [(0 or 1) * 2 ^ n +(0 or 1) * 2 ^ (n-1) + ......)] * divisor = dividend

Thus, we can calculate (0 or 1) * 2 ^ i, i from n to 0, and combine them together.


**Time complexity** : O(lgn)

**Space**: O(1)

**Attention**:

- abs (Integer.MIN_VALUE) = Integer.MIN_VALUE
- when calculate n, eg:  while(divisor <= (dividend >> 1)) we can not change to while((divisor<<1) <= dividend). It might overflow and keep loop forever.
- Take care of some corner case, eg: dividend = Integer.MIN_VALUE or divisor = Integer.MIN_VALUE


<br>

```java
	public int divide( int dividend, int divisor){
	       if(divisor == 0) return Integer.MAX_VALUE;
	       int result = 0;
	       boolean positive = ((dividend ^ divisor) >>> 31) == 0;
	       if(divisor == Integer.MIN_VALUE){
	           if(dividend == Integer.MIN_VALUE) return 1;
	           else return 0;
	       }
	       if(dividend == Integer.MIN_VALUE){
	           if(divisor == 1) return Integer.MIN_VALUE;
	           else if(divisor == -1) return Integer.MAX_VALUE;
	           dividend += Math.abs(divisor);
	           result += 1;
	       }
	       
	       dividend = Math.abs(dividend);
	       divisor = Math.abs(divisor);
	       
	       int count = 0;
	       while(divisor <= (dividend >> 1)){
	           count++;
	           divisor <<= 1;
	       }
	       
	       while(count >= 0){
	           if(dividend >= divisor){
	               result += 1 << count;
	               dividend -= divisor;
	           }
	           divisor >>= 1;
	           count --;
	       }
	       return positive ? result : -result;
	    }


```


<br>

<br>


###30 SubString with Concatenation of All Words

> You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

<pre>
For example, given:
S: "barfoothefoobarman"
L: ["foo", "bar"]
</pre>

You should return the indices: [0,9].
(order does not matter).

**Idea**: Store a dictionary of L. We use map to record each word of L and their occurence. Then for each index of S from 0, check if there is matches. 


**Java Code**:

```java

    public List<Integer> findSubstring(String S, String[] L) {
    	List<Integer> list = new ArrayList<Integer>();
    
    	if(S == null || S.length() == 0 || L == null || L.length == 0) return list;
    	if(S.length() < L.length * L[0].length()) return list;
    	
    	Map<String, Integer> map = new HashMap<String, Integer>();
    	for(int i = 0, len = L.length; i < len; i++){
    		String current = L[i];
    		if(map.containsKey(current)) map.put(current, map.get(current)+1);
    		else map.put(current, 1);
    	}
    	
    	int unitLen = L[0].length();
    	int sLen = S.length();
    	int totalStr = L.length;
    	int i = 0;
    	
    	while(sLen - i >= unitLen * totalStr){
    		Map<String, Integer> tempMap = new HashMap<String, Integer>(map);
    		for(int j = 0; j < totalStr; j++){
    			String current = S.substring(i+j*unitLen, i + (j+1)*unitLen);
    			if(!tempMap.containsKey(current)) break;
    			if(tempMap.get(current) == 1) tempMap.remove(current);
    			else tempMap.put(current,tempMap.get(current)-1);
    		}
			if(tempMap.size() == 0) list.add(i);
    		i++;
    	}
    	
    	return list;   
    }


```






<br>

<br>


###31 Next Permutation

>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

>The replacement must be in-place, do not allocate extra memory.

>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

<pre>
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>


**Idea**: The next permutation is the permutation that larger than the original permutation and the immediate larger one. We can also think this as a successor. We can find the next permutation by the following steps:

- 1) from the end, find the first non-increasing element, eg 1 2 3 5 4. Then we need to find is 3. Record this index. If it's -1, say 5, 4, 3, 2, 1., in this case we can reverse the array to 1, 2, 3, 4, 5 and end the function.

- 2) from the index1 we record in step 1, we find the smallest element larger than num[index1]. Record this index2.

- 3) swap element at index1 and index2, then reverse element after index1. 

For example. a permutation of 1 2 3 4 5 would be:

1 2 3 4 5

1 2 3 5 4

1 2 4 3 5

1 2 4 5 3

1 2 5 3 4

1 2 5 4 3

1 3 2 4 5

1 3 2 5 4

1 3 4 2 5

1 3 4 5 2 

.......


**Attention**

- 1) for step 1, when find the non-inceasing element we allow the equal element. eg: 1 2 5 4 4 3. We should find 2, the index1. Consider test case "[1 1]"
- 2) for step 2, we should find element larger than num[index1]. If change to >=, then it doesn't work. Consider test case "[1, 5, 1]"

**Java code**:

```java
    public void nextPermutation(int[] nums) {
        int index = nums.length - 2;
        while (index >= 0 && nums[index] >= nums[index + 1]) {
            index--;
        } 
        if (index == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int swapIndex = nums.length - 1;
        while (swapIndex >= 0 && nums[swapIndex] <= nums[index]) {
            swapIndex--;
        }
        swap(nums, index, swapIndex);
        reverse(nums, index + 1, nums.length - 1);
    }
    private void reverse(int[] nums, int l, int r) {
        while (l < r) {
            swap(nums, l++, r--);
        }
    }
    private void swap(int[] nums, int l, int r) {
        int temp = nums[l];
        nums[l] = nums[r];
        nums[r] = temp;
    }

```



<br>

<br>


###32 Longest Valid Parentheses


>Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

>For "(()", the longest valid parentheses substring is "()", which has length = 2.

>Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.


**Idea**: This problem has some similarities with the valid parentheses, we need to use the method in that problem to check if the current sequence of parentheses is valid. We use a stack to match the parentheses. The difference is that we store the **index** of the parenthese other than parenthese itself. Because there is only one type of parentheses, so it's ok to store just the index. 

Then how to calculate the longest valid parentheses? Like the valid parentheses problem, everytime, we encounter a '(', we push the current index. Then if the parentheses is ')', Obviously, if the stack is empty, then the previous parentheses sequence cannot be a valid parentheses, so we update the valid parentheses start position. Otherwise, we need to calculate the local longest parentheses. 

**Attention**: When we calculate the local longest, we need to compare the max with i-stack.peek() after we pop an element from the stack because we need to count in the previous valid sequences. Eg: (()(). 


**Java code**:

```java
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        int max = 0;
        int index = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                if (stack.isEmpty()) {
                    index = i + 1;
                    continue;
                } else {
                    stack.pop();
                    max = stack.isEmpty() ? Math.max(max, i - index + 1) : Math.max(max, i - stack.peek());
                }
            }
        }
        return max;
    }


```


<br>

<br>



###33 Search in Rotated Sorted Array


>Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>You are given a target value to search. If found in the array return its index, otherwise return -1.

>You may assume no duplicate exists in the array.

**Idea**: There is no duplicate, so after rotation, the array can be look as two parts, and these two parts are all in ascending order. Thus we can use the binary search method, and update the l and r pointer based on the comparison. See details of comparison on the code.


**Note**:

In the else if condition, we should use A[mid] >= A[l] other than A[mid] == A[l]. Otherwise can not pass 3, 1 use case.

**Java code**: 


**Time**: O(lgn)

```java

	    public int search(int[] A, int target) {
        if(A == null || A.length == 0) {
        	return -1;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
           int mid = l + (r - l) / 2;
           if (A[mid] == target) {
               return mid;
           } else if (A[mid] >= A[l]) {
               if (A[l] <= target && A[mid] > target) {
                   r = mid - 1;
               } else {
                   l = mid + 1;
               }
           } else {
               if (A[mid] < target && A[r] >= target) {
                   l = mid + 1;
               } else {
                   r = mid - 1;
               }
           }
        }
        return -1;
    }

```

**Another way**: It can handle duplicates, but this is not lg(n) at worst case. 


```java
       public int search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return -1;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) {
                return mid;
            } else if(A[mid] > target && A[mid] < A[r]) {
                r = mid-1;
            } else if(A[mid] < target && A[mid] > A[l]) {
                l = mid + 1;
            } else if (A[l] != target) {
                l++;
            } else {
                return l;
            }
        }
        return -1;
    }
```

<br>
<br>



###34 Search for a Range

>Given a sorted array of integers, find the starting and ending position of a given target value.

>Your algorithm's runtime complexity must be in the order of O(log n).

>If the target is not found in the array, return [-1, -1].

>For example,

>Given [5, 7, 7, 8, 8, 10] and target value 8,

>return [3, 4].

<br>

**Idea**: We need to find the range in O(lgn), thus binary search comes to mind. We could use binary search to find the target, then for the left and right part, we do binary search again to find the left boundary and right boundary.

The second solution is similar to the first one, the differce is that we do twice binary search to do the left boundary and right boundary. Remember to check the value of the two boundaries. Because in this method, we might not find the target element. 


**Solution1**:


```java
     public int[] searchRange(int[] A, int target) {
       int[] res = {-1, -1};
       int l = 0;
       int r = A.length - 1;
       while ( l <= r) {
           int mid = l + (r - l) / 2;
           if (target > A[mid]) {
               l = mid + 1;
           } else if (target < A[mid]) {
               r = mid - 1;
           } else {
               int lr = mid;
               int rl = mid;
               while (l <= lr) {
                   int mid1 = l + (lr - l) / 2;
                   if (target <= A[mid1]) {
                       lr = mid1 - 1;
                   } else {
                       l = mid1 + 1;
                   }
               }
               res[0] = l;
               while (rl <= r) {
                   int mid2 = rl + (r - rl) / 2;
                   if (target >= A[mid2]) {
                       rl = mid2 + 1;
                   } else {
                       r = mid2 - 1;
                   }
               }
               res[1] = r;
               return res;
           }
           
       }
       return res;
    }    

```


**Solution 2**:

```java
    public int[] searchRange(int[] A, int target) {
       int[] res = {-1, -1};
       int ll = 0;
       int lr = A.length - 1;
       int rl = 0;
       int rr = A.length - 1;
       while (ll <= lr) {
           int mid1 = ll + (lr - ll) / 2;
           if (A[mid1] >= target) {
               lr = mid1 - 1;
           } else {
               ll = mid1 + 1;
           }
       }
       while (rl <= rr) {
           int mid2 = rl + (rr - rl) / 2;
           if (A[mid2] <= target) {
               rl = mid2 + 1;
           } else {
               rr = mid2 - 1;
           }
       }
       if (ll <= rr) {
           res[0] = ll;
           res[1] = rr;
       }
       return res;
    }
```


**Related: first occurrence:**

```java
public int firstOccur(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return -1;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] >= target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    return (l < array.length && array[l] == target) ? l : -1;
}

```


**Related: last occurrence**:

```java
public int lastOccur(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return -1;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] <= target) {
        l = mid + 1;
      } else {
        r = mid - 1;
      }
    }
    return (r >= 0 && array[r] == target) ? r : -1;
}
```

**Related: find k closest**:
```java
public int[] kClosest(int[] array, int target, int k) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return array;
    }
    int[] res = new int[k];
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] == target) {
        l = mid;
        break;
      } else if (array[mid] > target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    int indexL = l - 1;
    int indexR = l;
    
    for (int i = 0; i < k; i++) {
      if (indexL >= 0 && indexR < array.length) {
        res[i] = Math.abs(array[indexL] - target) - Math.abs(array[indexR] - target) > 0 ? array[indexR++] : array[indexL--];
      } else if (indexL >= 0) {
        res[i] = array[indexL--];
      } else {
        res[i] = array[indexR++];
      }
    }
    
    return res;
  }
```

**Related: search in unknown size sorted array**:
```java
class Dictionary{
    int[] array = {1, 2, 4, 5, 6, 7, 8, 9, 10};
    public Integer get(int index){
        if (index >= array.length) {
            return null;
        }
        return array[index];
    }
}

public int search(Dictionary dict, int target) {
    // Write your solution here
    int bounds = findBound(dict, target);
    int l = 0;
    int r = bounds;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (dict.get(mid) == null || dict.get(mid) > target) {
        r = mid - 1;
      } else if (dict.get(mid) == target) {
        return mid;
      } else{
        l = mid + 1;
      }
    }
    return -1;
  }
  
  public int findBound(Dictionary dict, int target) {
    int i = 1;
    while(true) {
      if (dict.get(i) == null || dict.get(i) > target) {
        return i;
      } else {
        i *= 2;
      }
    }
  }
```

**Related: total occurrence**:

```java
  public int totalOccurrence(int[] array, int target) {
    // Write your solution here
    if (array == null || array.length == 0) {
      return 0;
    }
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      int mid = l + (r - l) / 2;
      if (array[mid] >= target) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    int l1 = 0;
    int r1 = array.length - 1;
    while (l1 <= r1) {
      int mid = l1 + (r1 - l1) / 2;
      if (array[mid] <= target) {
        l1 = mid + 1;
      } else {
        r1 = mid - 1;
      }
    }
    if (l <= r1) {
      return r1 - l + 1;
    }
    return 0;
  }
```

<br>
<br>


###35 Search Insert Position


>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

>You may assume no duplicates in the array.

>Here are few examples.

<pre>
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</pre>


<br>
**Idea**: Just like the method used in search range, we use binary search, when l > r, l is the first element larger then the target. 

**Time** : log(n)

```java 
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int l = 0;
        int r = A.length - 1;
        while (l <= r) {
            int mid = l + (r - l)/2;
            if (A[mid] == target) {
                return mid;
            } else if (A[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

```

<br>

<br>

###36 Valid Sudoku

>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

**Rules about sudoku**:

- 1) 9×9 grid
- 2) each column, each row, and each of the nine 3×3 sub-grids that compose the grid (also called "boxes", "blocks", "regions", or "sub-squares") contains all of the digits from 1 to 9

**Idea**: Check each row, each column and each 3*3 blocks.


**Java code**:

```java

    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length != 9 || board[0].length != 9) {
            return false;
        }
        for (int i = 0; i < 9; i++) {
            Set<Character> rSet = new HashSet<>();
            Set<Character> cSet = new HashSet<>();
            for (int j = 0; j < 9; j++) {
                if (rSet.contains(board[i][j]) || cSet.contains(board[j][i])) {
                    return false;
                }
                if (board[i][j] != '.') {
                    rSet.add(board[i][j]);
                }
                if (board[j][i] != '.') {
                    cSet.add(board[j][i]);
                }
            }
        }
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (!valid(board, i, j)) {
                    return false;
                }
            }
        }
        return true;
    }
    private boolean valid(char[][] board, int i, int j) {
        Set<Character> set = new HashSet<>();
        for (int x = i * 3; x < i * 3 + 3; x++) {
            for (int y = j * 3; y < j * 3 + 3; y++) {
                if (set.contains(board[x][y])) {
                    return false;
                }
                if (board[x][y] != '.') {
                    set.add(board[x][y]);
                }
            }
        }
        return true;
    }

```




<br>

<br>


###37 Sudoku Solver

>Write a program to solve a Sudoku puzzle by filling the empty cells.

>Empty cells are indicated by the character '.'.

>You may assume that there will be only one unique solution.


**Idea**: we solve the sudoku line by line, every time we fill in a filed, we check if is valid. We can use the method in * [36 Valid Sudoku](#36-valid-sudoku) to check the sudoku




**Java code**:

```java

    public void solveSudoku(char[][] board) {
        if (board == null || board.length != 9 || board[0].length != 9) {
            return;
        }
        solve(board, 0, 0);
    }
    private boolean solve(char[][] board, int i, int j) {
        if (j == 9) {
            return solve(board, i + 1, 0);
        }
        if (i == 9) {
            return true;
        }
        if (board[i][j] == '.') {
            for (int k = 1; k <= 9; k++) {
                board[i][j] = (char) (k + '0');
                if (isValid(board, i, j)) {
                    if(solve(board, i, j + 1)) {
                        return true;
                    }
                }
            }
            board[i][j] = '.';
            return false;
        }
        return solve(board, i, j + 1);
    }
    private boolean isValid(char[][] board, int i, int j) {
        for (int k = 0; k < 9; k++) {
            if ((board[i][k] == board[i][j] && k != j) || (board[k][j] == board[i][j] && k != i)) {
                return false;
            }
        }
        int row = (i / 3);
        int col = (j / 3);
        for (int x = row * 3; x < row * 3 + 3; x++) {
            for (int y = col * 3; y < col * 3 + 3; y++) {
                if (board[i][j] == board[x][y] && (x != i || y != j)) {
                    return false;
                }
            }
        }
        return true;
    }
	 
```



**Another solution**:

```java
    public void solveSudoku(char[][] board) {
      if (board == null || board.length != 9 || board[0].length != 9) {
          return;
      }
      solverHelper(board);
    }
    
  private boolean solverHelper(char[][] board){
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == '.') {
                    for (int k = 1; k <= 9; k++) {
                        board[i][j] = (char) ('0' + k);
                        if (isValid(board, i, j)) {
                             if (solverHelper(board)) {
                                 return true;
                             } else {
                                board[i][j] = '.';
                             }
                        } else {
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
  private boolean isValid(char[][] board, int i, int j) {
        for (int k = 0; k < 9; k++) {
            if ((board[i][k] == board[i][j] && k != j) || (board[k][j] == board[i][j] && k != i)) {
                return false;
            }
        }
        int row = (i / 3);
        int col = (j / 3);
        for (int x = row * 3; x < row * 3 + 3; x++) {
            for (int y = col * 3; y < col * 3 + 3; y++) {
                if (board[i][j] == board[x][y] && (x != i || y != j)) {
                    return false;
                }
            }
        }
        return true;
    }
```


<br>

<br>





###38 Count and Say
>The count-and-say sequence is the sequence of integers beginning as follows:

>1, 11, 21, 1211, 111221, ...

>1 is read off as "one 1" or 11.

>11 is read off as "two 1s" or 21.

>21 is read off as "one 2, then one 1" or 1211.

>Given an integer n, generate the nth sequence.

>Note: The sequence of integers will be represented as a string.


**Idea**: Calculate the string based on the previous one. Each time count the repeating times of each character. It's similar to compress string based on its repeating times.

**Java code**:


```java

    public String countAndSay(int n) {
        if(n <= 0) return "";
        if(n == 1) return "1";
        StringBuilder res = new StringBuilder();
        res.append(1);
        for(int i = 2; i <= n; i++){
            String temp = res.toString();
            StringBuilder cur = new StringBuilder();
            char pre = temp.charAt(0);
            int count = 1;
            for(int j = 1; j < temp.length(); j++){
                if(pre != temp.charAt(j)){
                    cur.append(count);
                    cur.append(pre);
                    pre = temp.charAt(j);
                    count = 1;
                }else count++;
            }
            cur.append(count);
            cur.append(pre);
            res = cur;
        }
        return res.toString();
    }


```

<br>

<br>

###39 Combination Sum
>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

> **The same repeated number may be chosen from C unlimited number of times.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

>The solution set must not contain duplicate combinations.

>For example, given candidate set 2,3,6,7 and target 7, 

<pre>

A solution set is: 
[7] 
[2, 2, 3] 

</pre>


**Idea**: We need to add combination in non-descending order, thus its better to first sort candidates. Off course, we can handle the duplicates and sequence in latter if we don't sort it. Then we add element to list, minus the current and go to the next recursion.


**Java code**:


```java

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if(candidates == null || candidates.length == 0) {
        return res;
    }
    Arrays.sort(candidates);
    combinationSum(candidates, target, res, new ArrayList<Integer>(), 0);
    return res;
}
public void combinationSum(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
    if (target < 0) {
        return;
    }
    if (target == 0) {
        res.add(new ArrayList<Integer>(cur));
        return;
    }
    for (int i = start; i < candidates.length; i++) {
        cur.add(candidates[i]);
        combinationSum(candidates, target-candidates[i], res, cur, i);
        cur.remove(cur.size()-1);
    }
}

```


<br>

<br>


###40 Combination Sum II

>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

>**Each number in C may only be used once in the combination.**

>Note:

>All numbers (including target) will be positive integers.

>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).

<pre>

The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

</pre>



**Idea**: The difference with [39 Combination Sum](#39-combination-Sum)] is that in ths problem we can only use each number once. So when go to next recursion, the start position should change to i+1, so that it will add itself again. 

**Java code**:

```java
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if(candidates == null || candidates.length == 0) {
            return res;
        }
        Arrays.sort(candidates);
        combinationSum(candidates, target, res, new ArrayList<Integer>(), 0);
        return res;
    }
    public void combinationSum(int[] candidates, int target, List<List<Integer>> res, List<Integer> cur, int start){
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }
            cur.add(candidates[i]);
            combinationSum(candidates, target-candidates[i], res, cur, i + 1);
            cur.remove(cur.size()-1);
        }
    }

```

<br>

<br>


###41 First Missing Positive

>Given an unsorted integer array, find the first missing positive integer.

>For example,

>Given [1,2,0] return 3,

>and [3,4,-1,1] return 2.

>Your algorithm should run in O(n) time and uses constant space.

<br>

**Idea**: This problem has the same idea with the counting sort problem. If no element is missing, then A[A[i]-1] = A[i]. Thus, we just need to put the element to its original place and have another pass to check the miss element.
 


**Java code**:


```java

    public int firstMissingPositive(int[] A) {
        if(A == null || A.length == 0) return 1;
        for(int i = 0; i < A.length; i++){
            if(A[i] > 0 && A[i] - 1 < A.length && A[A[i]-1] != A[i]){
                int temp = A[A[i]-1];
                A[A[i]-1] = A[i];
                A[i] = temp;
                i--;
            } 
        }
        for(int i = 0; i < A.length; i++){
            if(A[i] != i+1) return i+1;
        }
        return A.length+1;
    }

```


<br>
<br>


###42 Trapping Rain Water

>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

**Idea**: 

- 1) Solution1: Like [11 Container with Most Water](#11-container-with-most-water), we record two pointers, l and r, min = min(A[l], A[r]), if A[l] < A[r], we move l right, and add water if A[l] < min; similarly, if A[l] > A[r], we move r left, and if A[r] < min, we add water. When l >= r, we get the total volumn. 


```java

 public int trap(int[] A) {
    if(A == null || A.length == 0) return 0;
    int res = 0;
    int l = 0;
    int r = A.length - 1;
    while(l < r){
        int min = Math.min(A[l], A[r]);
        if(A[l] < A[r]){
            l++;
            while(l < r && A[l] < min){
                res += min - A[l++];
            }
        }else{
            r--;
            while(l < r && A[r] < min){
                res += min - A[r--];
            }
        }
    }
    return res;
  }

```

<br>

- 2)solution 2 : we traverse the array two times, left to right and right to left. Then we can get the min(max height on the left of A[i], max height on the right of A[i]). So add the capacity of each bar, we get the total capacity.

```java

	  public int trap(int[] A) {
		if(A == null || A.length == 0) return 0;
		int[] left = new int[A.length];
		int max = 0;
		for(int i = 0; i < A.length; i++){
		    left[i] = max;
		    max = Math.max(max, A[i]);
		}
		
		int res = 0;
		max = 0;
		for(int i = A.length-1; i>=0; i--){
		    res += Math.min(max, left[i]) - A[i] > 0 ? (Math.min(max, left[i]) - A[i]): 0 ;
		    max = Math.max(max, A[i]);
		}
		return res;
	}

```




<br>
<br>




###43 Multiply Strings


>Given two numbers represented as strings, return multiplication of the numbers as a string.

>Note: The numbers can be arbitrarily large and are non-negative.

<br>

**Idea**: If length is n and m, result's length is n+m or n+m-1, result of index i = 0 * i + 1 * i-1 ..... i * 0


**Attention**: We should not add the leftmost zero.



**Java code**:

```java

    public String multiply(String num1, String num2) {
        if(num1 == null || num2 == null) return null;
        if(num1.equals("0") || num2.equals("0")) return "0";
        StringBuilder res = new StringBuilder();
        int cur = 0;
        for(int i= num1.length() + num2.length() -1;i >=0; i--){
            for(int j = Math.min(i-1, num1.length()-1);j >= 0; j--){
                if(j < num1.length() && ((i-j-1) < num2.length())) {
                    cur += (int)(num1.charAt(j) - '0') * (int)(num2.charAt(i-j-1) - '0');
                }
            }
            if(i != 0 || cur > 0) res.insert(0, cur % 10);
            cur = cur / 10;
        }
        return res.toString();
    }


```

<br>
<br>

###44 Wildcard Matching

> Implement wildcard pattern matching with support for '?' and '*'.

<pre>

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

</pre>

**Idea**: This problem is similar with [10 Regular Expression Matching](#10-regular-expression-matching). The difference is that '.' is replace with '?'. And '\*' can match any sequence including empty. We can use the method in [10 Regular Expression Matching](#10-regular-expression-matching). Or we use two pointers to record the return place in s and p when encounter a '\*'

**Iterative Code**:

```java
	 public boolean isMatch(String s, String p) {
   	    if(s == null && p == null || p.equals("*")) return true;
		int i = 0, j = 0, savei = -1, savej = -1;
		while(i < s.length()){
		    if(j < p.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')){
		        i++;
		        j++;
		    }else if(j < p.length() && p.charAt(j) == '*'){
		        savei = i;
		        savej = j++;
		    }else if(savej != -1){
		        j = savej + 1;
		        i = ++savei;
		    }else return false;
		}
		while(j < p.length() && p.charAt(j) == '*') j++;
		return j == p.length();
	}

```


**Recursion**: it might exceed the time limit

```java
		
    public boolean isMatch2(String s, String p) {
        if((s == null && p == null) || p.equals("*")) return true;
        return helper(s, p, 0, 0);
    }
    
    public boolean helper(String s, String p, int i, int j){
        if(j == p.length()) return i == s.length();
        if(p.charAt(j) != '*'){
            if(i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) return helper(s, p, i+1, j+1);
            else return false;
        }else{
            while(i < s.length()){
                if(helper(s, p, i++, j+1)) return true;
            }
            return helper(s, p, i, j+1);
        }
    }

```

<br>

**DP solution**: Two dimensional array.

```java
    public boolean isMatch(String s, String p) {
        boolean[][] arr = new boolean[p.length() + 1][s.length() + 1];
        arr[0][0] = true;
        for (int i = 0; i < p.length(); i++) {
            if (p.charAt(i) != '*') {
                for (int j = 0; j < s.length(); j++) {
                    arr[i + 1][j + 1] =  arr[i][j] && (s.charAt(j) == p.charAt(i) || p.charAt(i) == '?');
                }
            } else {
                if (i == 0) {
                    arr[i + 1][0] = true;
                }
                for (int j = 0; j < s.length(); j++) {
                    arr[i][j + 1] |= arr[i][j];
                    arr[i + 1][j] |= arr[i][j];
                    arr[i + 1][j + 1] |=  arr[i][j + 1];
                 }
            }
        }
        return arr[p.length()][s.length()];
    }
```

**DP solution**: One dimensional DP:

```java
    public boolean isMatch(String s, String p) {
        boolean[] arr = new boolean[s.length() + 1];
        arr[0] = true;
        for (int i = 0; i < p.length(); i++) {
            if (p.charAt(i) != '*') {
                for (int j = s.length() - 1; j >= 0; j--) {
                    arr[j + 1] =  arr[j] && (s.charAt(j) == p.charAt(i) || p.charAt(i) == '?');
                }
                arr[0] = false; // "" can only match "*+"
            } else {
                for (int j = 0; j < s.length(); j++) {
                    arr[j + 1] |=  arr[j];
                 }
            }
        }
        return arr[s.length()];
    }

```



<br>
<br>

###45 Jump Game II

>Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.

>Your goal is to reach the last index in the minimum number of jumps.

<pre>

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

</pre>
<br>

**Idea**: The basic idea is same with Jump Game. Difference is that in this problem we need to calculate the optimal steps. How can We get the minimum steps? The idea is that we only increase steps when we found that the **current position i is greater than the previous step max**, which means that if you want to reach further, you need to increase steps.  


**Java code**:

```java
    public int jump(int[] A) {
        if(A == null || A.length <= 1) return 0;
        int max = 0;
        int canReach = 0;
        int res = 0;
        for(int i = 0; i < A.length; i++){
            if(i > max) return -1;  // check if you can reach to the end.
            if(i > canReach){
                res++;
                canReach = max;
            }
            max = Math.max(max, i + A[i]);
        }
        return res;
    }

```
<br>

**Similar solution**:
```java

  public int minJump(int[] array) {
    int res = 0;
    int currentMax = 0;
    int max = 0;
    for (int i = 0; i < array.length && i <= max; i++) {
      if (currentMax < i) {
        res++;
        currentMax = max;
      }
      max = Math.max(max, array[i] + i);
    } 
    return max < array.length - 1 ? -1 : res;
  }

  //or
  public int jump(int[] nums) {
    int min = 0;
    int cur = 0;
    int max = 0;
    for (int i = 0; i < nums.length && i <= max; i++) {
        max = Math.max(max, i + nums[i]);
        if (cur <= i) {
            if (cur >= nums.length - 1) {
                return min;
            }
            min++;
            cur = max;
        }
    }
    return max < nums.length - 1 ? -1 : min;
  }
```
<br>
**Related: min steps to jump out of the array**
**Idea**: Based on the solution in jump game two, we need to check if the max can reach to the end of array. But this time we need to compare if max <= array.length - 1, because we need to jump out of array.

Also, we need to return the min steps to jump out the array, thus we need to check if based on the min steps, if we can reach out to the end of the array. 



```java
public int minJump(int[] array) {
    int res = 0;
    int currentMax = 0;
    int max = 0;
    for (int i = 0; i < array.length && i <= max; i++) {
      if (currentMax < i) {
        res++;
        currentMax = max;
      }
      if (currentMax > array.length) {
    	  return res;
      }
      max = Math.max(max, array[i] + i);
    } 
    return max <= array.length - 1 ? -1 : (currentMax >= array.length ? res : res + 1);
  }


```


<br>


###46 Permutations

>Given a collection of numbers, return all possible permutations.

**No duplicate number in collection**

<pre>
For example,
[1,2,3] have the following permutations:
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].
</pre>

**Idea**:

Since there is no duplicate, we can add element one by one. For example:

1,

1 2, 2 1

3 1 2, 1 3 2, 1 2 3, 3 2 1, 2 3 1, 2 1 3


**Jave code**:



*Iterative*:


```java
    public List<List<Integer>> permute(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return res;
        }
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        for (int i = 1; i < num.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    cur.add(temp);
                }
            }
            res = cur;
        }
        return res;
    } 

```

*recursion*:

```java
    public List<List<Integer>> permute(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return list;
        }
        return permute(list, num, 0);
    }
    
    public List<List<Integer>> permute(List<List<Integer>> list, int[] num, int i){
        if (i == num.length) {
            List<Integer> arr = new ArrayList<Integer>();
            list.add(arr);
            return list;
        }
        
        list = permute(list, num, i+1);
        List<List<Integer>> current = new ArrayList<List<Integer>>();
        for (List<Integer> l : list) {
            if (l.size() == 0) {
                List<Integer> arr = new ArrayList<Integer>();
                arr.add(num[i]);
                current.add(arr);
            } else {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> arr = new ArrayList<Integer>(l);
                    arr.add(j, num[i]);
                    current.add(arr);
                }
            }
        }
        list = new ArrayList<List<Integer>>(current);
        return list;
    }

```

<br>


<br>


**Another way**: use swap

```java
    public List<List<Integer>> permute(int[] num) {
      List<List<Integer>> list = new ArrayList<List<Integer>>();
      if (num == null || num.length == 0) {
          return list;
      }
        permute(list, num, 0);
        return list;
    }
    
    public void permute(List<List<Integer>> list, int[] num, int index){
      if (index == num.length) {
          //List<Integer> arr = IntStream.of(num).boxed().collect(Collectors.toList()); //speed is slow.
          List<Integer> arr = new ArrayList<>();
          for (int i : num) {
              arr.add(i);
          }
        list.add(arr);
        return;
      }
        for (int i = index; i < num.length; i++) {
            swap(num, index, i);
            permute(list, num, index + 1);
            swap(num, index, i);
        }
    }
    
    private void swap(int[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
```
<br>
<br>


###47 Permutations II

>Given a collection of numbers that might **contain duplicates**, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:
[1,1,2], [1,2,1], and [2,1,1].
<br>

**Idea**: Since the collection has duplicates, thus each time when we add permutation, we need to consider if it already exists. 

In the following code, the first code snippet use list.contains to check the duplicates. The second code snippet use set to avoid add dupilcates.

These two are accepted, the second one has better time complexity.


**Java code**:

**M1**:

```java

    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return res;
        }
        List<Integer> first = new ArrayList<Integer>();
        first.add(num[0]);
        res.add(first);
        Set<String> set = new HashSet<String>();
        for (int i = 1; i < num.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                for(int j = 0; j <= l.size(); j++) {
                    List<Integer> temp = new ArrayList<Integer>(l);
                    temp.add(j, num[i]);
                    if(set.add(temp.toString())) {
                        cur.add(temp);
                    }
                }
            }
            res = cur;
        }
        return res;
    }

```
<br>

**M2: Use set, recursion**:


```java

    public List<List<Integer>> permuteUnique(int[] num) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        if (num == null || num.length == 0) {
            return list;
        }
        return permuteUnique(list, num, 0);
    }
    
    public List<List<Integer>> permuteUnique(List<List<Integer>> list, int[] num, int i){
        if (i == num.length) {
            List<Integer> arr = new ArrayList<Integer>();
            list.add(arr);
            return list;
        }
        
        list = permuteUnique(list, num, i+1);
        Set<List<Integer>> current = new HashSet<List<Integer>>();
        for (List<Integer> l : list) {
            if(l.size() == 0){
                List<Integer> arr = new ArrayList<Integer>();
                arr.add(num[i]);
                current.add(arr);
            } else {
                for (int j = 0; j <= l.size(); j++) {
                    List<Integer> arr = new ArrayList<Integer>(l);
                    arr.add(j, num[i]);
                    current.add(arr);
                }
            }
        }
        list = new ArrayList<List<Integer>>(current);
        return list;
    }

```

<br>

**M3**: use swap, tle on leetcode

```java
  public List<String> permutations(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    permutations(res, 0, set.toCharArray());
    return res;
  }
  
  public void permutations(List<String> res, int index, char[] arr) {
    if (index == arr.length) {
      String s = new String(arr);
      res.add(s);
      return;
    }
    Set<Character> myset = new HashSet<Character>();
    for (int i = index; i < arr.length; i++) {
      if (!myset.contains(arr[i])) {
        myset.add(arr[i]);
        swap(arr, i, index);
        permutations(res, index + 1, arr);
        swap(arr, i, index);
      }
    }
  }
  
  public void swap(char[] arr, int i, int j) {
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
```

<br>

**M4: use next permutation**:

```java
    public List<List<Integer>> permuteUnique(int[] num) {
      List<List<Integer>> list = new ArrayList<List<Integer>>();
      if (num == null || num.length == 0) {
          return list;
      }
      Arrays.sort(num);
      //list.add(IntStream.of(num).boxed().collect(Collectors.toList())); //speed is slow
      list.add(toList(num));
      while (nextPermutation(num)) {
          list.add(toList(num));
      }
        return list;
    }
    
    private boolean nextPermutation(int[] num) {
        if(num == null || num.length <= 1) {
            return false;
        }
        int i = num.length - 2;
        while (i >= 0 && num[i] >= num[i+1]) {
            i--;
        }
        int index1 = i;
        if (i == -1) {
            return false;
        }
        i = num.length - 1;
        while (i >= 0 && num[i] <= num[index1]) {
            i--;
        }
        swap(num, index1, i);
        reverse(num, index1 + 1);
        return true;
    }
    
    private void reverse(int[] num, int i) {
        for (int j = i; j < (num.length - i) / 2 + i; j++) {
            swap(num, j, num.length + i - j - 1);
        }
    }
    
    private void swap(int[] num, int i, int j) {
        int temp = num[i];
        num[i] = num[j];
        num[j] = temp;
    }
    
    private List<Integer> toList(int[] num) {
        List<Integer> arr = new ArrayList<>();
        for (int i : num) {
            arr.add(i);
        }
        return arr;
    }

```


<br>
<br>


###48 Rotate Image


>You are given an n x n 2D matrix representing an image.

>Rotate the image by 90 degrees (clockwise).

>Follow up:
>Could you do this in-place?

**Idea**:The easiest way to solve this problem is draw a matrix and rotate it by 90 degrees. Then you'll find the following pattarn.

-   matrix[i][j] = matrix[n-j-1][i];
-   matrix[n-j-1][i] = matrix[n-i-1][n-j-1]
-   matrix[n-i-1][n-j-1] = matrix[j][n-i-1]; 
-   matrix[j][n-i-1] = matrix[i][j]

**Attention**: I made a mistake at the first time, matrix[i][j] should equal to matrix[n-j-1][i] other than matrix[n-j][i]. The other three should follow the same way.

**Java code**:

```java

    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int n = matrix.length;
        for(int i = 0; i < n/2; i++){
            for(int j = i; j < n - i - 1; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = temp;
            }
        }
    }

```

<br>
<br>


###49 Group Anagrams

>Given an array of strings, return all groups of strings that are anagrams.

>Note: All inputs will be in lower-case.


**Ideas**: To solve this problem, we can divide it into two parts

- 1) how to check if two strings are anagrams?

	 we can sort them and check if they are equal

- 2) for a certain string, how to decide if it has anagram in the strs?

	 Use hashmap.

**Time complexity**:

For the first solution use sort + hashmap, suppose string[] length is N, maximum string length is M, then the overall time complexity is O(N * MlgM)

For the second solution, the time complexity is O(N * M), but too many multiplications. 

**Java code**:

```java

    public List<String> anagrams(String[] strs) {
        List<String> res = new ArrayList<String>();
        if(strs == null || strs.length == 0) {
            return res;
        }
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String s : strs){
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            String sorted = new String(arr);
            if (map.containsKey(sorted)) {
                map.get(sorted).add(s);
            } else {
                List<String> list = new ArrayList<String>();
                list.add(s);
                map.put(sorted, list);
            }
        }
        for (Map.Entry<String, List<String>> e : map.entrySet()) {
            if (e.getValue().size() > 1) {
                res.addAll(e.getValue());
            }
        }
        return res;
    }

```

Here is another similar solution using hashmap, the difference is that it does not use Arrays.sort to sort the strings. It uses some primes numbers to calculate the hash value. This solution is from leetcode discussion. Even though it does not improve the time complexity too much, it's a pretty good idea. 

```java
    public List<String> anagrams(String[] strs) {
        int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};
        List<String> list = new LinkedList<>();
        Map<Integer, List<String>> mapString = new HashMap<>();
        int result = -1;
        for (int i = 0; i < strs.length; i++) {
            int mapping = 1;
            for (int j = 0, max = strs[i].length(); j < max; j++) {
                mapping *= PRIMES[strs[i].charAt(j) - 'a'];
            }
            List<String> strings = mapString.get(mapping);
            if (strings == null) {
                strings = new LinkedList<>();
                mapString.put(mapping, strings);
            }
            strings.add(strs[i]);
        }
        for (List<String> mapList : mapString.values()) {
            if (mapList.size() > 1) {
                list.addAll(mapList);
            }
        }
        return list;
    }

```

<br>
**Solution for the updated question:**

```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> res = new ArrayList<>();
    if(strs == null || strs.length == 0) {
        return res;
    }
    Map<String, List<String>> map = new HashMap<String, List<String>>();
    for (String s : strs){
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        String sorted = new String(arr);
        if (map.containsKey(sorted)) {
            map.get(sorted).add(s);
        } else {
            List<String> list = new ArrayList<String>();
            list.add(s);
            map.put(sorted, list);
        }
    }
    Iterator<List<String>> ite = map.values().iterator();
    while (ite.hasNext()) {
        List<String> cur = ite.next();
        Collections.sort(cur);
        res.add(cur);
    }
    return res;
}
```


<br>
<br>

###50 Pow

>Implement pow(x, n).

**Idea**: Dichotomy and calculate recursively. 
```java
public double myPow(double x, int n) {
    if (n == 0) {
        return 1;
    }
    double half = myPow(x, n / 2);
    return n % 2 == 0 ? half * half : (n > 0 ? half * half * x : half * half / x);
}
```



<br>

<br>

###51 N Queens


>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.


>Given an integer n, return all distinct solutions to the n-queens puzzle.

>Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

<pre>
For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]

</pre>

**Requirement**: For n queen problem, we can not put queens in the same row or same column or diagonal.

**Idea**: We can use the queen one by one, each one correspond to one row. To find all solutions, we need to try each column on a row. When we finish the last row, we find a solution. Use recursions inside the loops we can find all solutions.



**Java code**:


```java

    public List<String[]> solveNQueens(int n) {
        List<String[]> res = new ArrayList<String[]>();
        if(n <= 0) return res;
        solve(0,n,new int[n],res);
        return res;
    }
    
    public void solve(int r, int n, int[] cols, List<String[]> list){
        if(r == n){
            String[] strs = new String[n];
            for(int i = 0; i < n; i++){
                StringBuilder s = new StringBuilder();
                for(int j = 0; j < n; j++){
                    if(j == cols[i]) s.append("Q");
                    else s.append(".");
                }
                strs[i] = s.toString();
            }
            list.add(strs);
            return;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, cols)){
                cols[r] = i;
                solve(r+1, n, cols, list);
            }
        }  
        
    }
    
    public boolean isValid(int r, int c, int[] cols){
        for(int i = 0; i < r; i++){
            if(c == cols[i] || r - i == Math.abs(cols[i] - c)) return false;
        }
        return true;
    }

```


**Sililar to 52 N Queens II, we can improve the isValid method in the following way**:

```java
  Set<Integer> colSet = new HashSet<>(); //check col1 = col2
  Set<Integer> posDiagSet = new HashSet<>(); //check row1 - row2 = col1 - col2 ==> row1 - col1 = row2 - col2
  Set<Integer> negDiagSet = new HashSet<>(); // check row1 - row2 = - (col1 - col2) ==> row1 + col1 = row2 + col2

  public boolean isValid(int r, int c, Set<Integer> colSet, Set<Integer> posDiagSet, Set<Integer> negDiagSet){
    return !(colSet.contains(c) || posDiagSet.contains(r - c) || negDiagSet.contains(r + c));
  }
```

<br>

<br>


###52 N Queens II

>Follow up for N-Queens problem.

>Now, instead outputting board configurations, return the total number of distinct solutions.

**Idea**: Same with n queen, difference is that we don't need to output the result, we just need to calculate the total number of solutions.


**Java code**:

```java

    public int totalNQueens(int n) {
        if(n <= 0) return 0;
        int[] res = new int[1];
        solve(0,n,new int[n],res);
        return res[0];
    }
    
    public void solve(int r, int n, int[] cols, int[] res){
        if(r == n){
          res[0]++;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, cols)){
                cols[r] = i;
                solve(r+1, n, cols, res);
            }
        }  
        
    }
    
	public boolean isValid(int r, int c, int[] cols){
	    for(int i = 0; i < r; i++){
	        if(c == cols[i] || r - i == Math.abs(cols[i] - c)) return false;
	    }
	    return true;
	}

```

**In above method, we use O(n) time to check valid, we can do it in O(1)**

```java
    public int totalNQueens(int n) {
        if(n <= 0) return 0;
        int[] res = new int[1];
        Set<Integer> colSet = new HashSet<>(); //check col1 = col2
        Set<Integer> posDiagSet = new HashSet<>(); //check row1 - row2 = col1 - col2 ==> row1 - col1 = row2 - col2
        Set<Integer> negDiagSet = new HashSet<>(); // check row1 - row2 = - (col1 - col2) ==> row1 + col1 = row2 + col2
        solve(0, n, new int[n], res, colSet, posDiagSet, negDiagSet);
        return res[0];
    }
    
    public void solve(int r, int n, int[] cols, int[] res, Set<Integer> colSet, Set<Integer> posDiagSet, Set<Integer> negDiagSet){
        if(r == n){
          res[0]++;
          return;
        }
        for(int i = 0; i < n; i++){
            if(isValid(r, i, colSet, posDiagSet, negDiagSet)){
                cols[r] = i;
                colSet.add(i);
                posDiagSet.add(r - i);
                negDiagSet.add(r + i);
                solve(r + 1, n, cols, res, colSet, posDiagSet, negDiagSet);
                colSet.remove(i);
                posDiagSet.remove(r - i);
                negDiagSet.remove(r + i);
            }
        }  
        
    }
    
  public boolean isValid(int r, int c, Set<Integer> colSet, Set<Integer> posDiagSet, Set<Integer> negDiagSet){
      return !(colSet.contains(c) || posDiagSet.contains(r - c) || negDiagSet.contains(r + c));
  }

```




<br>
<br>

###53 Maximum Subarray

>Find the contiguous subarray within an array **(containing at least one number)** which has the largest sum.

For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.

**Idea**:
- 1) solution1: use dp. Store a local max and global max. Local max represents the max subarray which includes the element A[i]. Thus Local Max = max(local+A[i], A[i]). global = max(global, local).

**Attention**: Because the maxsubarray contains at least one number, thus the max sum might be negative when the array only contains one negative numbers or when all the numbers are negative.



```java

	 public int maxSubArray(int[] A) {
		 if(A == null || A.length == 0) return 0;
		 int local = A[0];
		 int global = A[0];
		 for(int i = 1; i < A.length; i++){
			 local = Math.max(A[i], local+A[i]);
			 global = Math.max(local, global);
		 }
		 return global;
	 }

```

<br>

- 2) solution 2: One pass. When encounter a negative number, record the current max. when sum + A[i] < 0 && A[i] > 0, change the local max to A[i]. 

```java

    public int maxSubArray1(int[] A) {
        if(A == null || A.length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int temp = A[0];
        for(int i = 1; i < A.length; i++){
        	if(temp < 0){
        		max = Math.max(max,temp);
        		temp = A[i];
        	}else{
        		if(A[i] > 0) temp += A[i];
        		else if(temp + A[i] < 0){
        			max = Math.max(max,temp);
            		temp = A[i];
        		}else{
        			max = Math.max(max,temp);
            		temp += A[i];
        		}
        	}
        }
        max = Math.max(max,temp);
        return max;
    }

``` 


<br>

**Related**: maxinum submatrix sum:


**Idea**: 

For each row, we calculate the sum of the rows below the current row. Then apply the maximum subarray to the compressed rows.

**Time** : O(n ^ 3)

```java
  public int largest(int[][] matrix) {
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < matrix.length; i++) {
      int[] compressedRow = new int[matrix[0].length];
      for (int j = i; j < matrix.length; j++) {
        for(int k = 0; k < compressedRow.length; k++) {
          compressedRow[k] += matrix[j][k];
        }
        res = Math.max(res, largestSum(compressedRow));
      }
    }
    return res;
  }
  
  private int largestSum(int[] array) {
    int local = array[0];
    int res = array[0];
    for (int i = 1; i < array.length; i++) {
      local = Math.max(array[i], local + array[i]);
      res = Math.max(res, local);
    }
    return res;
  }
```
<br>
<br>


###54 Spiral Matrix

>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

<pre>
For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

</pre>

**Idea**:Don't figure out any good solution yet. Just add the element in spiral order one by one.

**Attention**: The row is not necessarily equal to column, thus make sure to check if they are equal. Also, in the following method, I loop Math.min(row, col) / 2 times. what will happen if  Math.min(row, col) is odd? 


**Java code**:


```java

    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) 
            return res;
        int row = matrix.length;
        int col = matrix[0].length;
        int loops = (Math.min(row, col)) /2;
        for(int i = 0; i < loops; i++){
            for(int j = i; j < col - i; j++){
                res.add(matrix[i][j]);
            }
            for(int j = i+1; j < row -i; j++){
                res.add(matrix[j][col-i-1]);
            }
            for(int j = col-i-2; j >= i; j--){
                res.add(matrix[row-i-1][j]);
            }
            for(int j = row - (i+2); j >= i+1; j--){
                res.add(matrix[j][i]);
            }
        }
        if(row >= col && col % 2 == 1){
            for(int i = col/2; i < row - col/2; i++){
                res.add(matrix[i][col/2]);
            }
        }
        if(row < col && row % 2 == 1){
            for(int i = row/2; i < col - row/2; i++){
                res.add(matrix[row/2][i]);
            }
        }
         return res;
    }

```

<br>

**Another more straightforward way**: M * N iterarive

```java
  public List<Integer> spiral(int[][] matrix) {
    List<Integer> res = new ArrayList<Integer>();
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
      return res;
    }
    int left = 0;
    int right = matrix[0].length - 1;
    int top = 0;
    int bottom = matrix.length - 1;
    while (left < right && top < bottom) {
      for (int i = left; i <= right; i++) {
        res.add(matrix[top][i]);
      }
      for (int i = top + 1; i <= bottom; i++) {
        res.add(matrix[i][right]);
      }
      for (int i = right - 1; i >= left; i--) {
        res.add(matrix[bottom][i]);
      }
      for (int i = bottom - 1; i >= top + 1; i--) {
        res.add(matrix[i][left]);
      }
      left++;
      right--;
      top++;
      bottom--;
    }
    if (left == right && top <= bottom) {
      for (int i = top; i <= bottom; i++) {
        res.add(matrix[i][left]);
      }
    } else if (top == bottom && left <= right) {
      for (int i = left; i <= right; i++) {
        res.add(matrix[top][i]);
      }
    }
    return res;
  }
```
<br>

**Recursive solution**: handle N* N 

```java
  public int[] spiral(int[][] matrix) {
    int[] res = new int[matrix.length * matrix.length];
    spiral(res, matrix, 0, matrix.length, 0);
    return res;
  }
  
  public void spiral(int[] res, int[][] matrix, int offset, int size, int count) {
    if (size == 0) {
      return;
    }
    if (size <= 1) {
      res[count++] = matrix[offset][offset];
      return;
    }
    for (int i = 0; i < size - 1; i++) {
      res[count++] = matrix[offset][i + offset];
    }
    for (int i = 0; i < size - 1; i++) {
      res[count++] = matrix[offset + i][offset + size - 1];
    }
    for (int i = size - 1; i >= 1; i--) {
      res[count++] = matrix[offset + size - 1][offset + i];
    }
    for (int i = size - 1; i >= 1; i--) {
      res[count++] = matrix[offset + i][offset];
    }
    spiral(res, matrix, offset + 1, size - 2, count);
  }
```

<br>
<br>


###55 Jump Game

> Given an array of non-negative integers, you are initially positioned at the first index of the array.

>Each element in the array represents your maximum jump length at that position.

>Determine if you are able to reach the last index.

<pre>
For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.
</pre>

**Idea**: We need to figure out the max-position we can reach. If max >= A.length-1, then we can reach to the end. Note that we need to check if at certain step if index i > max, then we can not reach to the end. Because in some cases the A[i] might be 0, thus we might not able to go to the next step.


**Java code**:


```java
    public boolean canJump(int[] nums) {
        int canReach = 0;
        for (int i = 0; i < nums.length && i <= canReach; i++) {
            canReach = Math.max(canReach, i + nums[i]);
            if (canReach >= nums.length - 1) {
                return true;
            }
        }
        return canReach >= nums.length - 1;
    }
```

<br>
<br>


###56 Merge Intervals

> Given a collection of intervals, merge all overlapping intervals.

<pre>
For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</pre>


**Idea**: First sort then merge.

- 1) For sort, we can use Collections.sort(list, comparator). And when interval1.start == interval2.start, we compare interval1.end and interval2.end.
Otherwise, we compare interval1.start and interval2.start
- 2) For merge, if current.start > last.end, just add interval.
Otherwise, we need to compare the end of two intervals. If current.end > last.end, we need to update last.end. 


**Java code**:

```java

    public List<Interval> merge(List<Interval> intervals) {
        if(intervals == null || intervals.size() == 0) return intervals;
        List<Interval> res = new ArrayList<Interval>();
        Comparator<Interval> comp = new Comparator<Interval>(){
          public int compare(Interval arg1, Interval arg2){
              if(arg1.start == arg2.start) return arg1.end - arg2.end;
              else return arg1.start - arg2.start;
          }
        };
        Collections.sort(intervals, comp);
        res.add(intervals.get(0));
        for(int i = 1; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.start > res.get(res.size() -1).end) 
                res.add(cur);
            else {
                if(cur.end > res.get(res.size() -1).end)
                    res.get(res.size() -1).end = cur.end;
            }
        }
        return res;
    }
    
```

<br>

<br>


###57 Insert Interval

>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

>You may assume that the intervals were initially sorted according to their start times.

>Example 1:


>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].


>Example 2:

>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].


**Idea**:

- solution 1 : There are three possible relations between two intervals. Consider interval i1 and interval i2,

	* case 1: i1.end < i2.start
	
	* case 2:  i1.start > i2.end
	
	* case 3: i1 includes i2, or i2 includes i1, or i1.start < i2.start and i1.end < i2.end, or i1.start > i2.start and i1.end > i2.end
	
	In case 1: we just need to add i1 to result,
	In case 2: we add i2 to result, and change newInterval to i1,
	In case 3: We might need to update the start or end of the newInterval.
	
	
- solution 2: First find the place to insert the newInterval, then do merge intervals for the remain intervals. How to find the place to insert the newInterval? If we find a interval that its end is >= newInterval.start, then it is the place to insert the newInterval. After insert, we merge the intervals. 



**java code**:


*Solution 1*:

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        for(Interval interval : intervals){
            if(interval.end < newInterval.start){
                res.add(interval);
            }else if(interval.start > newInterval.end){
                res.add(newInterval);
                newInterval = interval;
            }else if(newInterval.end >= interval.start || newInterval.start <= interval.end ){
                newInterval.start = Math.min(interval.start, newInterval.start);
                newInterval.end = Math.max(interval.end, newInterval.end);
            }
        }
        res.add(newInterval);
        return res;
    }
    

```



*Solution 2*: 

```java

    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> res = new ArrayList<Interval>();
        int i = 0;
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            if(cur.end >= newInterval.start){
                break;
            }
            res.add(cur);
        }
        
        res.add(newInterval);
        
        for(; i < intervals.size(); i++){
            Interval cur = intervals.get(i);
            Interval previous = res.get(res.size()-1);
            if(cur.start > previous.end){
                res.add(cur);
            }else{
                previous.start = Math.min(previous.start, cur.start);
                previous.end = Math.max(previous.end, cur.end);
            }
        }
        return res;
    }

```

<br>
<br>

###58 Length of Last Word


>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

>If the last word does not exist, return 0.

>Note: A word is defined as a character sequence consists of non-space characters only.

>For example, 

>Given s = "Hello World",

>return 5.

**Idea**:

- solution1 : split the string by spaces, then return the length of the last word. Be careful, before you split, you should first trim the string to remove the front and back spaces in the string. Otherwise, you might get the wrong answer.

- solution2 : trim the spaces, then find from the end of the string, until we find the first space, then we can return the length.




**Java code**:


*Method 1*:

```java


    public int lengthOfLastWord(String s) {
        if(s == null || s.length() == 0) return 0;
        s = s.trim();
        String[] words = s.split("\\s+");
        return words[words.length -1].length();
    }


```



*Method 2*:


```java

    
	public int lengthOfLastWord1(String s) {
		if(s == null || s.length() == 0) return 0;
    	s = s.trim();
    	int len = 0;
    	for(int i = s.length()-1; i>=0; i--){
    		if(s.charAt(i) != ' '){
    			len++;
    		}else break;
    	}
    	return len;
	}


```



<br>
<br>

###59 Spiral Matrix II

>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

<pre>
For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>

**Idea**: The idea is similar with spiral matrix. Actually, it's easier then the spiral matrix. Because now we can make sure that the matrix is a square matrix, thus we don't need to consider some corner cases like we did in spiral matrix. 


**Java code**:


```java

    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int num = 1;
        for(int i = 0; i < n/2+1; i++){
            for(int j = i; j < n - i; j++){
               matrix[i][j] = num++ ;
            }
            for(int j = i+1; j < n -i; j++){
               matrix[j][n-i-1] = num++;
            }
            for(int j = n-i-2; j >= i; j--){
               matrix[n-i-1][j] = num++;
            }
            for(int j = n - (i+2); j >= i+1; j--){
               matrix[j][i] = num++;
            }
       }
       return matrix;
    }

```

<br>
<br>

###60 Permutation Sequence

>The set [1,2,3,…,n] contains a total of n! unique permutations.

>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

<pre>
"123"
"132"
"213"
"231"
"312"
"321"

</pre>

Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.



**Idea**: for each begin character, it has (n-1)! permutations, k/(n-1)! we know the begin character
	 
	 
**Attention**: How to decide add which num to the permutation? We use k/(n-1)!. There are boundary between permutation (n-1)! when add num to permutation. For example, n = 3, k = 4, k /(2!) = 2, should we add 2 or 3 to the permutation? 
Thus k-- can simplify the index.  

**Java code**:


```java

      public String getPermutation(int n, int k) {
            if(n <= 0) return "";
            
            /* create factorial,nums for permutation and ressult stringbuilder*/
            List<Integer> nums = new ArrayList<Integer>();
            int factorial = 1;
            for(int i = 1; i <= n; i++){
                nums.add(i);
                factorial *= i;
            }
            factorial /= n;
            StringBuilder res = new StringBuilder();
            
            /* to simplify the boundary, we can k--. Consider n = 4, k = 18, 18 / 6 = 3, then we need to add nums[i-1]*/ 
            k--;
            
            /*create permutation one digit per time*/
            while(n > 0){
                int index = k / factorial;
                res.append(nums.get(index));
                nums.remove(index);
                k %= factorial;
                if(n > 1) {
                    factorial = factorial / (n-1);
                }
                n--;
            }
            return res.toString();
        }
	

```



<br>
<br>


###61 Rotate List

> Given a list, rotate the list to the right by k places, where k is non-negative.

<pre>
For example:
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
</pre>

**Idea**: First calculate the length of list and record the tail, then move len - n steps. Connect tail and head, disconnect the (len-n)th and (len-n+1)th node.

**Attention**: 

- 1) we need to mode n = n%len
- 2) Take care of null pointer


code:
```java
      public ListNode rotateRight(ListNode head, int n) {
        if(n < 0 || head == null) return head;
        ListNode temp = head;
        int len = 0;
        ListNode tail = null;
        while(temp != null){
            len++;
            tail = temp;
            temp = temp.next;
        }
        n = n % len;
        len = len - n;
        if(n == 0 || len == 0) return head;
        temp = head;
        ListNode pre = null;
        while(len > 0){
            pre = temp;
            temp = temp.next;
            len--;
        }
        pre.next = null;
        tail.next = head;
        return temp;
    }

```


<br>
<br>


###62 Unique Paths

> A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

>How many possible unique paths are there?

**Idea**: There are several ways to solve this problem. Let's discuss four methods. 

**Solution 1**

This problem is much similar to fibonacci number or the climb steps. We can easily solve this problem in recursion. But the time complexity is bad. The code is below(would be time exceeded on leetcode):

```java

    public int uniquePaths(int m, int n) {
        if (m == 0 && n == 0) {
            return 1;
        } else if (m < 0 || n < 0) {
            return 0;
        }
        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
    }


```
<br>

**Solution 2**

Simply to the climb stairs problem, we can solve this problem use dynamic programming. Use dynamic programming.

Induction rule:  dp[i][j] = dp[i-1][j] + dp[i][j-1]; 

In dp, the initial value is really important. In this problem, how do we initialize the dp array? Generally, the initianization would be dp[0][0] or dp[0][i] or dp[i][0], or other. In this problem, we need to initialize dp[0][i] dp[i][0] to 1, because they all have single path. The code is below:

*Dp, 2 dimensional array*

```java
    public int uniquePaths(int m, int n) {
        if (m < 0 || n < 0 || (m == 0 && n == 0)) {
            return 0;
        }
        
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        return dp[m-1][n-1];
    }
```

<br>


**Solution 3**

In the above dp code, the formula is  dp[i][j] = dp[i-1][j] + dp[i][j-1]. We can easily find that dp[i][j] is only related to the previous line. Thus we can use an one dimensional array to solve this problem.

```java


 public int uniquePaths(int m, int n) {
        if (m < 0 || n < 0 || (m == 0 && n == 0)) {
            return 0;
        }
        
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j-1];
            }
        }
        
        return dp[n-1];
 }


```


**Solution 4**

We can also use combination to solve this problem. We need to walk m+n-2 steps. m-1 steps down and n-1 steps right. 

Thus we can select (m -1) from (m + n - 2) steps.

**Note that the numbers will become really big after a few steps. Remember to use double or big integers.**

```java

	 public int uniquePaths3(int m, int n) {
		 int small = m < n ? m-1 : n-1;
		 int large = small == m-1 ? n-1 : m-1;
		 /* if use int, when m, n > 10, will overflow and get wrong answer*/
		 double up = 1;
		 double down = 1;
		 for (int i = 1; i <= small; i++) {
			 down *= i;
			 up *= small + large + 1 -i;
		 }
		 return (int) (up/down);
		 
	 }

```


<br>
<br>


###63 Unique Paths II

>Follow up for "Unique Paths":

>Now consider if some obstacles are added to the grids. How many unique paths would there be?

>An obstacle and empty space is marked as 1 and 0 respectively in the grid.

<pre>
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.

[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.

Note: m and n will be at most 100.

</pre>


**Idea**: The basic Idea is similar to **62 Unique path**. Only difference is that we can not run through obstacles in this problem. So when we encounter obstacles, we need to set path through that lattice to 0.

Similarly, we can use one dimensional array or two dimensional array to solve this problem. 

**Attention**: *For the two dimensional array solution we need to take attention to the dp array initialization. Note that if one lattice if blocked, like grid[2][0] == 1, then all lattices after grid[2][0] such ad grid[3][0] ... should set dp[i][0] to 0.*


**Java code**:

**Two dimensional array**:

```java

public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];
        boolean blocked = false;
        for (int i = 0; i < obstacleGrid.length; i++) {
            if (obstacleGrid[i][0] == 1) {
                blocked = true;
            }
            if (!blocked) {
                dp[i][0] = 1;
            }
        }
        blocked = false;
        for (int i = 0; i < obstacleGrid[0].length; i++) {
            if (obstacleGrid[0][i] == 1) {
                blocked = true;
            }
            if (!blocked) {
                dp[0][i] = 1;
            }
        }
        for (int i = 1, rlen = obstacleGrid.length; i < rlen; i++) {
            for (int j = 1, clen = obstacleGrid[0].length; j < clen; j++) {
                if (obstacleGrid[i][j] == 0) {
                    dp[i][j] = dp[i][j-1] + dp[i-1][j];
                }
            }
        }
        return dp[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
    }

```


**One dimensional array**:

```java
  public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid == null || m == 0 || n == 0 || obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 0 && j > 0) {
                    dp[j] = dp[j-1] + dp[j];
                }else if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                }
            }
        }
        return dp[n - 1];
    }
```




<br>
<br>


###64 Minimum Path Sum

>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

>Note: You can only move either down or right at any point in time.


**Idea**: If you have figure out how to solve the unique path problem :

* [62 Unique Paths](#62-unique-paths)
* [63 Unique Paths II](#63-unique-paths-ii)

you will find that we can solve this problem in the same way. We can use recursion, 2 dimensonal dp, 1 dimensional dp to solve this problem. 

**Here is the 2 dimensional dp solution in java:**


```java

    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = grid[i][j];
                } else if (i == 0) {
                     dp[i][j] = dp[i][j - 1] + grid[i][j];
                } else if (j == 0) {
                    dp[i][j] = dp[i - 1][j] + grid[i][j];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
                }
            }
        }
        return dp[grid.length - 1][grid[0].length - 1]; 
    }

```


**Here is the 1 dimensional dp solution in java:**

```java

    public int minPathSum(int[][] grid) {
        int[] dp = new int[grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (i == 0 && j == 0) {
                    dp[j] = grid[i][j];
                } else if (i == 0) {
                     dp[j] = dp[j - 1] + grid[i][j];
                } else if (j == 0) {
                    dp[j] = dp[j] + grid[i][j];
                } else {
                    dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];
                }
            }
        }
        return dp[grid[0].length - 1]; 
    }


```

<br>
<br>

###65 Valid Number
>Validate if a given string is numeric.

>Some examples:

>"0" => true

>" 0.1 " => true

>"abc" => false

>"1 a" => false

>"2e10" => true

>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.


**Need to consider before start**:

<pre>

- In a number it could include 0, 1-9, ., e E, + - Thus if other character appears, then the number is invalid

- The right place of the above characters: 

	- 0-9:  0-9 is valid in any place. 
	
	- . 
		* can not after e or E
		* must has a number before it or after it 
		
	- - and + :
		* must at the beginning or after e or E or .
		* must has a number or . after it.

	- e or E:
		* must be the first time appear, that is, there should not be any e or E before it
		* e should not at the beginning
		* it must be a integer after e (we can have + or 1 after e)
	
</pre>


**Some case**:

<pre>

"1 " true
"  " false
"-1." true
"6e6.5" false
" 005047e+6" true

</pre>


**Java code**

```java



    public boolean isNumber1(String s) {
        if (s == null || s.trim().length() == 0) {
            return false;
        }
        s = s.trim();
        boolean eE = false;
        boolean dot = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //check if character valid, if e|E at the beginning , if -|+ at the end
            if (!isValidCharacter(c) || (i == 0 && (c == 'e' || c == 'E')) || (i == s.length() -1  && (c == '-' || c == '+'))) {
               return false;
            }
            //if e|E, e|E must hasn't existed before, must be a number of + - after it
            if ((c == 'e' || c == 'E')) {
                if (eE || (i == s.length() -1 || (!isNumber(s.charAt(i+1)) && s.charAt(i+1) != '-' && s.charAt(i+1) != '+'))) {
                    return false;
                }
                eE = true;
            }
            //if -|+, must at the beginning or after e|E, must be a . or number after it
            if ((c == '-' || c == '+')) {
                if((!isNumber(s.charAt(i+1)) && s.charAt(i+1) != '.') || (i != 0 && s.charAt(i-1) != 'e' && s.charAt(i-1) != 'E')) {
                    return false;
                }
            }
            // if ., .|e|E must hasn't existed before, must has a number before it or after it. 
           if (c == '.'){
               if (dot || eE ||  s.length() == 1 || (i == 0 && !isNumber(s.charAt(i+1))) || ( i == s.length() - 1 && !isNumber(s.charAt(i-1))) || (i != 0 && i != s.length() -1 && !isNumber(s.charAt(i-1)) && !isNumber(s.charAt(i+1)))) {
                   return false;
               } 
               dot = true;
           }
        }
        return true;
    }
    
    public boolean isNumber(char c) {
        if (c >= '0' && c <= '9') {
            return true;
        }
        return false;
    }
    
    public boolean isValidCharacter(char c) {
        if (isNumber(c) || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E') {
            return true;
        }
        return false;
    }


```


If use switch


```java

 public boolean isNumber(String s) {
        if (s == null || s.trim().length() == 0) {
            return false;
        }
        s = s.trim();
        boolean eE = false;
        boolean dot = false;
        for (int i = 0; i < s.length(); i++) {
           switch(s.charAt(i)) {
               case 'e':
               case 'E':
                    if (eE || i == s.length() -1 || i == 0) {
                    return false;
                }
                    eE = true;
                    break;
                case '-':
                case '+':
                     if ((i == s.length() -1 || !((s.charAt(i+1) >= '0' && s.charAt(i+1) <= '9') || s.charAt(i+1) == '.') || (i != 0 && s.charAt(i-1) != 'e' && s.charAt(i-1) != 'E'))) {
                    return false;
                    }
                    break;
                case '.':
                    if (dot || eE || s.length() == 1 || (i == 0 && !isNumber(s.charAt(i+1))) || ( i == s.length() - 1 && !isNumber(s.charAt(i-1))) || (i != 0 && i != s.length() -1 && !isNumber(s.charAt(i-1)) && !isNumber(s.charAt(i+1)))) {
                   return false;
                    } 
                    dot = true;
                    break;
                case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        			break;
            	default:
            			return false;
           }
        }
        return true;
    }
    
    public boolean isNumber(char c) {
        if (c >= '0' && c <= '9') {
            return true;
        }
        return false;
    }
   
```



<br>
<br>

###66 Plus One

>Given a non-negative number represented as an array of digits, plus one to the number.

>The digits are stored such that the most significant digit is at the head of the list.



**Idea**: Since the most significant digit is at the head of the list, thus we need to add from the end. Thus problem is really similar to add two numbers, the other number in the two number is 1. We just need to take care of the carry. 

There are two cases:

- If carry is not 1 at the end, what should we  do? Definitely the original array is not big enough to store the result. Thus we need to enlarge the array by creating a new array. So the most straight forward thing to do is store the carry at index 0 and copy the original array, like the **First try solution** below.

It seems that it's a pretty good solution. Well, actually, we just need to store carry in index 0. **Why? Because if there are carry at the end, then the other digits must be 0**.  See detail on the **better solution** below. 

Also, if carry is 0, we can return the array immediately.


**Java code**:


**First try**:

```java

 public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0; i--) {
            int digit = digits[i];
            if (i == digits.length -1) {
                digit += 1;
            }
            digit += carry;
            digits[i] = digit % 10;
            carry = digit / 10;
        }
        if (carry == 0) {
            return digits;
        } else {
            int[] res = new int[digits.length + 1];
            res[0] = carry;
            for (int i = 0; i < digits.length; i++){
                res[i+1] = digits[i];
            }
            return res;
        }
        
    }


```


**Modified solution 1**:

```java
    public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0; i--) {
            int digit = digits[i];
            if (i == digits.length -1) {
                digit += 1;
            }
            digit += carry;
            digits[i] = digit % 10;
            carry = digit / 10;
        }
        if (carry == 0) {
            return digits;
        } else {
            int[] res = new int[digits.length + 1];
            res[0] = carry;
            return res;
        }
    }

```

**Modified solution 2**:

```java
    public int[] plusOne(int[] digits) {
        if (digits == null || digits.length == 0) {
            return digits;
        }
        int carry = 0;
        for (int i = digits.length - 1; i >= 0; i--) {
            int digit = digits[i];
            if (i == digits.length -1) {
                digit += 1;
            }
            digit += carry;
            digits[i] = digit % 10;
            carry = digit / 10;
            if (carry == 0) {
                return digits;
            } 
        }
        int[] res = new int[digits.length + 1];
        res[0] = carry;
        return res;
    }
```


<br>
<br>



###67 Add Binary

>Given two binary strings, return their sum (also a binary string).

>For example,

>a = "11"

>b = "1"

>Return "100".

**Some note**:

1) when calculate, we need to convert char to integer.

**Solution**:

```java
public String addBinary(String a, String b) {
    String longer = a.length() > b.length() ? a : b;
    String shorter = longer == a ? b : a;
    StringBuilder rs = new StringBuilder();
    int carry = 0;
    for (int i = longer.length() - 1; i >= 0; i--) {
        int charShorter = '0';
        if (i >= longer.length() - shorter.length()) {
            charShorter = shorter.charAt(shorter.length() - (longer.length() - i));
        }
        int sum = carry + longer.charAt(i) + charShorter - 2 * '0';
        rs.append("" + sum % 2);
        carry = sum / 2;
    }
    if (carry == 1) {
        rs.append("" + carry);
    }
    return rs.reverse().toString();
}
```




<br>

<br>

###68 Text Justification

>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

>Extra spaces between words should be distributed as **evenly** as possible. If the number of spaces on a line do not divide evenly between words, **the empty slots on the left will be assigned more spaces than the slots on the right**.

>For the **last line of text, it should be left justified** and no extra space is inserted between words.

<pre>
For example,
words: ["This", "is", "an", "example", "of", "text", "justification."]
L: 16.

Return the formatted lines as:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Note: Each word is guaranteed not to exceed L in length.
</pre>

**Idea**: Just need to be careful

A few notes:

- for rows except of the last row we need to take care of the case when there is only one word in the line.

- for the last row, remember to add addtional spaces in the end of the line.


```java
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> res = new ArrayList<>();
        int len = 0;
        int start = 0;
        for (int i = 0; i < words.length; i++) {
            if (len + words[i].length() + i - start > maxWidth) {
                res.add(generateRow(i, start, maxWidth, words, len));
                len = 0;
                start = i;
            }
            len += words[i].length();
        }
        //last row
        res.add(generateLastRow(start, maxWidth, words));
        return res;
    }
    
    private String generateLastRow(int start, int maxWidth, String[] words) {
        StringBuilder res = new StringBuilder();
        //separate each word with one space.
        for (int i = start; i < words.length; i++) {
            res.append(words[i]);
            if (res.length() < maxWidth) {
                res.append(" ");
            }
        }
        //add extra spaces in the end.
        for (int i = res.length(); i < maxWidth; i++) {
            res.append(" ");
        }
        return res.toString();
    }

    private String generateRow(int i, int start, int maxWidth, String[] words, int len) {
        //check space, slot number i - start - 1, i is not include, start is include
        int spacePerWord = 0;
        int remainSpace = 0;
        if (i - start - 1 > 0) {
            spacePerWord = (maxWidth - len) / (i - start - 1);
            remainSpace = (maxWidth - len) % (i - start - 1);
        }
        //generate row
        StringBuilder sb = new StringBuilder();
        for (int j = start; j < i; j++) {
            sb.append(words[j]);
            if (j != i - 1) {
                sb.append(createSpace(spacePerWord));
            }
            if (remainSpace > 0) {
                sb.append(" ");
            }
            remainSpace--;
        }
        //for i - start - 1 = 0
        for (int j = sb.length(); j < maxWidth; j++) {
            sb.append(" ");
        }
        return sb.toString();
    }
    
    private String createSpace(int num) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < num; i++) {
            res.append(" ");
        }
        return res.toString();
    }
```

<br>
<br>

###69 Sqrt

>Implement int sqrt(int x).

>Compute and return the square root of x.


**Idea**: The result = x/result, so each time we can give a better guess result = (result + x/result)/2 until we get the correct answer.

```java
    public int mySqrt(int x) {
        if (x < 1) {
            return 0;
        }
        double res = 1;
        while (Math.abs(res - x / res) > 0.00001) {
            res = (res + x / res) / 2;
        }
        return (int) res;
    }
```	
**Other Idea**: Dichotomy. l = smallest possible result, r the largest possible result. mid = (l + r)/2 , check the relationship between mid and result

**Attention**: mid <= x/mid && (mid + 1) > x/(mid+1) can not change to mid * mid <= x && (mid+1) * (mid+1) > x. Because, when **mid * mid overflows**, the result might change, also, it might lead to Time limit exceeded.

```java
    public int mySqrt(int x) {
      int l = 1;
      int r = x / 2 + 1;
      while (l <= r) {
          int mid = l + (r - l) / 2;
          if (x / mid >= mid && x / (mid + 1) < (mid + 1)) {
              return mid;
          } else if (x / mid > mid) {
              l = mid + 1;
          } else {
              r = mid - 1;
          }
      }
      return 0;
  }
```	

<br>

<br>



###70 Climbing Stairs

>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Idea**: Each time we can climb 1 steps or 2 steps, thus Fn = Fn-1 + Fn-2. It's just a fibonacci sequence. 

**Solution1** Use dp, Time O(n), Space O(1)

```java
 public int climbStairs(int n){
        if(n == 0) return 1;
        if(n == 1) return 1;
        int n1 = 1;
        int n2 = 1;
        int n3 = 0;
        for(int i = 2; i <= n; i++){
            n3 = n1 + n2;
            n1 = n2;
            n2 = n3;
        }
        return n3;
    }
```    
 
 
 **Solution2**: Use matrix, O(lgn) time.
 
 ```java
 
   public int climbStairs2(int n){
        if(n < 0) return 0;
        if(n <= 1) return 1;
        int[][] res = {{1, 0}, {0, 1}};
        int[][] m = {{1, 1}, {1, 0}};
        while(n > 0){
            if(n % 2 == 1) res = multiplyMatrix(res, m);
            n = n/2;
            m = multiplyMatrix(m, m);
        }
        return res[0][0];
    }
    
    
    public int[][] multiplyMatrix(int[][] m, int[][]n){
        int a = m[0][0] * n[0][0] + m[0][1] * n[1][0];
        int b = m[0][0] * n[0][1] + m[0][1] * n[1][1];
        int c = m[1][0] * n[0][0] + m[1][1] * n[1][0];
        int d = m[1][0] * n[0][1] + m[1][1] * n[1][1];
        int[][] res = {{a, b}, {c, d}};
        return res;
    }
 
```

**Solution 3** : recursion, O(2 ^ n) time.
```java
    public int climbStairs(int n) {
        if(n < 0) return 0;
        if(n == 1 || n == 0) return 1;
        return climbStairs(n-1)+climbStairs(n-2);
    }
    
```

**Solution 1: use stack.

We see that the value of Fibonacci increases exponentially. If we use int, then we can only compute to F47, if we use long, we can compute to F96. So if our required numbers are big, it's unreasonable to use in/long as return value. We can use BigInteger in java. Eg:

```java

	public static String bigFib(int n){
    	if(n <= 0) return "0";
    	if(n == 1) return "1";
    	BigInteger n1 = new BigInteger("0");
    	BigInteger n2 = new BigInteger("1");
    	BigInteger n3 = new BigInteger("0");
        for(int i = 2; i <= n; i++){
        	n3 = n1.add(n2);
        	n1 = n2;
        	n2 = n3;
        }
        return n3.toString();
    	
    }
    

```

<br>
<br>
###71 Simplify Path

> Given an absolute path for a file (Unix-style), simplify it.

<pre>
For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"

</pre>

**Idea**: Use stack

Note: When use linkedlist as stack, push add element to the front of the linkedlist. Pop removes the first element of the list. Thus when construct the result, we should use pollLast.

```java
 public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<String>();
        int i = 0;
        while (i < path.length()) {
            StringBuilder cur = new StringBuilder();
            while(i < path.length() && path.charAt(i) != '/') {
                cur.append(path.charAt(i++));
            }
            if (cur.length() > 0) {
                if (cur.toString().equals("..")) {
                    if (!stack.isEmpty()) {
                        stack.pop();
                    }
                } else if (!cur.toString().equals(".")) {
                    stack.push(cur.toString());
                }
            }
            i++;
        }
        StringBuilder res = new StringBuilder();
        if (stack.isEmpty()) {
            return "/";
        }
        while (!stack.isEmpty()) {
            res.append("/" +stack.pollLast());
        }
        return res.toString();
    }
```

Another solution use regular expression to split the path.

```java
  public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<String>();
        String[] strs = path.split("/");
        for (String s : strs) {
            if (s.equals("")) {
                continue;
            } else if (s.equals("..")) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!s.equals(".")) {
                stack.push(s);
            }
        }
        StringBuilder res = new StringBuilder();
        if (stack.isEmpty()) {
            return "/";
        }
        while (!stack.isEmpty()) {
            res.append("/" +stack.pollLast());
        }
        return res.toString();
    }
```



<br>
<br>

###72 Edit Distance

>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

a) Insert a character
b) Delete a character
c) Replace a character

<br>
<br>

**Idea**: DP.

We can also adapt the following code to use just one dimensional array.

```java
  public int minDistance(String word1, String word2) {
      int[][] dp = new int[word1.length() + 1][word2.length() + 1];
      for (int i = 0; i <= word1.length(); i++) {
          for(int j = 0; j <= word2.length(); j++) {
              if (i == 0) {
                  dp[i][j] = j;
              } else if (j == 0) {
                  dp[i][j] = i;
              } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                  dp[i][j] = dp[i - 1][j - 1];
              } else {
                  dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) +1;
              }
          }
      }
      return dp[word1.length()][word2.length()];
  }
```


###73 Set Matrix Zeroes

>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

**Solution 1**:

**Idea**: The easiest way to do this problem is record the rows of columns needed to be set to 0. We can use extra array to record the rows and columns. The space complexity would ba O(m+n). If we use one row and one column that are supposed to set to 0s to stroe the information, we can get O(1) space complexity.

**Java code**:

```java
public void setZeroes(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        int[] rzeros = new int[matrix.length];
        int[] czeros = new int[matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[0].length; j++){
                if(matrix[i][j] == 0) {
                    rzeros[i] = 1;
                    czeros[j] = 1;
                }
            }
        }
        for(int i = 0; i < rzeros.length; i++){
            if(rzeros[i] == 1){
                for(int j = 0; j < matrix[0].length; j++){
                    matrix[i][j] = 0;
                }
            } 
        }
        for(int i = 0; i < czeros.length; i++){
            if(czeros[i] == 1){
                for(int j = 0; j < matrix.length; j++){
                    matrix[j][i] = 0;
                }
            }
        }
    }

```

**Solution 2**:

Can we do it in place? Yes. We can use the first row and first column to record the rows and columns to be set to 0.
The spot in the first row or column will be set to 0 if there exists 0 element in that row or column.

```java
    public void setZeroes(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        boolean firstRow = false;
        for (int i = 0; i < matrix[0].length; i++) {
            if (matrix[0][i] == 0) {
                firstRow = true;
                break;
            }
        }
        boolean firstColumn = false;
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[i][0] == 0) {
                firstColumn = true;
                break;
            }
        }
        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (firstRow) {
            for (int i = 0; i < matrix[0].length; i++) {
                matrix[0][i] = 0;
            }
        }
        if (firstColumn) {
            for (int i = 0; i < matrix.length; i++) {
                matrix[i][0] = 0;
            }
        }
    }
```


<br>
<br>

###74 Search a 2D Matrix
>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

>Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,

>Consider the following matrix:

<pre>
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
Given target = 3, return true.

</pre>

**Idea**:

*Solution 1*: We can search from the top-right, if the target is larger than current, then we move to next row. If the target is smaller, then we move to left.

*Solution 2*: We use the method in solution 1 to find the target row, then apply binary search on that row.

Solution 3*: Use binary search to find the row, then in that row, use binary search to find the target.

**Attention: In binary search, when loop ends, if target is not found, then l points to the first element larger than the target and r points to the first element smaller than target.** 

**java code**:

**Solution 1**: Time: O(m + n)

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        for (int i = 0, row = matrix.length; i < row; i++) {
            for (int j = matrix[0].length - 1; j >= 0; j--) {
                if (matrix[i][j] == target) {
                    return true;
                } else if (matrix[i][j] < target) {
                    break;
                }
            }
        }
      return false;
    }
```

**Solution 2**: Time: O(m) + O(lgn)

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        for (int i = 0, row = matrix.length; i < row; i++) {
            for (int j = matrix[0].length - 1; j >= 0; j--) {
                if (matrix[i][j] == target) {
                    return true;
                } else if (matrix[i][j] < target) {
                    break;
                } else {
                    //do binary search 
                    int l = 0;
                    int r = j - 1;
                    while (l <= r) {
                        int mid = l + (r - l) / 2;
                        if (matrix[i][mid] == target) {
                            return true;
                        } else if (matrix[i][mid] > target) {
                            r = mid - 1;
                        } else {
                            l = mid + 1;
                        }
                    }
                    return false;
                }
            }
        }
      return false;
    }
```

**Solution 3**: Time complexity: O(lgm) + O(lgn)

***There are two ways below, can you find out the big difference here? ***

1) search from right. 

```java
   public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length;
        int col = matrix[0].length;
        int l = 0;
        int r = row - 1;
        //Find row
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (matrix[mid][col - 1] == target) {
                return true;
            } else if (matrix[mid][col - 1] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        //find target in that row
        if (l >= row || l < 0) {
            return false;
        }
        int ll = 0;
        int rr = col - 1;
        while (ll <= rr) {
            int midcol = ll + (rr -ll) / 2;
            if (matrix[l][midcol] == target) {
                return true;
            } else if (matrix[l][midcol] < target) {
                ll = midcol + 1;
            } else {
                rr = midcol - 1;
            }
        }
      return false;
    }
```

2) Search from left 


```java
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length;
        int col = matrix[0].length;
        int l = 0;
        int r = row - 1;
        //Find row
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (matrix[mid][0] == target) {
                return true;
            } else if (matrix[mid][0] > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        //find target in that row
        if (r >= row || r < 0) {
            return false;
        }
        int ll = 0;
        int rr = col - 1;
        while (ll <= rr) {
            int midcol = ll + (rr -ll) / 2;
            if (matrix[r][midcol] == target) {
                return true;
            } else if (matrix[r][midcol] < target) {
                ll = midcol + 1;
            } else {
                rr = midcol - 1;
            }
        }
      return false;
    }
```

<br>
<br>

###75 Sort Colors


> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

>Note:
>You are not suppose to use the library's sort function for this problem. 

**Idea**:

- Solution 1: Use counting sort, we can count the numbers of 0, 1, 2, then refill numbers into A. **Note that this is not inplace**
- Solution 2: Use two pointers for 0 and 1, if we encounter 0, A[count1++] = 1, A[count0++] = 0, if we encounter 1, count1++

**Attention**: 

- 1) For the second method, the sequence of count1++ and count0++ is impoertant, we need first A[count1++] = 1
- 2) Everytime before we move the two pointers, we need to assgin A[i] = 2. Because we don't maintain a pointer for 2, thus the last part would be 2.

**Time complexity**

Use method1 need two pass. Method 2 only need one pass. 


**Java code Solution1**:

```java

    public void sortColors(int[] A) {
    	if(A == null || A.length == 0) return;
    	int count0 = 0;
    	int count1 = 0;
    	for(int i = 0; i < A.length; i++){
    		if(A[i] == 0) count0++;
    		else if(A[i] == 1) count1++;
    	}
    	for(int i = 0; i < A.length; i++){
    		if(i < count0) A[i] = 0;
    		else if(i >= count0 && i < count0+count1) A[i] = 1;
    		else A[i] = 2;
    	}
    }
    

```


**Java code solution 2**:

```java

    public void sortColors(int[] A) {
        if(A == null || A.length == 0) return;
        int count0 = 0, count1 = 0;
        for(int i = 0; i < A.length; i++){
            if(A[i] == 0){
                A[i] = 2;
                A[count1++] = 1;
                A[count0++] = 0;
            }else if(A[i] == 1){
                A[i] = 2;
                A[count1++] = 1;
            }
        }

    }
```

<br>

**Solution 3**:
```java
  public int[] sortColors(int[] array) {
    if (array == null || array.length <= 1) {
      return array;
    }
    int l = 0;
    int r = array.length - 1;
    int m = 0;
    while (m < r) {
      if (array[m] == 1) {
        m++;
      } else if (array[m] == 0) {
        swap(array, l++, m++);
      } else {
        swap(array, m, r--);
      }
    }
    return array;
    }
    private void swap(int[] array, int i, int j) {
      int temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
```


<br>
<br>

###76 Minimum Window Substring
>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
<pre>

For example,
S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC".

Note:
If there is no such window in S that covers all characters in T, return the emtpy string "".

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
</pre>

**Idea**: hashmap && sliding window.

```java
 public String minWindow(String s, String t) {
        if (s.length() < t.length()) {
            return "";
        }
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            Integer temp = map.get(t.charAt(i));
            if (temp == null) {
                map.put(t.charAt(i), 1);
            } else {
                map.put(t.charAt(i), temp + 1);
            }
        }
        int count = 0;
        int start = 0;
        String res = s;
        boolean contains = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            Integer temp = map.get(c);
            if (temp != null) {
                map.put(c, temp - 1);
                if (temp - 1 >= 0) {
                    count++;
                }
            }
            while (count == t.length()) {
                contains = true;
                if (res.length() > i - start + 1) {
                    res = s.substring(start, i + 1);
                }
                if (start < s.length() && map.containsKey(s.charAt(start))) {
                    map.put(s.charAt(start), map.get(s.charAt(start)) + 1);
                    if (map.get(s.charAt(start)) > 0) {
                        count--;
                    }
                }
                start++;
            }
        }
        return contains ? res : "";
    }
```

<br>
<br>

###77 Combinations

>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

<pre>
For example,
If n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>



**Idea**: Same idea with combination sum, difference is that here we use k to determine the recursion termination condition

**Solution**: Recursion

```java
    public List<List<Integer>> combine(int n, int k) {  
        List<List<Integer>> res = new ArrayList<List<Integer>>();  
        if (n <= 0 || n < k) {
            return res;
        }
        combine(n, k, 1, new ArrayList<Integer>(), res);  
        return res;  
    }  
    private void combine(int n, int k, int start, List<Integer> item, List<List<Integer>> res)  {  
        if (item.size() == k) {  
            res.add(new ArrayList<Integer>(item));  
            return;  
        }  
        for (int i = start; i <= n; i++) {  
            item.add(i);  
            combine(n, k, i + 1, item, res);  
            item.remove(item.size() - 1);  
        }  
    } 

```

Similiar recursive solution:

```java
 public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        if (n <= 0 || n < k) {
            return res;
        }
        combine(n, k, 1, new ArrayList<Integer>(), res);
        return res;
    }
    private void combine(int n, int k, int start, List<Integer> cur, List<List<Integer>> res) {
        if (k == 0) {
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        for (int i = start; i <= n; i++) {
            cur.add(i);
            combine(n, k - 1, i + 1, cur, res);
            cur.remove(cur.size() - 1);
        }
    }
```

<br>
<br>

###78 Subsets


>Given a set of distinct integers, nums, return all possible subsets.

>Note:
>Elements in a subset must be in non-descending order.
>The solution set must not contain duplicate subsets.

<pre>
For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

</pre>



**Idea**: 

- Non-decsending order --sort the array first
- step:
	- []
	- []     [1]
	- [] [1]       [2] [1, 2]
	- [] [1] [2] [1, 2]        [3] [1, 3] [2, 3] [1, 2, 3]

From the subsets creation steps above, you must find a way to solve this problem.
The Subset begin with [], after insert 1, it becomes [] [1], you need to combine the original [] and new created[1]. Then add [2] [3] by step. 

**Attention** : What is the time complexity of this problem? Note that the number of subsets increase exponentially.

**Concise DFS solution**:


```java
 public List<List<Integer>> subsets(int[] nums) {
      List<List<Integer>> res = new ArrayList<>();
      Arrays.sort(nums);
      subsets(nums, new ArrayList<Integer>(), 0, res);
      return res;
  }
  private void subsets(int[] nums, List<Integer> list, int index, List<List<Integer>> res) {
      res.add(new ArrayList<Integer>(list));
      for (int i = index; i < nums.length; i++) {
          list.add(nums[i]);
          subsets(nums, list, i + 1, res);
          list.remove(list.size() - 1);
      }
  }

```


**Iterative**:


```java

    public List<List<Integer>> subsets1(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            for (List<Integer> l : res) {
                List<Integer> temp = new ArrayList<Integer>(l);
                temp.add(nums[i]);
                cur.add(temp);
            }
            res.addAll(cur);
        }
        return res;
    }


```


**Recursive**:



```java
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        helper(nums, 0, res);
        return res;
    }
    
    public void helper(int[] nums, int start, List<List<Integer>> res) {
        if (start == nums.length) {
            return;
        }
        List<List<Integer>> cur = new ArrayList<List<Integer>>();
        for (List<Integer> l : res) {
            List<Integer> temp = new ArrayList<Integer>(l);
            temp.add(nums[start]);
            cur.add(temp);
        }
        res.addAll(cur);
        helper(nums, start + 1, res);
    }
```


<br>

**Similar DFS solution**:

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);
    subsets(res, 0, nums, new ArrayList<Integer>());
    return res;
}
private void subsets(List<List<Integer>> res, int start, int[] nums, List<Integer> cur) {
    if (start == nums.length) {
        res.add(new ArrayList<Integer>(cur));
        return;
    }
    subsets(res, start + 1, nums, cur);
    cur.add(nums[start]);
    subsets(res, start + 1, nums, cur);
    cur.remove(cur.size() -1);
}
```



<br>

**Related**: **subsets of string**

> eg: Set = "abc":  [“”, “a”, “ab”, “abc”, “ac”, “b”, “bc”, “c”]

> Set = "":  [""]

> Set = null: []

**Idea**: Same with List. 

**Solution**:

```java
  public List<String> subSets(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    res.add("");
    for (int i = 0; i < set.length(); i++) {
      List<String> current = new ArrayList<String>();
      char c = set.charAt(i);
      for (int j = 0; j < res.size(); j++) {
         String s = res.get(j);
         String newS = concatenate(s, s.length(), c);
         current.add(newS);
      }
      res.addAll(current);
    }
    return res;
  }
  
  public String concatenate(String s, int i, char c) {
    if (s == null || s.length() < i || i < 0) {
      return null;
    }
    return s.substring(0, i) + c + s.substring(i, s.length());
  }
```

<br>

**What if we treat "ac" and "ca"  different?**

**Idea**: Add one more loop, insert each character to each possible index of the all existed strings.

**Solution**:

```java
  public List<String> subSets(String set) {
    List<String> res = new ArrayList<String>();
    if (set == null) {
      return res;
    }
    res.add("");
    for (int i = 0; i < set.length(); i++) {
      List<String> current = new ArrayList<String>();
      char c = set.charAt(i);
      for (int j = 0; j < res.size(); j++) {
         String s = res.get(j);
         for (int k = 0; k <= s.length(); k++) {
           String newS = concatenate(s, k, c);
           current.add(newS);
         }
      }
      res.addAll(current);
    }
    return res;
  }
  
  public String concatenate(String s, int i, char c) {
    if (s == null || s.length() < i || i < 0) {
      return null;
    }
    return s.substring(0, i) + c + s.substring(i, s.length());
  }

```  



<br>
<br>


###79 Word Search

>Given a 2D board and a word, find if the word exists in the grid.

<pre>
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.

</pre>

**Idea**:


**Solution**:

```java
  public boolean exist(char[][] board, String word) {
      for (int i = 0; i < board.length; i++) {
          for (int j = 0; j < board[0].length; j++) {
              if (exist(board, word, i, j, 0)) {
                  return true;
              }
          }
      }
      return false;
  }
  private boolean exist(char[][] board, String word, int i, int j, int index) {
      if (index == word.length()) {
          return true;
      }
      if (i >= board.length || j >= board[0].length || j < 0 || i < 0 || word.charAt(index) != board[i][j]) {
          return false;
      }
      board[i][j] = '*'; //mark as read
      boolean res = exist(board, word, i - 1, j, index + 1) || exist(board, word, i + 1, j, index + 1)
                    || exist(board, word, i, j - 1, index + 1) || exist(board, word, i, j + 1, index + 1);
      board[i][j] = word.charAt(index);
      return res;
  }

```

<br>
<br>

###80 Remove Duplicates From Sorted Array II

>Follow up for "Remove Duplicates":
>
>What if duplicates are allowed at most twice?
>
>For example,
>
>Given sorted array A = [1,1,1,2,2,3],
>
>Your function should return length = 5, and A is now [1,1,2,2,3].

**Idea**: It's the same method with [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array). Only diffence is that we need to compare with previous and previous previous element. 

**Java Code**:

First try:

```java

    public int removeDuplicates(int[] A) {
        if(A == null) return 0;
        if(A.length <= 2) return A.length;
        int count = 2;
        int pre = A[1];
        int prepre = A[0];
        for(int i = 2; i < A.length; i++){
            if(A[i] == pre && A[i] == prepre) continue;
            A[count++] = A[i];
            prepre = pre;
            pre = A[i];
        }
        return count;
    }
	

```

More concise solution:

```java
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) {
            return nums.length;
        }
        int j = 2;
        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[j - 2]) {
                nums[j++] = nums[i];
            }
        }
        return j;
    }
```



<br>
<br>

###81 Search in Rotated Sorted Array II

>Follow up for "Search in Rotated Sorted Array":
**What if duplicates are allowed?**

>Would this affect the run-time complexity? How and why?

>Write a function to determine if a given target is in the array.


**Idea**: In * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array), we can make sure that each time we cut half of the array, thus the totla time complexity is O(lgn). In this problem, since the existence of dulicates, thus the A[mid] might equals to A[l] and A[r]. From this information, we don't know which half we should go. Thus the worst case would be **O(n)** 

How to solve this problem? We can use the second method in * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array). If we can not find an increasing  interval of A[l]-A[mid] and A[mid]-A[r], we can just move one step right or one step left by l++ or r--



**Solution 1 
**:


```java
 public boolean search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return false;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
           int mid = l + (r - l) / 2;
           if (A[mid] == target) {
               return true;
           } else if (A[mid] > A[l]) {
               if (A[l] <= target && A[mid] > target) {
                   r = mid - 1;
               } else {
                   l = mid + 1;
               }
           } else if (A[mid] < A[l]){
               if (A[mid] < target && A[r] >= target) {
                   l = mid + 1;
               } else {
                   r = mid - 1;
               }
           } else {
            l++;
           }
        } 
        return false;
    }

```


**Solution 2**:  Even though in worst cast this solution is same with solution 1, in saome cases solution 1 has better time complexity

```java

  public boolean search(int[] A, int target) {
        if(A == null || A.length == 0) {
            return false;
        }
        int l = 0;
        int r = A.length-1;
        while(l <= r){
            int mid = (l+r)/2;
            if(A[mid] == target) {
                return true;
            } else if(A[mid] > target && A[mid] < A[r]) {
                r = mid-1;
            } else if(A[mid] < target && A[mid] > A[l]) {
                l = mid + 1;
            } else if (A[l] != target) {
                l++;
            } else {
                return true;
            }
        }
        return false;
    }


```


<br>
<br>



###82 Remove Duplicates from Sorted List

>Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

**Idea**: It's simple compare to * [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii). Because there are less corner cases related to null pointers. Just if head != null, start from the head.next, when encounter duplicates, delete that node. 

```java
   public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return null;
        ListNode pre = head;
        ListNode temp = head.next;
        while(temp != null){
            if(temp.val == pre.val) {
                pre.next = temp.next;
                temp = temp.next;
            }else{
                pre = temp;
                temp = temp.next;
            }
        }
        return head;
    }

```    

<br>
<br>

###83 Remove Duplicates from Sorted List II

>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

<pre>
For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.
</pre>

**Idea**:

1) Compare each node with it's next, count++ if duplicate is found. if head.val != head.next.val, then check if count == 1. If yes, add node, else reset head to 1 and  continue.


**Attention**: Remember to check count at the end. If count == 1, add the last node. else set result's tail.next = null. 

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode feakHead = new ListNode(-1);
        ListNode h1 = feakHead;
        int count = 1;
        while(head != null && head.next != null){
            if(head.val == head.next.val){
                head = head.next;
                count++;
            }else{
                if(count == 1){
                    h1.next = head;
                    head = head.next;
                    h1 = h1.next;
                }else{
                    head = head.next;
                    count = 1;
                }
            }
        }
        if(count == 1) h1.next = head;
        else h1.next = null;
        return feakHead.next;
    }
```




<br>
<br>

###84 Largest Rectangle in Histogram
>Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

**Idea**: http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html

**Solution**:

```java
public int largestRectangleArea(int[] height) {
  Deque<Integer> stack = new LinkedList<>();
  int res = 0;
  for (int i = 0; i <= height.length; i++) {
      while (!stack.isEmpty() && (i == height.length || height[stack.peek()] > height[i])) {
          res = Math.max(res, height[stack.pop()] * (stack.isEmpty() ? i : (i - stack.peek() - 1)));
      }
      stack.push(i);
  }
  return res;
}
```

<br>
<br>

###85 Maximal Rectangle

>Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

**Solution**:

- A great solution from leetcode discussion: https://leetcode.com/discuss/20240/share-my-dp-solution. It's hard for me to understand


**Another Solution based on ###84 Largest Rectangle in Histogram**:

Time complexity : O(m * n)

```java
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }
    int[] height = new int[matrix[0].length + 1];
    int res = 0;
    for (int i = 0; i < matrix.length; i++) {
        Deque<Integer> stack = new LinkedList<>();
        for (int j = 0; j <= matrix[0].length; j++) {
            if (j < matrix[0].length) {
                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;
            }
            while (!stack.isEmpty() && (j == matrix[0].length || height[stack.peek()] > height[j])) {
                res = Math.max(res, height[stack.pop()] * (stack.isEmpty() ? j : (j - stack.peek() - 1)));
            }
            stack.push(j);
        }
    }
    return res;
}
```

<br>
<br>



###86 Partition List

>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should **preserve the original relative order** of the nodes in each of the two partitions.

<pre>
For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.
</pre>

**Idea**: We need to preserve the original order, thus we can maintain two pointers, h1 and tail. h1 is the place we need to insert the element which smaller than x. tail is the end of the result list from which we add the elements equal or larger than x. 

**Attention**: We need to 
```java
    public ListNode partition(ListNode head, int x) {
        if (head == null) {
            return null;
        }
        ListNode feakHead = new ListNode(-1);
        ListNode h = feakHead;
        ListNode tail = feakHead;
        while (head != null){
            if (head.val >= x) {
                tail.next = head;
                head = head.next;
                tail = tail.next;
                tail.next = null;
            } else{
                 ListNode saveH = h;
                 ListNode temp = h.next;
                 h.next = head;
                 head = head.next;
                 h = h.next;
                 h.next = temp;
                 if (tail.equals(saveH)) {
                    tail = h;
                 }
            }
        }
        return feakHead.next;
    }

```

**Another solution**: much similar to the first one

```java
  public ListNode partition(ListNode head, int target) {
    // write your solution here
    if (head == null || head.next == null) {
      return head;
    }
    ListNode fakeHead1 = new ListNode(-1);
    ListNode fakeHead2 = new ListNode(-1);
    ListNode smaller = fakeHead1; // position to insert elements smaller than target
    ListNode larger = fakeHead2; // position to insert elements larger than target
    ListNode temp = head;
    while (temp != null) {
      ListNode next = temp.next;
      temp.next = null;
      if (temp.value < target) {
        smaller.next = temp;
        smaller = smaller.next;
      } else {
        larger.next = temp;
        larger = larger.next;
      }
      temp = next;
    }
    smaller.next = fakeHead2.next;
    return fakeHead1.next;
  }
```

<br>
<br>

###87 Scramble String

>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

<pre>

Below is one possible representation of s1 = "great":

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

</pre>

**Solution 1**: Devide and Conqure + Recursion. Divide String into two parts. s1[0, i) and s1[i, end]. Check if isScramble(s1[0, i), s2[0, i)) && isScramble(s1[i, end], s2[i, end]) is true or 
isScramble(s1[0, i), s2[s2.length() - i, end)) && isScramble(s1[i, end], s2[0, s2.length() - i])

```java
 public boolean isScramble(String s1, String s2) {
    if (!isAnagram(s1, s2)) {
        return false;
    }
    if (s1.equals(s2)) {
        return true;
    }
    for (int i = 1; i < s1.length(); i++) {
        if ((isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) || (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))) {
            return true;
        } 
    }
    return false;
}
private boolean isAnagram(String s1, String s2) {
    char[] arr1 = s1.toCharArray();
    char[] arr2 = s2.toCharArray();
    Arrays.sort(arr1);
    Arrays.sort(arr2);
    return Arrays.equals(arr1, arr2);
}
```


**Solution 2**: DP, the induction rule has the same idea with the resursion solution.

dp[i][j][len] represents that s1 starts from index i, length len, s2 starts from index j, length len, check if they are scramble.
)
To check if dp[i][j][len] is true, we need to divide len into two parts. (1, len-1)  or (2, len-2).....


```java
public boolean isScramble(String s1, String s2) {
    if (s1.length() != s2.length()) {
        return false;
    }
   boolean dp[][][] = new boolean[s1.length()][s1.length()][s1.length() + 1];
   for (int i = s1.length() - 1; i >= 0; i--) {
       for (int j = s1.length() - 1; j >= 0; j--) {
           dp[i][j][1] = (s1.charAt(i) == s2.charAt(j));
           for (int len = 2; i + len <= s1.length() && j + len <= s1.length(); len++) {
               for (int k = 1; k < len; k++) {
                   dp[i][j][len] |= (dp[i][j][k] && dp[i + k][j + k][len - k])
                                    || (dp[i][j + len - k][k] && dp[i + k][j][len - k]);
               }
           }
       }
   }
   return dp[0][0][s1.length()];
}
```


<br>
<br>

###89 Gray Code
>The gray code is a binary numeral system where two successive values differ in only one bit.

>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

>00 - 0

>01 - 1

>11 - 3

>10 - 2

>Note:
>For a given n, a gray code sequence is not uniquely defined.

>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

Let's first see a few example of gray code and find the laws to create gray code

	n = 1: 0 
		   1
	
	n = 2: 00 
		   01
		   11
		   10

	n = 3: 000
	       001
	       011
	       010
	       110
	       111
	       101
	       100
	       
	 n = 4: 0000
	 	    0001
	 	    0011
	 	    0010
	 	    0110
	 	    0111
	 	    0101
	 	    0100
	 	    1100
	 	    1101
	 	    1111
	 	    1110
	 	    1010
	 	    1011
	 	    1001
	 	    1000
		   
**Some laws from above** : we can find that the first half of  2 ^ n numbers could be create by add a 0 to 2 ^ (n-1) numbers. For the last half of 2 ^ n, we can add 1 to the reversed order number of 2 ^ (n-1). 

For example, based on 2 bit gray code, we can get the first half of 3 bit gray code by adding 0, eg: 000 001 011 010, for the last half, we first reverse the order 10, 11, 01, 00, then add 1 to each of them, we can get 110 111 101 100.

**Time Complexity**: we have 2 ^ n gray code numbers, thus the time complexity is 2 ^ n
**Space**: 2 ^ n
```java
    public List<Integer> grayCode(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n < 0) return list;
        list.add(0);
        if(n == 0) return list;
        list.add(1);
        for(int i = 2; i <= n; i++){
            for(int j = list.size()-1; j >= 0; j--){
                list.add(list.get(j) + (1 <<(i-1)));
            }
        }
        return list;
     }
```
**Related Questions** : check if two bytes can be put successively in a gray code sequence.

**Idea**: we know that the neighbor gray code numbers is different with 1 bit. We need to check if these two numbers have only one bit diffenence.

```java
	public boolean isSuccesive(byte b1, byte b2){
		int count = 0;
		while(b1 > 0 || b2 > 0){
			if((b1 & 1) != (b2 & 1))
				count++;
			b1 >>>= 1;
			b2 >>>= 1;
		}
		return count == 1;
	}
```

If the numbers are unsigned numbers, we can first ^ then check if it is the power of 2
```java	
	temp = b1 ^ b2;
	
	return (temp > 0) && ((temp & -temp) == temp); 
	
	return (temp > 0) && ((temp & (temp -1)) == 0);
	
```	
<br>
<br>


###90 Subsets II

>Given a collection of integers that might contain duplicates, nums, return all possible subsets.

<pre>
Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>


**Idea**: The different with * [78 Subsets](#78-subsets) is that in this problem the nums might contain duplicates.

How to handle duplicates? 

Consider the above case [1, 2, 2], then the steps are below:

- []
- []      [1]
- [][1]   [2][1,2]
- [][1][2][1,2]  [2,2][1, 2, 2]

You might make a mistake that if duplicates occur, we just need to insert new element into the last half of the pre subsets. This seems true at first glance. 

Consider the case [2, 2, 2, 2, 2]

- [] 
- []   [2]
- [][2]   [2,2]
- [][2][2,2]   [2,2,2]
- [][2][2,2][2,2,2]    [2,2,2,2]
- .......

Actually, the start position we need to insert is the size of the prev subsets result. 

Here are he solutions.


**Concise DFS solution**:

```java
  public List<List<Integer>> subsetsWithDup(int[] nums) {
      List<List<Integer>> res = new ArrayList<>();
      Arrays.sort(nums);
      subsets(nums, new ArrayList<Integer>(), 0, res);
      return res;
  }
  private void subsets(int[] nums, List<Integer> list, int index, List<List<Integer>> res) {
      res.add(new ArrayList<Integer>(list));
      for (int i = index; i < nums.length; i++) {
          if (i == index || nums[i] != nums[i - 1]) {
              list.add(nums[i]);
              subsets(nums, list, i + 1, res);
              list.remove(list.size() - 1);
          }
      }
  }
```


**Iterative**:


```java
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        if (nums == null || nums.length == 0) {
            return res;
        }
        Arrays.sort(nums);
        int prevSize = 0;
        for (int i = 0; i < nums.length; i++) {
            List<List<Integer>> cur = new ArrayList<List<Integer>>();
            int startPos = 0;
            if (i > 0 && nums[i] == nums[i-1]) {
                startPos = prevSize;
            } 
           for (;startPos< res.size(); startPos++) {
                List<Integer> temp = new ArrayList<Integer>(res.get(startPos));
                temp.add(nums[i]);
                cur.add(temp);
            }
            prevSize = res.size();
            res.addAll(cur);
        }
        return res;
    }
```


**Resursion**:


```java
 public List<List<Integer>> subsetsWithDup(int[] nums) {
	        List<List<Integer>> res = new ArrayList<List<Integer>>();
	        res.add(new ArrayList<Integer>());
	        if (nums == null || nums.length == 0) {
	            return res;
	        }
	        Arrays.sort(nums);
	        helper(nums, 0, res, 0);
	        return res;
	    }
	    
	    public void helper(int[] nums, int start, List<List<Integer>> res, int lastSize) {
	        if (start == nums.length) {
	            return;
	        }
	        List<List<Integer>> cur = new ArrayList<List<Integer>>();
	        int insertPos = 0;
	        if (start > 0 && nums[start] == nums[start-1]) {
	            insertPos = lastSize;
	        }
	        for (; insertPos < res.size(); insertPos++) {
	            List<Integer> temp = new ArrayList<Integer>(res.get(insertPos));
	            temp.add(nums[start]);
	            cur.add(temp);
	        }
	        lastSize = res.size();
	        res.addAll(cur);
	        helper(nums, start + 1, res, lastSize);
	    }
    

```


<br>
<br>

###91 Decode Ways

>A message containing letters from A-Z is being encoded to numbers using the following mapping:

<pre>

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2.

</pre>

**Brute force && recursion**: For decoding, we can decode 1 character or 2 character(if these 2 characters are valid). 

Time limit exceeded on leetcode.

```java
   public int numDecodings(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) == '0') {
            return 0;
        }
        int[] res = new int[1];
        decoding(res, s, 0);
        return res[0];
    }
    private void decoding(int[] res, String s, int index) {
        if (index == s.length()) {
            res[0] += 1;
            return;
        }
        if (s.charAt(index) == '0') {
            if (s.charAt(index - 1) != '1' && s.charAt(index - 1) != '2') {
              return;
            }
        } else {
          decoding(res, s, index + 1);
          if (index < s.length() - 1 && valid(s.substring(index, index + 2))) {
            decoding(res, s, index + 2);
          }
        }
    }
    private boolean valid(String s) {
      int val = Integer.valueOf(s);
      return val >= 10 && val <= 26;
    }
```

**DP solution**: It's kind of like climb stairs, each time we can climb one stair or two stairs. The difference here is that it is not guaranteed that we can decode 2 characters at a time. 

Thus the induction rule of the DP is : 

- dp[i] = dp[i - 1] + dp[i - 2] if we can decode 2 characters at a time.
- dp[i] = dp[i - 1] if we can only decode one character at a time.


```java

    public int numDecodings(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) == '0') {
            return 0;
        }
        int res = 1;
        int pre = 1;
        int prepre = 1;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == '0') {
                if (s.charAt(i - 1) != '1' && s.charAt(i - 1) != '2') {
                    return 0;
                }
                res = prepre;
            } else if (valid(s.substring(i - 1, i + 1))) {
                res = pre + prepre;
            }
            prepre = pre;
            pre = res;
        }
        return res;
    }
    
    private boolean valid(String s) {
      int val = Integer.valueOf(s);
      return val >= 10 && val <= 26;
    }

```




<br>
<br>

###92 Reverse Linked List II

>Reverse a linked list from position m to n. Do it in-place and in one-pass.

<pre>

For example:
Given 1->2->3->4->5->NULL, m = 2 and n = 4,

return 1->4->3->2->5->NULL.

Note:
Given m, n satisfy the following condition:
1 ≤ m ≤ n ≤ length of list.
	
</pre>

**Idea**: 1) Find begining node of reverse. 2) reverse m-n 3) concatenate 

**Attention**:

- 1) when concatenate, take care of null pointer. ***(When use node.next, always check if node is null)***
- 2) If m == 1, what should we return? So check the previous node of the reverse list's head, if it's null, just return the reverse head. 
- 3) Take care of the steps. We need to move ***m-1*** steps to find the beginning of the reverse. We need take another ***n-m+1*** steps to reverse the nodes. 
```java
    public ListNode reverseBetween1(ListNode head, int m, int n) {
        if(head == null || head.next == null || (m == n)) return head;
        ListNode saveHead = head;
        ListNode preReverse = null;
        while(m-1 > 0){
            preReverse = head;
            head = head.next;
            m--;
            n--;
        }
        ListNode reverseHead = null;
        ListNode reverseTail = null;
        ListNode next = null;
        while(n-1 >= 0){
            n--;
            if(reverseHead == null){
                reverseHead = head;
                reverseTail = head;
                head = head.next;
                continue;
            }
            next = head.next;
            head.next = reverseHead;
            reverseHead = head;
            head = next;
        }
        if(preReverse != null) preReverse.next = reverseHead;
        if(reverseTail != null) reverseTail.next = head;
        if(preReverse == null) return reverseHead;
        return saveHead;
      }
```   
   <br>
 
     

Pretty much the save with the above, just change while to for:
```java
  public ListNode reverseBetween(ListNode head, int m, int n) {
    	if(head == null) return null;
    	if(m < 0) m = 0;
    	if(m > n){
    		int tempValue = m;
    		m = n;
    		n = tempValue;
    	}
    	
    	ListNode temp = head;
    	ListNode previousM = null;
    	
    	/* find node at m */
    	for(int i = 1; i < m && temp != null; i++){
    		previousM = temp;
    		temp = temp.next;
    	}
    	ListNode saveTemp = temp;
    	
    	/* reverse node between m and n */
    	ListNode pre = null;
    	ListNode next = null;
    	for(int i = m; i <= n && temp != null; i++){
    		next = temp.next;
    		temp.next = pre;
    		pre = temp;
    		temp = next;
    	}
    	
    	/* concatenate */
    	if(previousM != null) previousM.next = pre;
    	if(saveTemp != null) saveTemp.next = temp;
    	
    	if(m == 1) return pre; 
    	return head;
     }
     
``` 


<br>
<br>


###93 Restore IP Addresses

>Given a string containing only digits, restore it by returning all possible valid IP address combinations.

<pre>
For example:
Given "25525511135",

return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)
</pre>

**Idea**: Because it is ip address, thus we need to divide it into valid 4 parts. 

**Iterative solution**:

```java
 public List<String> restoreIpAddresses(String s) {
    List<String> res = new ArrayList<>();
    if (s == null || s.length() < 4 || s.length() > 12) {
        return res;
    }
    for (int i = 1; i < 4 && i < s.length() - 2; i++) {
        for (int j = i + 1; j < i + 4 && j < s.length() - 1; j++) {
            for (int k = j + 1; k < j + 4 && k < s.length(); k++) {
                String s1 = s.substring(0, i);
                String s2 = s.substring(i, j);
                String s3 = s.substring(j, k);
                String s4 = s.substring(k, s.length());
                if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {
                    res.add(s1 + "." + s2 + "." + s3 + "." + s4);
                }
            }
        }
    }
    return res;
}
private boolean isValid(String s) {
    return s.length() > 0 && s.length() <= 3 && Integer.parseInt(s) <= 255 && !(s.charAt(0) == '0' && s.length() > 1);
}
```

**Recursion**:

```java
   public List<String> restoreIpAddresses(String s) {
        List<String> res = new ArrayList<>();
        if (s == null || s.length() < 4 || s.length() > 12) {
            return res;
        }
        restore(s, 0, 1, "", res);
        return res;
    }
    
    private void restore(String s, int index, int segmentNum, String cur, List<String> res) {
        if (index >= s.length()) {
            return;
        }
        if (segmentNum == 4) {
            String seg = s.substring(index);
            if (isValid(seg)) {
                res.add(cur + "." + seg);
            }
            return;
        }
        for (int i = 1; i < 4 && ((index + i) < s.length()); i++) {
            String seg = s.substring(index, index + i);
            if (isValid(seg)) {
                if (segmentNum == 1) {
                    restore(s, index + i, segmentNum + 1, seg, res);
                } else {
                    restore(s, index + i, segmentNum + 1, cur + "." + seg, res);
                }
            }
        }
    }
    
    private boolean isValid(String s) {
        return s.length() > 0 && s.length() <= 3 && Integer.parseInt(s) <= 255 && !(s.charAt(0) == '0' && s.length() > 1);
    }
```





<br>
<br>


###94 Binary Tree Inorder Traversal

> Given a binary tree, return the inorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,3,2].

</pre>

> Note: Recursive solution is trivial, could you do it iteratively?

**Idea**: 

- 1) Solution 1: Recursion. It's the simplest method. Just visit in left, root, right order.

- 2) Solution 2: Iterative. Use a stack to record the parant node, so we can go to it and its right child after visit its left child.

- 3) Solution 3 : Morris Traversal. Use a pointer to go back to its parent after visit it's left child. Note that use this method we only need O(1) space. Want to know more about Morris traversal click on this link. [Morris Traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/). 


**Solution 1, Recursion**:


```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    inorderTraversal(root, res);
    return res;
}
public void inorderTraversal(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    inorderTraversal(root.left, res);
    res.add(root.val);
    inorderTraversal(root.right, res);
}
```



**Solution 2, Iterative**:

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    Stack<TreeNode> stack = new Stack<TreeNode>();
    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            res.add(root.val);
            root = root.right;
        }
    }
    return res;
}
```



**Solution 3: Morris Traversal**:

```java

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    TreeNode pre = null;
    while (root != null) {
        if (root.left == null) {
            res.add(root.val);
            root = root.right;
        } else {
            pre = root.left;
            while (pre.right != null && pre.right != root) {
                pre = pre.right;
            }
            if (pre.right == null) {
                pre.right = root;
                root = root.left;
            } else {
                pre.right = null;
                res.add(root.val);
                root = root.right;
            }
        }
    }
    return res;
}

```


<br>
<br>

**Related**: Get Keys In Binary Search Tree In Given Range

>Get the list of keys in a given binary search tree in a given range[min, max] in ascending order, both min and max are inclusive.

```java
  public List<Integer> getRange(TreeNode root, int min, int max) {
    List<Integer> res = new ArrayList<Integer>();
    getRange(root, min, max, res);
    return res;
  }
  public void getRange(TreeNode root, int min, int max, List<Integer> res) {
    if (root == null) {
      return;
    }
    if (root.key >= min) {
      getRange(root.left, min, max, res);
    }
    if (root.key >= min && root.key <= max) {
      res.add(root.key);
    }
    if (root.key <= max) {
      getRange(root.right, min, max, res);
    }
  }
```

<br>
<br>

###95 Unique Binary Search Trees

> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

> For example,

> Given n = 3, there are a total of 5 unique BST's.

<pre>


   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3


</pre>



**Idea**: Consider a binary rooted at certain node node1, the number of unique binary trees would be #left sub-BST * #right sub-BST. So the total number of binary search tree would be sum of binary trees rooted at each node. 

This is similar to the [catalan numbers](http://en.wikipedia.org/wiki/Catalan_number). In this problem, we could use dynamic programming to store middle results.  

Cn+1 = Sum (ci * c[n-i]), i = 0, 1, 2,....nwq   
  

**Java code**:

```java
    public int numTrees(int n) {
       int[] res = new int[n+1];
       res[0] = 1;
       res[1] = 1;
       for (int i = 2; i <= n; i++) {
           for (int j = 0; j < i; j++) {
               res[i] += res[j] * res[i - j - 1];
           }
       }
       return res[n];
    }

```


<br>
<br>


###96 Unique Binary Search Trees II

> Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

<pre>
For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.

</pre>

**Idea**: The basic Idea is same as [95 Unique Binary Search Trees](#95-unique-binary-search-trees). We still need to create the left sub-BST and right sub-BST, then combine it with the root. 

This is a bottom up approach, we create the trees from leaves. The time complexity is not polynomial. 

**Attention**: In order to create all the combinations in the for loop. So when left subtree is null, we still need to add null to list. 

```java
    public List<TreeNode> generateTrees(int n) {
        List<TreeNode> res = new ArrayList<TreeNode>();
        if (n < 0) {
           return res;
        }  
        return generateTrees(1, n);
    }
    public List<TreeNode> generateTrees(int l,  int r) {
       List<TreeNode> res = new ArrayList<>();
       if (l > r) {
           res.add(null);
           return res;
       }
       for (int i = l; i <= r; i++) {
           //i is root.
           List<TreeNode> resL = generateTrees(l, i - 1);
           List<TreeNode> resR = generateTrees(i + 1, r);
           for (TreeNode lNode : resL) {
               for (TreeNode rNode : resR) {
                   TreeNode root = new TreeNode(i);
                   root.left = lNode;
                   root.right = rNode;
                   res.add(root);
               }
           }
       }
       return res;
    }
```




<br>
<br>

###97 Interleaving String

>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

<pre>
For example,
Given:
s1 = "aabcc",
s2 = "dbbca",

When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.
</pre>

**Brute force*: time limit exceeded.

```java
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s3.length() != s1.length() + s2.length()) {
            return false;
        }
        return isInterleave(s1, 0, s2, 0, s3, 0);
    }
    private boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3) {
        if (i3 == s3.length() && i1 == s1.length() && i2 == s2.length()) {
            return true;
        }
        if (i3 == s3.length() || (i1 == s1.length() && i2 == s2.length())) {
            return false;
        }
        if (i1 == s1.length()) {
             return s2.charAt(i2) == s3.charAt(i3) ? isInterleave(s1, i1, s2, i2 + 1, s3, i3 + 1) : false;
        }
        if (i2 == s2.length()) {
            return s1.charAt(i1) == s3.charAt(i3) ? isInterleave(s1, i1 + 1, s2, i2, s3, i3 + 1) : false;
        }
        return (s1.charAt(i1) == s3.charAt(i3) && isInterleave(s1, i1 + 1, s2, i2, s3, i3 + 1)) || 
                ( s2.charAt(i2) == s3.charAt(i3) && isInterleave(s1, i1, s2, i2 + 1, s3, i3 + 1));
    }
```

**Dp solution**: Since the dp induction rule is just based on previous row, thus we can reduce it to one dimensional array.

```java
  public boolean isInterleave(String s1, String s2, String s3) {
      if (s3.length() != s1.length() + s2.length()) {
          return false;
      }
      boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
      dp[0][0] = true;
      for (int i = 0; i <= s1.length(); i++) {
          for (int j = 0; j <= s2.length(); j++) {
              if (i == 0 && j == 0) {
                   dp[i][j] = true;
              } else if (i == 0) {
                  dp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
              } else if (j == 0) {
                   dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i - 1);
              } else {
                  dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
              }
          }
      }
      return dp[s1.length()][s2.length()]; 
  }
```

<br>
<br>


###98 Validate Binary Search Tree

>Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys **less than** the node's key.
The right subtree of a node contains only nodes with keys **greater than** the node's key.
Both the left and right subtrees must also be binary search trees.

**Idea**: We know that if a tree is a binary search tree, then it's inorder traversal is sequential. Thus we can traverse the tree inorder to check if everynode's predecessor is less than the node. We can also traverse the tree inorder and save the sequence, then check if there is out of order nodes. But it will require addtional space. 

**Time**: O(n) **Space**: O(lgn)


**Note**: Remember to check if pre is null before compare pre.val and root.val

```java
  public boolean isValidBST(TreeNode root) {
    // Write your solution here.
    if (root == null) {
      return true;
    }
    boolean[] res = new boolean[1];
    res[0] = true;
    isBST(root, res, new TreeNode[1]);
    return res[0];
  }
  
  public void isBST(TreeNode root, boolean[] res, TreeNode[] pre) {
    if (root == null) {
      return;
    }
    isBST(root.left, res, pre);
    if (pre[0] != null && pre[0].val >= root.val) {
      res[0] = false;
    }
    pre[0] = root;
    isBST(root.right, res, pre);
  }
```


**Other idea**: We record the lower bound and upper bound for each node. If a node's value is not between the lower bound and upper bound, return false. There is a problem with this method: if the tree contains nodes with value of Integer.MIN_VALUE AND Integer.MAX_VALUE. 

```java

    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    public boolean isValidBST(TreeNode root, int min, int max) {
        if (root == null) {
            return true;
        }
        if (root.val <= min || root.val >= max) {
            return false;
        }
        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
    }
	

```

**Wrong answer**: The following code just check if each node maintains node.val > node.left.val and node.val < node.right.val. However, even though each node satisfies this condition, it might not be a binary search tree. Eg: 10,5,15,#,#,6,20

```java
  public boolean isValidBST1(TreeNode root) {
        if (root == null || (root.left == null && root.right == null)) {
            return true;
        }
        if ((root.left != null && root.left.val >= root.val) || (root.right != null && root.right.val <= root.val)) {
            return false;
        }
        return isValidBST(root.left) && isValidBST(root.right);
   }

```
<br>
<br>


###99 Recover Binary Search Tree

> Two elements of a binary search tree (BST) are swapped by mistake.

> Recover the tree without changing its structure.

> Note:

> A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?

**Idea**: We can traverse the tree inorder to find the misplaced TreeNode. If we use recursion, we need O(n) space. If we use morris traversal, we can solve this problem in constant space. 


**Solution 1: O(n) space.**

```java
    public void recoverTree(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode[] arr = new TreeNode[3];
        recoverTree(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    public void recoverTree(TreeNode root, TreeNode[] arr) {
        if(root == null) {
            return;
        }
        recoverTree(root.left, arr);
        if (arr[2] != null && arr[2].val > root.val) {
            if(arr[0] == null) {
                arr[0] = arr[2];
            }
            arr[1] = root;
        }
        arr[2] = root;
        recoverTree(root.right, arr);
    }

```

**Solution2 : morris**

```java
	/*Morris traversal O(1) */
       public void recoverTree(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode[] arr = new TreeNode[3];
        recoverTree(root, arr);
        int temp = arr[0].val;
        arr[0].val = arr[1].val;
        arr[1].val = temp;
    }
    
    public void recoverTree(TreeNode root, TreeNode[] arr){
        if(root == null) {
            return;
        }

        TreeNode pre = null; /* predecessor*/
        TreeNode previous = null;
        while (root != null) {
            if (root.left == null) {
                if (previous != null && previous.val > root.val) {
                    if(arr[0] == null) {
                        arr[0] = previous;
                    }
                    arr[1] = root;
                }
                previous = root;
                root = root.right;
            }else{
                /* find predecessor */
                pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }

                /* if predecessor's right == null, set current node as its right child */
                if (pre.right == null) {
                    pre.right = root;
                    root = root.left;
                } else {
                    /* recover tree, when return to parent node the second time */
                    pre.right = null;
                    if (previous != null && previous.val > root.val) {
                        if(arr[0] == null) {
                            arr[0] = previous;
                        }
                        arr[1] = root;
                    }   
                    previous = root;
                    root = root.right;
                }
            }
        }
    }
```

<br>
<br>


###100 Same Tree

> Given two binary trees, write a function to check if they are equal or not.

>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


**Idea**: We can choose any traverse method to visit each node and check if they are the same. We need to check the val, the left child and the right child.

**Java code**:


```java
 public boolean isSameTree(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    }
    if (one == null || two == null || one.val != two.val) {
      return false;
    }
    return isSameTree(one.left, two.left) && isSameTree(one.right, two.right);
  }
```

**Time complexity analysis**:

- 1) way 1 : T(n) = 2 T(n/2) + 1. Use master theory, we got T = O(n)
- 2) way 2 : recursion tree. T(n) = 2 ^ log2(n) = O(n)

<br>

<br>

**Related**: Tweaked Identical Binary Trees

> Determine whether two given binary trees are identical assuming any number of ‘tweak’s are allowed. A tweak is defined as a swap of the children of one node in the tree

**Idea**: basically, it's the same idea with same tree or symmetric tree. If it's same or tweaked, we return true

**solution**:

```java
  public boolean isTweakedIdentical(TreeNode one, TreeNode two) {
    if (one == null && two == null) {
      return true;
    }
    if (one == null || two == null || one.key != two.key) {
      return false;
    }
    return (isTweakedIdentical(one.left, two.left) && isTweakedIdentical(one.right, two.right)) || (isTweakedIdentical(one.right, two.left) && isTweakedIdentical(one.left, two.right));
  }

```

**Time complexity analysis**:

- 1) way 1 : T(n) = 4 T(n/2) + 1. Use master theory, we got T = O(n^2)
- 2) way 2 : recursion tree. T(n) = 4 ^ log2(n) = 2 ^ (2 log2(n)) = 2 ^ log2(n^2) = O(n^2)

<br>
<br>



###101 Symmetric Tree

> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

<pre>
For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3

</pre>
Note:
Bonus points if you could solve it both recursively and iteratively.

**Idea**: 

- 1) root is null, then return true
- 2) left and right child are both null return true;
- 3) left and right only one is null, return false
- 4) left and right both exist, check if their value equals
- 5) go to next level, check the relatin of left.left and right.right , left.right and right.left

**Solution 1**: Recursive

```java
  public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    return isSymmetric(root.left, root.right);
  }
  
  public boolean isSymmetric(TreeNode l, TreeNode r) {
    if (l == null && r == null) {
      return true;
    }
    if (l == null || r == null || l.val != r.val) {
      return false;
    }
    return isSymmetric(l.left, r.right) && isSymmetric(l.right, r.left);
    
  }

```

**Solution 2**: Iterative

```java
  public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    if (root.left == null || root.right == null) {
        return false;
    }
    Queue<TreeNode> queueL = new LinkedList<TreeNode>();
    Queue<TreeNode> queueR = new LinkedList<TreeNode>();
    queueL.offer(root.left);
    queueR.offer(root.right);
    while (!queueL.isEmpty() && !queueR.isEmpty()) {
        TreeNode l = queueL.poll();
        TreeNode r = queueR.poll();
        if (l.val != r.val) {
            return false;
        }
        if (l.left != null) {
            if (r.right == null) {
                return false;
            }
            queueL.offer(l.left);
            queueR.offer(r.right);
        } else {
            if (r.right != null) {
                return false;
            }
        }
        if (l.right != null) {
            if (r.left == null) {
                return false;
            }
            queueL.offer(l.right);
            queueR.offer(r.left);
        } else {
            if (r.left != null) {
                return false;
            }
        }
    } 
    return true;
  }
```

**Solution 3**: concise version

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null || (root.left == null && root.right == null)) {
      return true;
    }
    Queue<TreeNode> queueL = new LinkedList<TreeNode>();
    Queue<TreeNode> queueR = new LinkedList<TreeNode>();
    queueL.offer(root.left);
    queueR.offer(root.right);
    while (!queueL.isEmpty() && !queueR.isEmpty()) {
        TreeNode l = queueL.poll();
        TreeNode r = queueR.poll();
        if (l == null && r == null) {
            continue;
        }
        if ((l == null && r != null) || (l != null && r == null) || l.val != r.val) {
            return false;
        }
        queueL.offer(l.left);
        queueR.offer(r.right);
        queueL.offer(l.right);
        queueR.offer(r.left);
    } 
    return true;
  }
```

<br>
<br>
###102 Binary Tree Level Order Traversal

>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
</pre>

**Idea**: 

-1) Breadth first search -> Queue

-2) each time not just poll one node from queue, but poll a level of nodes from queue


**Solution**:

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            cur.add(temp.val);
        }
        res.add(cur);
    }
    return res;
}

```


<br>
<br>

###103 Binary Tree Zigzag Level Order Traversal

>Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).


<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]

</pre>


**Idea**: Maintain a boolean variable to help indicate the add direction of the zigzag. Two cases based on this boolean variable, add at the end or add at index 0;


**Solution**:


```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    boolean zig = true;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            if (zig) {
                cur.add(temp.val);
            } else {
                cur.add(0, temp.val);
            }
        }
        res.add(cur);
        zig = !zig;
    }
    return res;
}
```
<br>
<br>

###104 Maximum Depth of Binary Tree


**Idea**:

- 1) solution 1: recursive, max depth of root = max(max depth of left child, max depth of right child) + 1

- 2) the levels of the binary search tree is its max depth

**Solution 1**: recursive

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

**Solution 2**: iterative

```java
public int maxDepth(TreeNode root){
    if(root == null) {
        return 0;
    }
    int level = 0;
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
        }
        level++;
    }
    return level;
    }
```
<br>
<br>

###105 Construct Binary Tree from Preorder and Inorder Traversal

>Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.



**Idea**: 

**Solution 1**:

- 1) in preorder, the first element is root, then left subtree, right subtree

- 2) in inorder, left subtree, root, right subtree. 

Thus we can use this index to recursively build the binary search tree. 

**Time complexity**:

T(n) = 2 T(n/2) + O(n). Solve it we get T(n) = O(nlgn)

**Solution 2**:

If we use a map to store the value and index relation of inorder array, we can get a better time complexity:

**Time** :

T(n) = 2 T(n/2) + 1. Solve it we get T(n) = O(n)


**Solution 1 code **:

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
}

public TreeNode buildTree(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd) {
    if (pStart > pEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pStart]);
    int rootIndex = 0;
    for (int i = iStart; i <= iEnd; i++) {
        if (preorder[pStart] == inorder[i]) {
            rootIndex = i;
            break;
        }
    }
    int leftLen = rootIndex - iStart;
    root.left  = buildTree(preorder, pStart + 1, pStart + leftLen, inorder, iStart, rootIndex - 1);
    root.right = buildTree(preorder, pStart + leftLen + 1, pEnd, inorder, rootIndex + 1, iEnd);
    return root;
}
```

<br>


**Solution 2 code**:

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || preorder.length == 0) {
        return null;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
}

public TreeNode buildTree(int[] preorder, int pStart, int pEnd, int[] inorder, int iStart, int iEnd, Map<Integer, Integer> map) {
    if (pStart > pEnd) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pStart]);
    int rootIndex = map.get(preorder[pStart]);
    int leftLen = rootIndex - iStart;
    root.left  = buildTree(preorder, pStart + 1, pStart + leftLen, inorder, iStart, rootIndex - 1, map);
    root.right = buildTree(preorder, pStart + leftLen + 1, pEnd, inorder, rootIndex + 1, iEnd, map);
    return root;
}
```



<br>

**Related**:Reconstruct Binary Tree With Levelorder And Inorder

**Time complexity**: if tree is balanced O(nlogn), otherwise, O(n ^ 2)

```java
  public TreeNode reconstruct(int[] in, int[] level) {
    if (in == null || in.length == 0 || level == null || level.length == 0) {
      return null;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < in.length; i++) {
      map.put(in[i], i);
    }
    return reconstruct(in, 0, in.length - 1, level, map);
  }
  private TreeNode reconstruct(int[] in, int inl, int inr, int[] level, Map<Integer, Integer> map) {
    if (inl > inr) {
      return null;
    }
    TreeNode root = new TreeNode(level[0]);
    int rootIndex = map.get(level[0]);
    int[] levelLeft = new int[rootIndex - inl];
    int[] levelRight = new int[inr - rootIndex];
    Map<Integer, Integer> leftMap = new HashMap<Integer, Integer>();
    for (int i = inl; i < rootIndex; i++) {
      leftMap.put(in[i], i);
    }
    int indexLeft = 0;
    int indexRight = 0;
    for (int i = 1; i < level.length; i++) {
      if (leftMap.containsKey(level[i])) {
        levelLeft[indexLeft++] = level[i];
      } else {
        levelRight[indexRight++] = level[i];
      }
    }
    root.left = reconstruct(in, inl, rootIndex - 1, levelLeft, map);
    root.right = reconstruct(in, rootIndex + 1, inr, levelRight, map);
    return root;
  }
```

<br>

**Related**: Reconstruct Binary Search Tree With Postorder Traversal

```java
public TreeNode reconstruct(int[] post) {
  if (post == null || post.length == 0) {
      return null;
  }
  return reconstruct(post, 0, post.length - 1);
}

public TreeNode reconstruct(int[] post, int l, int r) {
  if (l < 0 || r < 0 || l > r) {
      return null;
  }
  TreeNode root = new TreeNode(post[r]);
  int index = findIndex(post, l, r);
  root.left = reconstruct(post, l, index);
  root.right = reconstruct(post, index + 1, r - 1);
  return root;
}

private int findIndex(int[] post, int l, int r) {
  int root = post[r];
  int index = r - 1;
  while (index >= l && post[index] > root) {
      index--;
  }
  return index;
}
```

<br>
<br>

###106 Construct Binary Tree from Inorder and Postorder Traversal

>Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.



**Idea**: Here is the O(n) solution use hashmap, if you want a O(nlgn) solution, you can refer to 105 Construct Binary Tree from Preorder and Inorder Traversal.

For inorder: left subtree | root | right subtree
For postorder: left subtree | right subtree | root

Thus we can use the index relation to recursively build the tree. s

**Solution**:

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (inorder.length == 0) {
        return null;
    }
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, map);
}
public TreeNode buildTree(int[] inorder, int iStart, int iEnd, int[] postorder, int pStart, int pEnd, Map<Integer, Integer> map) {
    if (iStart > iEnd) {
        return null;
    }
    TreeNode root = new TreeNode(postorder[pEnd]);
    int rootIndex = map.get(postorder[pEnd]);
    root.left = buildTree(inorder, iStart, rootIndex - 1, postorder, pStart, pStart + (rootIndex - 1 - iStart), map);
    root.right = buildTree(inorder, rootIndex + 1, iEnd, postorder, pStart + (rootIndex - iStart), pEnd - 1, map);
    return root;
}
```

<br>
<br>

###107 Binary Tree Level Order Traversal II

>Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

<pre>
For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
</pre>

**Idea**: The solution below is same with 102  Binary Tree Level Order Traversal. The only difference is that when insert into list of list, we insert at index 0. Is there any other better solution other than the this method and recursion version of level order traverse? 


**BFS Solution**:

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> cur = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode temp = queue.poll();
            if (temp.left != null) {
                queue.offer(temp.left);
            }
            if (temp.right != null) {
                queue.offer(temp.right);
            }
            cur.add(temp.val);
        }
        res.add(0, cur);
    }
    return res;
}
```


**DFS solution**:

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    levelOrder(res, 0, root);
    return res;
}
private void levelOrder(List<List<Integer>> res, int level, TreeNode root) {
    if (root == null) {
        return;
    }
    if (res.size() < level + 1) {
        res.add(0, new ArrayList<Integer>());
    }
    res.get(res.size() - (level + 1)).add(root.val);
    levelOrder(res, level + 1, root.left);
    levelOrder(res, level + 1, root.right);
}
```


<br>
<br>


    
###108 Convert Sorted Array to Binary Search Tree  

>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

Top down.

Just find the mid of the list each time and create the tree from root.

root = mid

root.left = mid of (0, mid -1)

root.right = mid of (mid + 1, end)

**Time: O(n)**, because we need to traverse all the nodes. 

**Space** O(lg(n)) for recursion. 
```java

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }
    
    public TreeNode sortedArrayToBST(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = start + (end - start) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(nums, start, mid - 1);
        root.right = sortedArrayToBST(nums, mid + 1, end);
        return root;
    }
```


<br>
<br>
 
###109 Convert Sorted List to Binary Search Tree
>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

**Idea**: 

1) solution1: Bottom-up

The list is sorted and we need to convert it to a **balanced BST**. When visit the linkedlist, we can only visit node by node. Thus we visit the nodes in ascending order: **Inorder Traversal !**. Thus, we create the binary tree **Bottom-up**. The bottom-up approach enables us to access the list in its order while creating nodes.

**Time O(n)**

**Space**: O(n) + O(lgn) = O(n)


2) solution2 : Top-down

Just find the mid of the list each time and create the tree from root.
root = mid
root.left = mid of (0, mid -1)
root.right = mid of (mid + 1, end)

**Time: O(nlgn)**  T(n) = 2 * T(n/2) + O(n). Solve it we get T(n) = O(nlgn)

**Space**: O(n) + O(lgn) = O(n)

3) solution3: 

Store all the nodes in an array, then use the array to create the BST. just like the method in  * [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree). However, not recommend this method. If we do in this way, then this question is meaningless. 

**Time: O(n)**

**Space**: O(n) + O(lgn) = O(n)

*Solution1 code:*

<br>
```java
public TreeNode sortedListToBST(ListNode head) {
    if (head == null) {
        return null;
    }
    int len = 0;
    ListNode temp = head;
    while (temp != null) {
        temp = temp.next;
        len++;
    }
    ListNode[] h = new ListNode[1];
    h[0] = head;
    return sortedListToBST(h, 0, len - 1);
}

public TreeNode sortedListToBST(ListNode[] h, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode left = sortedListToBST(h, start, mid - 1);
    TreeNode root = new TreeNode(h[0].val);
    h[0] = h[0].next;
    root.left = left;
    root.right = sortedListToBST(h, mid + 1, end);
    return root;
}
	 
```		 
*solution 2 code*

```java
public TreeNode sortedListToBST(ListNode head) {
    if(head == null) {
        return null;
    }
    if(head.next == null) {
        return new TreeNode(head.val);
    }
    ListNode pre = getMidPre(head);
    ListNode mid = pre.next;
    pre.next = null;
    TreeNode root= new TreeNode(mid.val);
    root.left = sortedListToBST(head);
    root.right = sortedListToBST(mid.next);
    return root;
 }
 
 public ListNode getMidPre(ListNode head) {
    ListNode fast = head;  
    ListNode pre = head;  
    while (fast!=null) {  
        fast = fast.next;  
        if (fast != null) {
            fast = fast.next;  
            pre = head;  
            head = head.next;  
        } 
    }  
    return pre;  
 }

```			 	 


<br>
<br>

###110 Balanced Binary Tree

>Given a binary tree, determine if it is height-balanced.

>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

**Idea**: Check the height diffrence of  subtrees. If difference greater than 1, return false

**Solution 1** : time O(nlgn)

**Time analysis**: 

- 1) master theory: getHeight complexity is O(n), thus T(n) = 2T(n/2) + n. Solve it we get T = O(nlgn)
- 2) recursion tree: O(n) + O(n) ......., lgn layers. Thus the total time is nlgn

```java
  public boolean isBalanced(TreeNode root) {
    // Write your solution here.
    if (root == null) {
      return true;
    }
    if (Math.abs(getHeight(root.left) - getHeight(root.right)) > 1) {
      return false;
    }
    return isBalanced(root.left) && isBalanced(root.right);
  }
  
  public int getHeight(TreeNode root) {
    if (root == null) {
      return 0;
    }
    return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
  }
```
<br>
**Solution 2**: time : O(n)

In this method, we omit repeated getheight part. Thus the time is better than the fist solution

**Time analysis**: 

- 1) master theory: thus T(n) = 2T(n/2) + 1. Solve it we get T = O(n)
- 2) recursion tree: 2 ^ lgn  = O(n)


```java
    public boolean isBalanced(TreeNode root) {
        return validHeight(root) >= 0;
    }
    private int validHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = validHeight(root.left);
        int right = validHeight(root.right);
        if (left < 0 || right < 0 || Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    } 
```
<br>
<br>

###111 Minimum Depth of Binary Tree

>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

**Idea**: The * [104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree) let us to calculate the max depth of the binary tree. 

Thus max depth = Math.max(maxDepth(root.left), maxDepth(root.left)) + 1

In this problem, we need to calculate the minumum depth. Is the minimum depth = Math.min(minDepth(root.left), minDepth(root.left)) + 1.

This is partly true. When the left child and right child all exist, this is true. What if only left child or right child exist? 

In these two cases:

min depth = minDepth(root.left) + 1 when right child does not exist

min depth = minDepth(root.right) + 1 when left child does not exist


**Solution**:


```java
public int minDepth(TreeNode root) {
    if (root == null) {
      return 0;
    }
    if (root.left == null) {
        return minDepth(root.right) + 1;
    }
    if (root.right == null) {
        return minDepth(root.left) + 1;
    }
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
```

<br>
<br>

###112 Path Sum

>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

<pre>
For example:
Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

**Idea**: Recursion.

</pre>

```java
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.val == sum && root.left == null && root.right == null) {
            return true;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }

```
<br>
<br>

###113 Path Sum II

> Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

<pre>
For example:
Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return
[
   [5,4,11,2],
   [5,8,4,5]
]
</pre>

**Same idea with Path Sum. Except that we need to record all the paths.

```java
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        path(root, sum, res, new ArrayList<Integer>());
        return res;
    }
    private void path(TreeNode root, int sum, List<List<Integer>> res, List<Integer> cur) {
        if (root == null) {
            return;
        }
        cur.add(root.val);
        sum -= root.val;
        if (sum == 0 && root.left == null && root.right == null) {
            res.add(new ArrayList<Integer>(cur));
            return;
        }
        path(root.left, sum, res, cur);
        if (root.left != null) {
            cur.remove(cur.size() - 1);
        }
        path(root.right, sum, res, cur);
        if (root.right != null) {
            cur.remove(cur.size() - 1);
        }
    }

```
<br>
<br>

###114 Flatten Binary Tree to Linked List
>Given a binary tree, flatten it to a linked list **in-place**.

<pre>
For example,
Given

         1
        / \
       2   5
      / \   \
     3   4   6
The flattened tree should look like:
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6

</pre>


**Idea**: From the structure of the original tree and result tree, we know that we need to traverse the tree preorder. We can solve it recursively or use a stack to record the right child. 

**Attention**: 

- 1) we can use a fake node pre so that each time we can add the current node to the right of pre, set pre.left = null and recursively solve this problem. 

- 2) We need to save the right child, because the right child has changed when we visit the left child. 

*Reversion code && Preorder* : 

```java
public void flatten(TreeNode root){
    if (root == null) {
        return;
    }
    TreeNode[] pre = new TreeNode[1];
    pre[0] = new TreeNode(-1);
    flatten(root, pre);
}

private void flatten(TreeNode root, TreeNode[] pre) {
    if (root == null) {
        return;
    }
    TreeNode right = root.right;
    pre[0].left = null;
    pre[0].right = root;
    pre[0] = root;
    flatten(root.left, pre);
    flatten(right, pre);
}
```

*Recursion && Postorder*:

```java
public void flatten(TreeNode root){
    TreeNode[] pre = new TreeNode[1];
    pre[0] = null;
    flatten(root, pre);
}

private void flatten(TreeNode root, TreeNode[] pre) {
    if (root == null) {
        return;
    }
    flatten(root.right, pre);
    flatten(root.left, pre);
    root.right = pre[0];
    root.left = null;
    pre[0] = root;
}
```

*Stack && Preorder*: 

```java
public void flatten(TreeNode root){
   if (root == null) {
       return;
   }
   TreeNode pre = new TreeNode(-1);
   Stack<TreeNode> stack = new Stack<TreeNode>();
   while (!stack.isEmpty() || root != null) {
       if (root != null) {
           pre.right = root;
           pre.left = null;
           pre = root;
           stack.push(root.right);
           root = root.left;
       } else {
           root = stack.pop();
       }
   }
}


```



<br>
<br>

###115 Distinct Subsequences

>Given a string S and a string T, count the number of distinct subsequences of T in S.

>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

>Here is an example: S = "rabbbit", T = "rabbit" Return 3.


**DP** Two dimensional:

dp[i][j] represents the number of distinct subsequences of T[0, j] in S[0, i]

Induction rule: dp[i][j] = s.charAt(i - 1) == t.charAt(j - 1) ? dp[i - 1][j - 1] + dp[i - 1][j] :  dp[i - 1][j];

```java
 public int numDistinct(String s, String t) {
      int[][] dp = new int[s.length() + 1][t.length() + 1];
      for (int i = 0; i <= s.length(); i++) {
          for (int j = 0; j <= t.length(); j++) {
              if (j == 0) {
                  dp[i][j] = 1;
              } else if (i == 0) {
                  continue;
              } else {
                   dp[i][j] = s.charAt(i - 1) == t.charAt(j - 1) ? dp[i - 1][j - 1] + dp[i - 1][j] :  dp[i - 1][j];
              }
          }
      }
      return dp[s.length()][t.length()];
  }

```

**One dimensional dp**:

```java
public int numDistinct(String s, String t) {
    int[] dp = new int[t.length() + 1];
    dp[0] = 1;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = t.length(); j >= 1; j--) {
            dp[j] = s.charAt(i - 1) == t.charAt(j - 1) ? dp[j - 1] + dp[j] : dp[j];
        }
    }
    return dp[t.length()];
}
```
<br>
<br>

###116 Populating Next Right Pointers in Each Node

>Given a binary tree

<pre>
    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
For example,
Given the following perfect binary tree,
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL

</pre>

**Idea**: Binary tree level order traversal. Here we need to use constant space, thus we can not use queen. 

We can use the LinkNode to reach the same result.

```java
public void connect(TreeLinkNode root) {
    while (root != null) {
        TreeLinkNode nextList = new TreeLinkNode(-1);
        TreeLinkNode temp = nextList;
        while (root != null) {
            if (root.left != null) {
                temp.next = root.left;
                temp = temp.next;
            } 
            if (root.right != null) {
                temp.next = root.right;
                temp = temp.next;
            }
            root = root.next;
        }
        root = nextList.next;
    }
}
```

<br>
<br>

###117 Populating Next Right Pointers in Each Node II

>Follow up for problem "Populating Next Right Pointers in Each Node".

<pre>

What if the given tree could be any binary tree? Would your previous solution still work?

Note:

You may only use constant extra space.
For example,
Given the following binary tree,
         1
       /  \
      2    3
     / \    \
    4   5    7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL

</pre>

**Same solution with last problem**:


```java
 public void connect(TreeLinkNode root) {
        while (root != null) {
            TreeLinkNode nextList = new TreeLinkNode(-1);
            TreeLinkNode temp = nextList;
            while (root != null) {
                if (root.left != null) {
                    temp.next = root.left;
                    temp = temp.next;
                } 
                if (root.right != null) {
                    temp.next = root.right;
                    temp = temp.next;
                }
                root = root.next;
            }
            root = nextList.next;
        }
    }

```

<br>
<br>

###118 Pascal Triangle

>Given numRows, generate the first numRows of Pascal's triangle.

<pre>
For example, given numRows = 5,
Return

[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

</pre>


**Idea**: First row : 1. Then each row is calculated based on the last row. In each row the first element and the last element is 1. Thus val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);

```java
            public List<List<Integer>> generate(int numRows) {
	        List<List<Integer>> list = new ArrayList<List<Integer>>();
	        if(numRows <= 0) return list;
	        List<Integer> firstR = new ArrayList<Integer>();
	        firstR.add(1);
	        list.add(firstR);
	        for(int i = 1; i < numRows; i++){
	            List<Integer> current = new ArrayList<Integer>();
	            List<Integer> pre = list.get(list.size()-1);
	            for(int j = 0; j <= pre.size(); j++){
	                int val = j == 0 || j == pre.size() ? 1 : pre.get(j-1)+pre.get(j);
	                current.add(val);
	            }
	            list.add(current);
	        }
	        return list;
	    }
	    

```


<br>
<br>




###119 Pascal Triangle II

>Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?

**Revised solution**: overwrite from the last second element to the second element. In this way, we don't need to store any previous value.

```java
public List<Integer> getRow(int rowIndex) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    for(int i = 1; i <= rowIndex; i++){
        list.add(1);
        for(int j = list.size() - 2; j > 0; j--){
            list.set(j, list.get(j) + list.get(j - 1));
        } 
    }
    return list;
}

```

**Idea**: If we can only use O(k) space, then we need to store all rows info in a single array. So the current row is calculated based on the last row. Eg: the last row is 1 2 1, we need to replace it with 1 3 3 1. We can ignore the first 1. Then 3 = 1 + 2 = pre + list.get(j). We need to store the current elment before we overwrite it. 

If there is no other requirements, then we can just use the result in [118 Pascal Triangle](#118-pascal-triangle) and get the last row. 

**Attention**:

- 1) k = 3, we return the fourth row.
- 2) we need to store the current elment before we overwrite it. 

<br>

```java
public List<Integer> getRow(int rowIndex) {
	List<Integer> list = new ArrayList<Integer>();
    	if(rowIndex < 0) return list;
    	list.add(1);
    	for(int i = 0; i < rowIndex; i++){
    	    int pre = 1;
    	    int current = 0;
    	    for(int j = 0; j < list.size(); j++){
    	        if(j == 0) continue;
    	        current = list.get(j);
    	        list.set(j, pre + list.get(j));
    	        pre = current;
    	    } 
    	    list.add(1);
    	}
        return list;
	}

```


<br>
<br>

###120 Triangle

>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

<pre>
For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
</pre>

**Idea**: Begin from the second-last layer, calculate the min sum of the last layer and last second layer, then continue the second-last layer and third-last layer....eg: the sum of last layer and last-second layer: min(4, 1) + 6, min(1, 8) + 5, min(8, 3) + 7. If we are only allowed to use O(n) space, then we need to replace the sum each time.

For example: Assume we use int[] res = new int[triangle.get(triangle.size()-1).size()] to store the sum

<pre>

Original triangle:             

[							   
     [2],					   
    [3,4],					  
   [6,5,7],					   
  [4,1,8,3]                  
] 


res array:
11
9, 10
7, 6, 10
4, 1, 8, 3

</pre>

**Space**: O(n)


We can also calculate from the top layer, then go down. It's similar to the method above. It's easier to handle the index if we begin from the last layer.

```java
public int minimumTotal(List<List<Integer>> triangle) {
    List<Integer> res = triangle.get(triangle.size() - 1);
    for(int i = triangle.size()-2; i >= 0; i--){
        List<Integer> current = triangle.get(i);
        for(int j = 0; j < current.size(); j++){
            res.set(j, Math.min(res.get(j), res.get(j + 1)) + current.get(j));
        }
    }
    return res.get(0);
}
```

**Solution 2**: From top to bottom:

```java
	/* from top to bottom */
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle.size() == 0) {
            return 0;
        }
        List<Integer> res = new ArrayList<>();
        res.add(triangle.get(0).get(0));
        for (int i = 1; i < triangle.size(); i++) {
            List<Integer> cur = triangle.get(i);
            res.add(cur.get(cur.size() - 1) + res.get(res.size() - 1));
            for (int j = cur.size() - 2; j >= 1; j--) {
                res.set(j, Math.min(res.get(j), res.get(j - 1)) + cur.get(j));
            }
            res.set(0, res.get(0) + cur.get(0));
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < res.size(); i++) {
            min = Math.min(min, res.get(i));
        }
        return min;
    }
```



<br>
<br>

###121 Best Time to Buy and Sell Stock
>Say you have an array for which the ith element is the price of a given stock on day i.

> If you were only permitted to complete **at most one transaction** (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

**Idea:** We are allowed at most one transaction. Thus we only need to maintain a local  min stock price before prices[i]. Traverse prices one pass to get the max profit.

**max = Math.max(max, prices[i] - min)** 

**min = Math.min(min, prices[i])**

**Time complexity**: O(n)
 
**Space** : O(1)

```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length == 0) return 0;
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
		}
		return max;
	}
```



	
<br>
<br>

###122 Best Time to Buy and Sell Stock II

>Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **as many transactions** as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are allowed as many transactions. Thus we only need to each neighbor pair, if prices[i] > prices[i-1], we add the difference to our result. We can get the max one pass. 

**dif = Math.max(0, prices[i] - prices[i-1])** 

**max = max + dif** 

**Time complexity**: O(n) 

**Space** : O(1)
```java
public int maxProfit(int[] prices) {
    int res = 0;
    for (int i = 1; i < prices.length; i++) {
        res = res + Math.max(0, prices[i] - prices[i - 1]);
    }
    return res;
}
```	

<br>
<br>

###123 Best Time to Buy and Sell Stock III

>Say you have an array for which the ith element is the price of a given stock on day i. 
> 
>Design an algorithm to find the maximum profit. You may complete **at most two transactions**.

>Note:
>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Idea:** We are only allowed  at most two transactions. Thus, we can use two arrays to record the max profit before profits[i], including i, denote as l[i], and max profits after profits[i], including i, denote as r[i]. Then find the max of l[i] + r[i]. 

**Time complexity**: O(n) 

**Space** : O(n)
```java
	public int maxProfit(int[] prices){
		if(prices == null || prices.length <= 1) return 0;
		int[] l = new int[prices.length];
		int[] r = new int[prices.length];
		int max = 0;
		int min = prices[0];
		for(int i = 1; i < prices.length; i++){
			max = Math.max(max, prices[i] - min);
			min = Math.min(min, prices[i]);
			l[i] = max;
		}
		int maxR = prices[prices.length-1];
		max = 0;
		for(int i = prices.length - 2; i >= 0; i--){
			max = Math.max(max, maxR - prices[i]);
			maxR = Math.max(maxR, prices[i]);
			r[i] = max;
		}
		max = 0;
		for(int i = 0; i < prices.length; i++){
			max = Math.max(max, l[i] + r[i]);
		}
		return max;
	}
```	
**Another solution:** 

global[i][j]: denotes max profit, at most j transactions before day i: 

**global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

From above, we know that we can change the two dimensional array to one dimensional to save space. Because we only use two rows in the two dimensional array. 

**Time complexity**: O(n) 

**Space** : O(1) (O(k), but k is 2 in this problem)
```java
	public int maxProfit1(int[] prices){
		return maxProfit(prices, 2);
	}
	public int maxProfit(int[] prices, int k){
		if(prices == null || prices.length <= 1) return 0;
		int[] global = new int[k+1];
		int[] local = new int[k+1];
		for(int i = 1; i < prices.length; i++){
			int dif = prices[i] - prices[i-1];
			for(int j = k; j >= 1; j--){
				local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
				global[j] = Math.max(local[j], global[j]);
			}
		}
		return global[k];
	}
```


<br>
<br>

###124 Binary Tree Maximum Path Sum

>Given a binary tree, find the maximum path sum.

>The path may start and end at any node in the tree.

<pre>
For example:
Given the below binary tree,

       1
      / \
     2   3
Return 6.

</pre>


**Idea**: In this problem, the path can start and end at any node. Thus we can divide the path into 3 parts: left path, root, right path

In the solution below, we maintain a maxSum, this is same with the general max path problem. And in the recursion part, we calculate the max left path root at a certain node and the max right path at a node, update the maxSum and return the max path of left path part or right path part. 

**Time**:

T(n) = 2T(n/2) + 1. Solve it we get T(n) = O(n)

**Solution**:


```java
public int maxPathSum(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int[] maxSum = new int[1];
    maxSum[0] = root.val;
    maxPathSum(root, maxSum);
    return maxSum[0];
}

public int maxPathSum(TreeNode root, int[] maxSum) {
    if (root == null) {
        return 0;
    }
    int left = Math.max(maxPathSum(root.left, maxSum), 0);
    int right = Math.max(maxPathSum(root.right, maxSum), 0);
    maxSum[0] = Math.max(root.val + left + right, maxSum[0]);
    return root.val + Math.max(left, right);
}
```

<br>

**Related**: max path sum from leaf to leaf


```java
  public int maxPathSum(TreeNode root) {
    if (root == null) {
      return Integer.MIN_VALUE;
    }
    int[] max = new int[1];
    max[0] = Integer.MIN_VALUE;
    maxPathSum(root, max);
    return max[0];
  }
  private int maxPathSum(TreeNode root, int[] max) {
    if (root == null) {
      return 0;
    }
    int left = maxPathSum(root.left, max);
    int right = maxPathSum(root.right, max);
    int temp = left + right + root.key;
    if (temp > max[0] && root.left != null && root.right != null) {
      max[0] = temp;
    }
    if (root.left == null) {
      return right + root.key;
    } else if (root.right == null) {
      return left + root.key;
    } else {
      return Math.max(left, right) + root.key;
    }
  }
```

<br>

**Related**:max path sum from node to node on root to leaf path. Allowed to contain only one node.


```java
  class Sum {
    int val;
    public Sum(int val) {
      this.val = val;
    }
  }
  public int maxPathSum(TreeNode root) {
    if (root == null) {
      return 0;
    }
    Sum sum = new Sum(Integer.MIN_VALUE);
    maxPathSum(root, new ArrayList<Integer>(), sum);
    return sum.val;
  }
  
  private void maxPathSum(TreeNode root, List<Integer> prefixList, Sum sum) {
    if (root == null) {
      return;
    }
    prefixList.add(root.key);
    updateSum(prefixList, sum);
    maxPathSum(root.left, prefixList, sum);
    prefixList.remove(prefixList.size() - 1);
    prefixList.add(root.key);
    maxPathSum(root.right, prefixList, sum);
    prefixList.remove(prefixList.size() - 1);
  }
  
  private void updateSum(List<Integer> prefixList, Sum sum) {
    int num = 0;
    for (int i = prefixList.size() - 1; i >= 0; i--) {
      num += prefixList.get(i);
      sum.val = Math.max(sum.val, num);
    }
  }
```
<br>
<br>

###125 Valid Palindrome

>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

<pre>
For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.
</pre>

```java
public boolean isPalindrome(String s) {
    int l = 0;
    int r = s.length() - 1;
    while (l < r) {
        if (isNotCharacter(s.charAt(l))) {
            l++;
        } else if (isNotCharacter(s.charAt(r))) {
            r--;
        } else {
            if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) {
                l++;
                r--;
            } else {
                return false;
            }
        }
    }
    return true;
}
private boolean isNotCharacter(char c) {
    return ! ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'));
}

```
<br>
<br>

###126 Word Ladder

>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:


Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:

start = "hit"

end = "cog"

dict = ["hot","dot","dog","lot","log"]

As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",

return its length 5.

Note:

Return 0 if there is no such transformation sequence.

All words have the same length.

All words contain **only lowercase alphabetic characters**.




**Idea**: This shortest transformation ladder is just like a shortest path in a graph. We treat each string as a graph node. If these two strings only have one different char, then we add an edge to these two nodes. When we come to the end string, we find the shortest path. 

If we use bfs, we can use an additional len queue to record the path length of each node. 


**Attention**: 

- 1)Everytime, we visit a string in dict and add an edge, we need to remove it from dict. 
- 2) char arr = start.toCharArray() should be inside the first for while loop. Otherwise, it may change more than one character of the string. 



**Solution**:
```java
	public static int ladderLength(String start, String end, Set<String> dict) {
	        if(dict == null || dict.size() == 0 || start == null || end == null) return 0;
	        Deque<String> queue = new LinkedList<String>();
	        Deque<Integer> qlen = new LinkedList<Integer>();
	        queue.offer(start);
	        qlen.offer(1);
	        while(!queue.isEmpty()){
	            start = queue.pollFirst();
	            int len = qlen.pollFirst();
	            if(start.equals(end)) return len;
	            for(int i = 0; i < start.length(); i++){
	                char[] arr = start.toCharArray();
	                for(arr[i] = 'a'; arr[i] <='z'; arr[i]++){
	                    String s = new String(arr);
	                    if(dict.contains(s)){
	                        queue.addLast(s);
	                        qlen.addLast(len+1);
	                        dict.remove(s);
	                    }
	                }
	            }
	        }
	        return 0;
	    }
    
```

**Another BFS solution**:

Space O(n)

```java
public int ladderLength(String start, String end, Set<String> dict) {
        Deque<String> queue = new LinkedList<>();
        queue.add(start);
        dict.add(end);
        int res = 0;
        while (!queue.isEmpty()) {
            res++;
            int size = queue.size();
            for (int j = 0; j < size; j++) {
                start = queue.poll();
                if (start.equals(end)) {
                    return res;
                }
                for (int i = 0; i < start.length(); i++) {
                    char[] arr = start.toCharArray();
                    for (arr[i] = 'a'; arr[i] <= 'z'; arr[i]++) {
                        String temp = new String(arr);
                        if (dict.contains(temp)) {
                            queue.add(temp);
                            dict.remove(temp);
                        }
                    }
                }
                
            }
        }
        return 0;
    }
```

<br>
<br>

###127 Word Ladder II

>Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:

<pre>
Only one letter can be changed at a time
Each intermediate word must exist in the dictionary
For example,

Given:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.
</pre>


<br>
<span style="background-color:#303030 ">


**Idea**: Becuase we need to output all the shortest paths, thus we need to record the parent node in the path. Then build paths based on these parent nodes.

**Attention**:

- 1) we need to remove end from dict if dict contains end, otherwise, we might have duplicates.
- 2) When we find all the path to end, we can break and rebuild the paths.
- 3) We can not remove element immediately when we find an neighbors in dict, because one node might have two or more parents. Thus we need to remove it after we have build the relationships between the node and all its parents. *We can remove it at the beginning of the next while loop*
- 4) when add element to queue, check if queue has alreay contains this element.

</span>


```java
      public List<List<String>> findLadders(String start, String end, Set<String> dict) {
          List<List<String>> res = new ArrayList<>();
          Deque<String> queue = new LinkedList<>();
          Map<String, Set<String>> parentMap = new HashMap<>();
          parentMap.put(end, new HashSet<String>());
          queue.add(start);
          dict.add(end);
          String saveStart = start;
          while (!queue.isEmpty()) {
              List<String> toRemove = new LinkedList<>();
              int size = queue.size();
              for (int j = 0; j < size; j++) {
                  start = queue.poll();
                  for (int i = 0; i < start.length(); i++) {
                      char[] arr = start.toCharArray();
                      for (arr[i] = 'a'; arr[i] <= 'z'; arr[i]++) {
                          String temp = new String(arr);
                          if (dict.contains(temp)) {
                              if (!parentMap.containsKey(temp)) {
                                  parentMap.put(temp, new HashSet<String>());
                              }
                              parentMap.get(temp).add(start);
                              queue.add(temp);
                              toRemove.add(temp);
                          }
                      }
                  }
              }
              if (parentMap.get(end).size() > 0) {
                  break;
              }
              for (String string : toRemove) {
                  dict.remove(string);
              }
          }
          List<String> curPath = new ArrayList<>();
          curPath.add(end);
          buildPaths(parentMap, res, end, saveStart, curPath);
          return res;
      }
      
      private void buildPaths(Map<String, Set<String>> parentMap, List<List<String>> res, String end, String start, List<String> path) {
          if (end.equals(start)) {
              List<String> p = new ArrayList<>(path);
              Collections.reverse(p);
              res.add(p);
              return;
          }
          Set<String> parent = parentMap.get(end);
          for (String s : parent) {
              path.add(s);
              buildPaths(parentMap, res, s, start, path);
              path.remove(path.size() - 1);
          }
      }
```

<br>

**Another similar solution:**: 


```java
  public List<List<String>> findLadders(String start, String end, Set<String> dict) {
        List<List<String>> res = new ArrayList<>();
        Queue<String> queue = new LinkedList<String> ();
        Map<String, ArrayList<String>> map = new HashMap<>();
        queue.offer(start);
        for (String s : dict) {
            map.put(s, new ArrayList<String>());
        }
        map.put(end, new ArrayList<String>());
        List<String> cur = new ArrayList<>();
        
        while(!queue.isEmpty()){
            cur.clear();
            for (int i = 0, size = queue.size(); i < size; i++) {
              String temp = queue.poll();
                cur.add(temp);
                dict.remove(temp);
            }
            for (String s : cur){
                for (int i = 0; i < s.length(); i++) {
                    char[] arr = s.toCharArray();
                    for (arr[i] = 'a'; arr[i] <= 'z'; arr[i]++) {
                        String temp = new String(arr);
                        if (dict.contains(temp)) {
                            if (!map.containsKey(temp)) {
                                map.put(temp, new ArrayList<String>());
                            }
                            map.get(temp).add(s);
                            if (!queue.contains(temp)) {
                                queue.offer(temp);
                            }
                        }
                    }
                }
            }
            
            if (map.get(end).size()>0) {
                break;
            }
        }
        
        List<String> path = new ArrayList<String>();
        path.add(end);
        buildPaths(map, res, end, start, path);
        return res;
  }
  
  public void buildPaths(Map<String, ArrayList<String>> map, List<List<String>> res, String end, String start, List<String> path){
      if (end.equals(start)) {
          List<String> apath = new ArrayList<>(path);
          Collections.reverse(apath);
          res.add(apath);
          return;
      }
      List<String> pre = map.get(end);
      for (String s : pre) {
          path.add(s);
          buildPaths(map, res, s, start, path);
          path.remove(path.size() - 1);
      }
  }
 	
```



<br>
<br>

###128 Longest Consecutive Sequence

>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.


<pre>
For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

</pre>

**Idea**: Use set to check if an element exist in O(1) time.

Pick an element, go to the left and right consecutive as far as possible. For each consecutive sequence we check once.

http://blog.csdn.net/linhuanmars/article/details/22964467



```java
  public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for (int i : nums) {
            set.add(i);
        }
        int res = 0;
        while (!set.isEmpty()) {
            int len = 1;
            Iterator<Integer> iterator = set.iterator();
            int cur = iterator.next();
            set.remove(cur);
            int left = cur - 1;
            while (set.contains(left)) {
                set.remove(left--);
                len++;
            }
            int right = cur + 1;
            while (set.contains(right)) {
                set.remove(right++);
                len++;
            }
            res = Math.max(len, res);
        }
        return res;
    }

```

**Another solution based on leetcode discussion**:

```java
public int longestConsecutive(int[] nums) {
  Map<Integer, Integer> map = new HashMap<>();
  int res = 0;
  for (int num : nums) {
      if (!map.containsKey(num)) {
          int l = map.containsKey(num - 1) ? map.get(num - 1) : 0;
          int r = map.containsKey(num + 1) ? map.get(num + 1) : 0;
          int count = l + r + 1;
          map.put(num, count);
          res = Math.max(res, count);
          map.put(num - l, count);
          map.put(num + r, count);
      }
  }
  return res;
}

```


<br>
<br>


###129 Sum Root to Leaf Numbers


>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

<pre>
An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = 12 + 13 = 25.

</pre>

```java
    public int sumNumbers(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int[] res = new int[1];
        sumPath(res, root, 0);
        return res[0];        
    }
    private void sumPath(int[] res, TreeNode root, int cur) {
        if (root == null) {
            return;
        }
        cur = cur * 10 + root.val;
        if (root.left == null && root.right == null) {
            res[0] += cur;
            return;
        }
        sumPath(res, root.left, cur);
        sumPath(res, root.right, cur);
    }

```

Or

```java
public int sumNumbers(TreeNode root) {
    return sumPath(root, 0);
}
private int sumPath(TreeNode root, int cur) {
    if (root == null) {
        return 0;
    }
    cur = cur * 10 + root.val;
    if (root.left == null && root.right == null) {
        return cur;
    }
    return sumPath(root.left, cur) + sumPath(root.right, cur);
}
```

<br>
<br>


###130 Surrounded Regions

>Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

For example,
X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X

**Idea**:

Change all unsurrounded 'O' to other character, then fill surrounded 'O' with 'X'. Then change unsurrounded '0' back.


```java
public void solve(char[][] board) {
        if (board == null || board.length == 0 || board[0].length == 0) {
            return;
        }
        for (int i = 0; i < board.length; i++) {
            flood(board, i, 0);
            flood(board, i, board[0].length - 1);
        }
        for (int i = 0; i < board[0].length; i++) {
            flood(board, 0, i);
            flood(board, board.length - 1, i);
        }
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                }
            }
        }
    }
    
    private void flood(char[][] board, int i, int j) {
        if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1 || board[i][j] != 'O') {
            return;
        }
        board[i][j] = 'A';
        if (i > 1) {
            flood(board, i - 1, j);
        }
        if (i < board.length - 2) {
            flood(board, i + 1, j);
        }
        if (j > 1) {
            flood(board, i, j - 1); 
        }
        if (j < board[0].length - 2) {
            flood(board, i, j + 1);
        }
    }
```

<br>

The more concise version of flood is following, but will get TLE on leetcode. This takes O(4 ^ n) for the flood.

```java
    private void flood(char[][] board, int i, int j) {
        if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1 || board[i][j] != 'O') {
            return;
        }
        board[i][j] = 'A';
        flood(board, i - 1, j);
        flood(board, i + 1, j);
        flood(board, i, j - 1);
        flood(board, i, j + 1);
    }
```


<br>

**Iterative version of flood**: Use iterative way, the flood takes O(m * n)

```java
    private void flood(char[][] board, int i, int j) {
        if (board[i][j] != 'O') {
            return;
        }
        board[i][j] = 'A';
        Deque<Integer> queue = new LinkedList<>();
        queue.offer(i * board[0].length + j);
        while (!queue.isEmpty()) {
            int pos = queue.poll();
            int row = pos / board[0].length;
            int col = pos % board[0].length;
            if (row > 0 && board[row - 1][col] == 'O') {
                queue.offer(pos - board[0].length);
                board[row - 1][col] = 'A';
            }
            if (row < board.length - 1 && board[row + 1][col] == 'O') {
                queue.offer(pos + board[0].length);
                board[row + 1][col] = 'A';
            }
            if (col > 0 && board[row][col - 1] == 'O') {
                queue.offer(pos - 1);
                board[row][col - 1] = 'A';
            }
            if (col < board[0].length - 1 && board[row][col + 1] == 'O') {
                queue.offer(pos + 1);
                board[row][col + 1] = 'A';
            }
        }
    }
``` 

<br>
<br>


###131 Parlindrome partitioning

>Given a string s, partition s such that every substring of the partition is a palindrome.

>Return all possible palindrome partitioning of s.

<pre>
For example, given s = "aab",
Return

  [
    ["aa","b"],
    ["a","a","b"]
  ]

</pre>

**Idea**:

- Solution 1: Use recursion, each time, add one character, if is palindrome, go to the next recursive level.

- Solution 2: Use dp to pre calculate isPalindrome for each substring i to j, then use the same recursive rule in method 1.

**Time complexity**:

- Solution 1:  worst case. T(n) = (n - 1)T(n - 1) + n * (n - 1), thus time is O(n!)

- Solution 2: T(n) = (n - 1)T(n - 1), time complexity is O(n!) 

**Solution 1**: recursion.

```java
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<List<String>>();
        if (s == null || s.length() == 0) {
            return res;
        }
        partition(s, 0, new ArrayList<String>(), res);
        return res;
    }
    
    private void partition(String s, int start, List<String> cur, List<List<String>> res) {
        if (start == s.length()) {
            res.add(new ArrayList<String>(cur));
            return;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = start; i < s.length(); i++) {
            sb.append(s.charAt(i));
            if (isPalindrome(sb.toString())) {
                cur.add(sb.toString());
                partition(s, i + 1, cur, res);
                cur.remove(cur.size() - 1);
            }
        }
    }
    
    private boolean isPalindrome(String s) {
        if (s.length() == 0 || s.length() == 1) {
            return true;
        }
        for (int i = 0, halfLen = s.length() / 2; i < halfLen; i++) {
            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {
                return false;
            }
        }
        return true;
    }
```

**Solution 2**: dp:

```java
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<List<String>>();
        if (s == null || s.length() == 0) {
            return res;
        }
        partition(s, 0, new ArrayList<String>(), res, getParlindromeArray(s));
        return res;
    }
    
    private void partition(String s, int start, List<String> cur, List<List<String>> res, boolean[][] isP) {
        if (start == s.length()) {
            res.add(new ArrayList<String>(cur));
            return;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = start; i < s.length(); i++) {
            sb.append(s.charAt(i));
            if (isP[start][i]) {
                cur.add(sb.toString());
                partition(s, i + 1, cur, res, isP);
                cur.remove(cur.size() - 1);
            }
        }
    }
    
    private boolean[][] getParlindromeArray(String s) {
        boolean[][] res = new boolean[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || res[j + 1][i - 1])) {
                    res[j][i] = true;
                }
            }
        }
        return res;
    }

```


<br>
<br>


###132 Parlindrome partitioning II

>Given a string s, partition s such that every substring of the partition is a palindrome.

>Return the minimum cuts needed for a palindrome partitioning of s.

>For example, given s = "aab",
>Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.

**Idea**: From Parlindrome partitioning we know how to calcaulate all the possible solutions. If we just need to know the minimum cut numbers, we can use dp to solve the problem.

- *Solution 1*, calculate the isPalindrome[i][j] use dp, which represents if substring(i, j) is parlindrome. Then use dp to calculate the minimum cut.

cut[i] represents the number of cuts to cut the substring(0, i+1) to parlindrome. 

Base case: cut[i] = i, every single character must be parlindrome.

Induction rule: cut[i] = min(cut[i], cut[j - 1] + 1), if substring(j, i + 1) is parlindrome. 

Note if j = 0, and isParlindrome[j][i] = true, then cut[i] = 0


- *Solution 2*: combine the cut[] isParlindrome[][] together, then we only need n ^ 2, other then 2 * (n ^ 2) 

**Solution 1**:

```java
public int minCut(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    boolean[][] isP = getParlindromeArray(s);
    int[] cut = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        cut[i] = i;
        for (int j = 0; j <= i; j++) {
            if (isP[j][i]) {
                if (j > 0) {
                    cut[i] = Math.min(cut[i], cut[j - 1] + 1);
                } else {
                    cut[i] = 0;
                }
            }
        }
    }
    return cut[s.length() - 1];
}
private boolean[][] getParlindromeArray(String s) {
    boolean[][] res = new boolean[s.length()][s.length()];
    for (int i = 0; i < s.length(); i++) {
        for (int j = 0; j <= i; j++) {
            if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || res[j + 1][i - 1])) {
                res[j][i] = true;
            }
        }
    }
    return res;
}

```
<br>
**Solution 2**:

```java
public int minCut(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    boolean[][] isP = new boolean[s.length()][s.length()];
    int[] cut = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        cut[i] = i;
        for (int j = 0; j <= i; j++) {
            if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || isP[j + 1][i - 1])) {
                isP[j][i] = true;
                if (j > 0) {
                    cut[i] = Math.min(cut[i], cut[j - 1] + 1);
                } else {
                    cut[i] = 0;
                }
            }
        }
    }
    return cut[s.length() - 1];
}

```
<br>
<br>

###133 Clone Graph

>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


>OJ's undirected graph serialization:
Nodes are labeled uniquely.

>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

>The graph has a total of three nodes, and therefore contains three parts as separated by #.

>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:

<pre>
       1
      / \
     /   \
    0 --- 2
         / \
         \_/

</pre>

**Idea**: We need a map to record if the node has already been copyed, if it is, then we just need to record the neighbors relationship for it.

**Solution 1**: DFS


```java
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if (node == null) {
            return node;
        }
        UndirectedGraphNode copy = new UndirectedGraphNode(node.label);
        Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
        map.put(node, copy);
        cloneGraph(node, copy, map);
        return copy;
    }
    private void cloneGraph(UndirectedGraphNode node, UndirectedGraphNode copy, Map<UndirectedGraphNode, UndirectedGraphNode> map) {
        if (node == null) {
            return;
        }
        for (UndirectedGraphNode cur : node.neighbors) {
            if (!map.containsKey(cur)) {
                UndirectedGraphNode curCopy = new UndirectedGraphNode(cur.label);
                map.put(cur, curCopy);
                copy.neighbors.add(curCopy);
                cloneGraph(cur, curCopy, map);
            } else {
                 copy.neighbors.add(map.get(cur));
            }
        }
    }
```

**Solution 2**: BFS

```java
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) {
        return null;
    }
    UndirectedGraphNode copy = new UndirectedGraphNode(node.label);
    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
    Queue<UndirectedGraphNode> queue = new LinkedList<>();
    queue.offer(node);
    map.put(node, copy);
    while (!queue.isEmpty()) {
        UndirectedGraphNode cur = queue.poll();
        for (UndirectedGraphNode neib : cur.neighbors) {
            UndirectedGraphNode copyNeib = null;
            if (map.get(neib) == null) {
                copyNeib = new UndirectedGraphNode(neib.label);
                queue.offer(neib);
                map.put(neib, copyNeib);
            } else {
                copyNeib = map.get(neib);
            }
            map.get(cur).neighbors.add(copyNeib);
        }
    }
    return copy;
}

```

<br>
<br>


###134 Gas Station
>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

>Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

>Note:The solution is guaranteed to be unique.

**Brute force, o(n^2)**:

```java
public static int canCompleteCircuit(int[] gas, int[] cost) {
      for (int i = 0, len = cost.length; i < len; i++){
          int remain = gas[i] - cost[i];
        if (remain < 0) {
            continue;
        }
        int j = 0; 
        for (j = i + 1; j < len; j++){
            remain += gas[j] - cost[j];
          if (remain < 0) {
              break;
          }
        }

        if (j != len) {
            continue;
        }
        
        for (j = 0; j < i; j++){
            remain += gas[j] - cost[j];
          if (remain < 0) {
              break;
          }
        }

        if(j == i) {
            return i;
        }
      }
      
        return -1;
    }
```


<br>

**Improve the above solution to O(n) solution**:

When we found at station A, remainGas + gas[A] - cost[A] < 0, we start from A + 1.

Just add one line i = j in the following for loop block:

```java
for (j = i + 1; j < len; j++){
    remain += gas[j] - cost[j];
  if (remain < 0) {
      i = j;
      break;
  }
}
```

```java
 public static int canCompleteCircuit(int[] gas, int[] cost) {
      for (int i = 0, len = cost.length; i < len; i++){
          int remain = gas[i] - cost[i];
        if (remain < 0) {
            continue;
        }
        int j = 0; 
        for (j = i + 1; j < len; j++){
            remain += gas[j] - cost[j];
          if (remain < 0) {
              i = j;
              break;
          }
        }

        if (j != len) {
            continue;
        }
        
        for (j = 0; j < i; j++){
            remain += gas[j] - cost[j];
          if (remain < 0) {
              break;
          }
        }

        if(j == i) {
            return i;
        }
      }
      
        return -1;
    }

```

**Another solution**:

Based on the following two ideas:

1) if car can not reach from A to B, then car not start from A + 1, A + 2....B - 1 to B

2) if sum (gas[i] - cost[i]) >= 0, then there must have a solution.

For details, please look at the following two links.

http://blog.csdn.net/linhuanmars/article/details/22706553

https://leetcode.com/discuss/4159/share-some-of-my-ideas


```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    if (gas == null || cost == null) {
        return -1;
    }
    int total = 0;
    int cur = 0;
    int start = 0;
    for (int i = 0; i < gas.length; i++) {
        total += gas[i] - cost[i];
        cur += gas[i] - cost[i];
        if (cur < 0) {
            cur = 0;
            start = i + 1;
        }
    }
    return total >= 0 ? start : -1;
}
```

<br>

<br>


###135 Candy

> There are N children standing in a line. Each child is assigned a rating value.

> You are giving candies to these children subjected to the following requirements:

> Each child must have at least one candy.

> Children with a higher rating get more candies than their neighbors.

> What is the minimum candies you must give?

**Idea**: 

- 1) Solution1 : Traverse the array two times, left to right and right to left. In the first traverse, we calculate the min candy for each child based on its left neighbor. In the right to left traverse, we calculate the min candy for each child based on its right neighbor. It's easier to use 2 array and traverse three times. We can reduce it to 1 array and 2 pass. 

**Three pass, two array**

```java

 public static int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) return 0;
        int[] left = new int[ratings.length];
        left[0] = 1;
        for(int i = 1; i < ratings.length; i++){
            if(ratings[i] > ratings[i-1]) left[i] = left[i-1] +1;
            else left[i] = 1;
        }
        int[] right = new int[ratings.length];
        right[ratings.length - 1] = 1;
        for(int i = ratings.length - 2; i >= 0; i--){
             if(ratings[i] > ratings[i+1]){
                right[i] = right[i+1] + 1;
            }else right[i] = 1;
        }
        int res = 0;
        for(int i = 0; i < ratings.length; i++){
            res += Math.max(left[i], right[i]);
        }
        return res;
    }

```

<br>

**Two pass, one array**

```java

    public int candy(int[] ratings) {
        if (ratings == null || ratings.length == 0) {
            return 0;
        }
        int[] left = new int[ratings.length];
        left[0] = 1;
        for (int i = 1; i < ratings.length; i++) {
            left[i] = ratings[i] > ratings[i - 1] ? left[i - 1] + 1 : 1;
        }
        int sum = left[left.length - 1];
        for (int i = ratings.length - 2; i >= 0; i--) {
            int right = ratings[i] > ratings[i + 1] ? left[i + 1] + 1 : 1;
            sum += Math.max(left[i], right);
            left[i] = right;
        }
        return sum;
    }

```

<br>
<br>

####136 Single Number

>Given an array of integers, every element appears three times except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Idea**:
If we can use extra memory, we can easily solve it using a hashmap. 

If can not use memory, you need to be aware of "Bit manipulation".

N1 ^ N2 ^ N1 ^ N2 ^ N3 = N3

```java
public int singleNumber(int[] nums) {
    int res = nums[0];
    for (int i = 1; i < nums.length; i++) {
        res ^= nums[i];
    }
    return res;
}
```
<br>
<br>

###137 Single Number II

>Given an array of integers, every element appears three times except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Idea**: Too hard for me. See the following link.

https://leetcode.com/discuss/31595/detailed-explanation-generalization-bitwise-operation-numbers

https://leetcode.com/discuss/43377/the-simplest-solution-ever-with-clear-explanation

Basic idea of the following solution:

Suppose all the numbers are 1 bit. Then we can use sum % 3 to know the single number. We can extend it to 32 bits.


```java

 public static int singleNumber(int[] A) {
        int result = 0;
      int count = 0;
      int pos = 0;
    
      for(int i = 0; i < 32; i++){
        count = 0;
        pos = 1 << i;
        for (int j = 0, len = A.length; j < len; j++) {
          if ((pos & A[j]) != 0) {
              count++;
          }
        }
        if ((count % 3) != 0) {
            result |= pos;
        }
      }
      return result;
    }

```

<br>
<br>


###138 Copy List With Random Pointer

>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.
 

**Idea** :

**Solution1:**Copy each node in the list, then divide the list into two lists. For example: 1->2->3, we copy nodes and the list turns to 1->1->2->2->3->3. Then we divide it into two 1->2->3

**Attention**: ***we should copy the random pointer seperatel after we copy all the nodes***. At the beginning, I thought that I can copy the random pointer at the same time and just let it pointer to the same node with the original node, when breaking the list, I change the copy node's random to origin's random's next. It works only when the node that random pointer points to is after to the current pointer. What if it is before the current node? we might not able to find the random's next because when breaking the list we have changed the structure of the list. 

**Solution2**: Use hashmap store old and copy, then copy the random pointer

***Solution1 code***
```java
    public RandomListNode copyRandomList(RandomListNode head) {
        if(head == null) return null;
        RandomListNode temp = head;
        while(temp != null){
            RandomListNode next = temp.next;
            temp.next = new RandomListNode(temp.label);
            temp.next.next = next;
            temp = next;
        }
        temp = head;
        while(temp != null){
            if(temp.random != null){
                temp.next.random = temp.random.next;
            }
            temp = temp.next.next;
        }
        RandomListNode fakeHead = new RandomListNode(-1);
        RandomListNode copy = fakeHead;
        while(head != null){
            RandomListNode next = head.next.next;
            copy.next = head.next;
            copy = copy.next;
            copy.next = null;
            head.next = next;
            head = next;
        }
        return fakeHead.next;
    }
```    
***Solution2 code***
```java
 	public RandomListNode copyRandomList1(RandomListNode head) {
        if(head == null) return null;
        RandomListNode copy = new RandomListNode(-1);
        RandomListNode temp = head;
        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();
        while(temp != null){
            copy.next = new RandomListNode(temp.label);
            map.put(temp, copy.next);
            copy = copy.next;
            temp = temp.next;
        }
        copy = map.get(head);
        RandomListNode saveHead = copy;
        while(head != null){
            copy.random = map.get(head.random);
            head = head.next;
            copy = copy.next;
        }
        return saveHead;
    }
```


<br>
<br>


###139 Word Break

>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

<pre>
For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code".
</pre>

**Idea**: DP.

```java
    public boolean wordBreak(String s, Set<String> wordDict) {
        boolean[] arr = new boolean[s.length()];
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (wordDict.contains(s.substring(j, i + 1)) && (j == 0 || arr[j - 1])) {
                    arr[i] = true;
                    break;
                }
            }
        }
        return arr[s.length() - 1];
    }
```



<br>
<br>

###140 Word Break II



>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

>Return all such possible sentences.

>For example, given

>s = "catsanddog",

>dict = ["cat", "cats", "and", "sand", "dog"].

>A solution is ["cats and dog", "cat sand dog"].

**Brute force**: time limit exceeded for one use case "aaaaaaaaa......."

For this use case, we can use the previous problem "Word Break" to check if it can breank, then use the brute force.

```java
 public List<String> wordBreak(String s, Set<String> wordDict) {
      List<String> res = new ArrayList<>();
      wb(s, 0, "", wordDict, res);
      return res;
  }
  private void wb(String s, int index, String cur, Set<String> wordDict, List<String> res) {
        if (index == s.length()) {
            res.add(cur);
            return;
        }
        for (int i = index; i < s.length(); i++) {
            String temp = s.substring(index, i + 1);
            if (wordDict.contains(temp)) {
                String old = cur;
                cur = cur.length() == 0 ? temp : cur + " " + temp;
                wb(s, i + 1, cur, wordDict, res);
                cur = old;
            }
        }
    }
```

**Accepted solution based on the above brute force**:


```java
    public List<String> wordBreak(String s, Set<String> wordDict) {
        List<String> res = new ArrayList<>();
        if (!canBreak(s, wordDict)) {
            return res;
        }
        wb(s, 0, "", wordDict, res);
        return res;
    }
    
    private void wb(String s, int index, String cur, Set<String> wordDict, List<String> res) {
        if (index == s.length()) {
            res.add(cur);
            return;
        }
        for (int i = index; i < s.length(); i++) {
            String temp = s.substring(index, i + 1);
            if (wordDict.contains(temp)) {
                String old = cur;
                cur = cur.length() == 0 ? temp : cur + " " + temp;
                wb(s, i + 1, cur, wordDict, res);
                cur = old;
            }
        }
    }
    
    private boolean canBreak(String s, Set<String> wordDict) {
        boolean[] arr = new boolean[s.length()];
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (wordDict.contains(s.substring(j, i + 1)) && (j == 0 || arr[j - 1])) {
                    arr[i] = true;
                    break;
                }
            }
        }
        return arr[s.length() - 1];
    }
```

**Dp solution**:

```java
 public List<String> wordBreak(String s, Set<String> wordDict) {
        if (!canBreak(s, wordDict)) {
            return new ArrayList<String>();
        }
        List<String> init = new ArrayList<>();
        Map<Integer, List<String>> map = new HashMap<>();
        init.add("");
        map.put(s.length(), init);
        for (int i = s.length() - 1; i >= 0; i--) {
            List<String> cur = new ArrayList<>();
            for (int j = i + 1; j <= s.length(); j++) {
                if (wordDict.contains(s.substring(i, j))) {
                    for (String str : map.get(j)) {
                        cur.add(s.substring(i, j) + (str.isEmpty() ? "" : " ") + str);
                    }
                }
            }
            map.put(i, cur);
        }
        return map.get(0);
    }
    
    private boolean canBreak(String s, Set<String> wordDict) {
        boolean[] arr = new boolean[s.length()];
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j <= i; j++) {
                if (wordDict.contains(s.substring(j, i + 1)) && (j == 0 || arr[j - 1])) {
                    arr[i] = true;
                    break;
                }
            }
        }
        return arr[s.length() - 1];
    }
```

<br>
<br>

###141 Linked List Cycle

>Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

**Idea**: Use two pointers, one pointer move one step each time, the other pointer move two step each time. If they encounter, then a cycle exist.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public boolean hasCycle(ListNode head) {
        if(head == null) return false;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return false;
            if(f.equals(s)) return true;
        }
        return false;
    }
```


<br>
<br>    

###142 Linked List Cycle II

>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:
Can you solve it without using extra space?

**Idea**: 

- 1) Use the method in [141 Linked List Cycle](#141-linked-list-cycle) to check if cycle exist. 
- 2) when faster and slower encounters, change the faster to head, and move faster and slower one step each time until they encounter. At this time, the faster and slower point to the node where the cycle begins.

**Attention**: when check if they encounter, if check if they are null! Otherwise, if(f.equals(s)) will have null pointer. 
```java
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        ListNode f = head;
        ListNode s = head;
        while(f != null){
            f = f.next;
            if(f != null) f = f.next;
            s = s.next;
            if(f == null) return null;
            if(f.equals(s)) break;
        }
        f = head;
        while(f != null){
            if(f.equals(s)) return s;
            f = f.next;
            s = s.next;
        }
        return null;
    }
```


<br>
<br>

###143 Reorder List

>Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.

**Idea**: We can solve this problem in two ways.
- 1) copy a reversed linked list, then insert half of the list into original list.
- 2) Reverse the last half of the list, then insert it into the first half. 

**Attention**: When reverse, remember to set the first node's next to null, otherwise their will have a loop. 


***Solution1 code ***:

```java
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode copy = new ListNode(-1);
        int count = 0;
        ListNode temp = head;
        while (temp != null) {
            ListNode current = new ListNode(temp.val);
            current.next = copy;
            copy = current;
            temp = temp.next;
            count++;
        }
        if(count <= 2) {
            return;
        }
        temp = head;
        ListNode next = null;
        ListNode copyNext = null;
        ListNode pre = null;
        for(int i = 0; i < count/2; i++){
            next = temp.next;
            copyNext = copy.next;
            temp.next = copy;
            copy.next = next;
            pre = copy;
            temp = next;
            copy = copyNext;
        }
        if (count % 2 != 0) {
            temp.next = null;
        } else {
            pre.next = null;
        }
    }

```    
***Solution2 code ***:
```java    
  public void reorderList(ListNode head) {
    // write your solution here
    if (head == null || head.next == null || head.next.next == null) {
      return;
    }
    //find the mid node
    ListNode slower = head; //move one step each time
    ListNode faster = head; // move two steps each time
    ListNode pre = null;
    while (faster != null) {
      pre = slower;
      slower = slower.next;
      faster = faster.next;
      if (faster != null) {
        faster = faster.next;
      }
    }
    pre.next = null;
    
    //reverse last half
    slower = reverseList(slower);
    ListNode temp = head;
    while(temp != null && slower != null) {
      ListNode insert = slower;
      ListNode next = temp.next;
      slower = slower.next;
      temp.next = insert;
      insert.next = next;
      temp = temp.next.next;
    }
  }
  
  public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode pre = null;
    ListNode next = null;
    while (head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
  }
```


<br>

**Related**: Reorder array in place 

> eg : { 1, 2, 3, 4, 5, 6, 7, 8 } → { 1, 5, 2, 6, 3, 7, 4, 8 }

> { 1, 2, 3, 4, 5, 6, 7 } → { 1, 4, 2, 5, 3, 6, 7 }

```java
  public int[] reorder(int[] array) {
    if (array == null || array.length == 0) {
      return array;
    }
    int len = array.length % 2 == 0 ? array.length : array.length - 1;
    for (int i = len / 2; i < len / 2 * 2; i++) {
      int temp = array[i];
      for (int j = i - 1; j > 2 * i - len; j--) {
        array[j + 1] = array[j];
      }
      array[2 * i - len + 1] = temp;
    }
    return array;
  }
```

<br>
<br>


###144 Binary Tree Preorder Traversal


>Given a binary tree, return the preorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,2,3].

</pre>

Note: Recursive solution is trivial, could you do it iteratively?


**Idea**:

- Solution 1: recursive. list.add(root.val), then recursive to left and right

- Soltuion 2: Iterative. Use stack. If root != null,store root.val in result list and push root to stack, keep go left. Otherwise, pop root, go right

- Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)


**Solution 1**: Recursive

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        preorderTraversal(root, res);
        return res;
    }
    public void preorderTraversal(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorderTraversal(root.left, res);
        preorderTraversal(root.right, res);
    }
```

**Solution 2**: iterative with stack

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        while (!stack.isEmpty()) {
           TreeNode cur = stack.pop();
           res.add(cur.val);
           if (cur.right != null) {
               stack.push(cur.right);
           }
           if (cur.left != null) {
               stack.push(cur.left);
           }
        }
        return res;
    }
```

**Solution 3**: Morris traversal

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
        TreeNode pre = null;
        while (root != null) {
            if (root.left == null) {
                res.add(root.val);
                root = root.right;
            } else {
                pre = root.left;
                while (pre.right != null && pre.right != root) {
                    pre = pre.right;
                }
                if (pre.right == null) {
                    pre.right = root;
                    res.add(root.val);
                    root = root.left;
                } else {
                    pre.right = null;
                    root = root.right;
                }
            }
        }
        return res;
    }
```

<br>

**Related**: Search in binary search tree

```java
public TreeNode search(TreeNode root, int key) {
    // Write your solution here.
    if (root == null) {
      return null;
    }
    while (root != null) {
      if (root.key == key) {
        return root;
      } else if (root.key > key) {
        root = root.left;
      } else {
        root = root.right;
      }
    }
    return null;
}

```

<br>

**Related**: Insert in binary search tree

**Idea**:

- if root is null, insert new element as root
- Otherwise search insert position. If insert key greater than parent, insert as right child otherwise, insert as left child


```java
  public TreeNode insert(TreeNode root, int key) {
    // Write your solution here.
    if (root == null) {
      root = new TreeNode(key);
      return root;
    }
    TreeNode temp = root;
    TreeNode pre = null;
    while (temp != null) {
      pre = temp;
      if (temp.key == key) {
        return root;
      } else if (temp.key < key) {
        temp = temp.right;
      } else {
        temp = temp.left;
      }
    }
    if (pre.key > key) {
      pre.left = new TreeNode(key);
    } else {
      pre.right = new TreeNode(key);
    }
    return root;
  }
```

<br>
<br>

###145 Binary Tree Postorder Traversal

>Given a binary tree, return the postorder traversal of its nodes' values.

<pre>
For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

</pre>

Note: Recursive solution is trivial, could you do it iteratively?


**Idea**:

- Solution 1: recursive. recursive to left and right, then list.add(root.val)

- Soltuion 2: Iterative. Use stack. If root != null,push root to stack, keep go left. Otherwise, pop root, go right then add root.val

- Solution 3: Morris, without stack. Create links to the successor(use leaf node's left or right null pointer), in the solution below, we use the right pointer. See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)

**Solution 1**: recursive

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    postorderTraversal(root, res);
    return res;
}
public void postorderTraversal(TreeNode root, List<Integer> res) {
    if (root == null) {
        return;
    }
    postorderTraversal(root.left, res);
    postorderTraversal(root.right, res);
    res.add(root.val);
}
```

**Solution 2**: Iterative, from wiki

```java
public static List<Integer> postorderTraversal(TreeNode root){
    List<Integer> res = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode preVisited = null;
    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            TreeNode top = stack.peek();
            if (top.right != null && preVisited != top.right) {
                root = top.right;
            } else {
                top = stack.pop();
                res.add(top.val);
                preVisited = top;
            }
        }
    }
    return res;
}

```

**Solution 3**: based on preorder.

```java
  public List<Integer> postOrder(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
      return res;
    }
    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    stack.push(root);
    while (!stack.isEmpty()) {
      TreeNode cur = stack.pop();
      res.add(0, cur.key);
      if (cur.left != null) {
        stack.push(cur.left);
      }
      if (cur.right != null) {
        stack.push(cur.right);
      }
    }
    return res;
  }
```


**Solution 4**: Morris

 See details on blog [Morris traversal](http://wishyouhappy.github.io/2014/12/17/morris%20traversal-traverse%20a%20binary%20tree%20without%20stack/)


<br>
<br>

###146 LRU Cache

>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

**Idea** HashMap + double LinkedList

1) We use hashmap to quickly get value by key. 


2) We use double LinkedList not single linkedlist because when we get(key), we need to update the node to the tail of the linkedlist and remove it from the original place, thus double list not single list is needed.

**Get**:

- if node exists, update the node to the tail of the list and return value.

**Set**:

- If node exists, change the value, update it to tail
- Otherwise, check if cache is full
-- if is full, remove node from head(least recent used), then add node to tail.
-- otherwise, just add node to tail.

Remember to check if head/tail is null when set values.

**Solution**:

```java
public class LRUCache {
    class Node {
        Node pre, next;
        int key;
        int val;
        public Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
    
    private Map<Integer, Node> map;
    
    private Node head;
    
    private Node tail;
    
    private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if (node == null) {
            return -1;
        }
        updateToLatest(key, node);
        return node.val;
    }
    
    private void updateToLatest(int key, Node node) {
         if (node != tail) {
            //remove node from the original place.
            if (node == head) {
                head = head.next;
            } else {
                node.pre.next = node.next;
            }
            node.next.pre = node.pre;
            
            //add node to tail.
            tail.next = node;
            node.pre = tail;
            node.next = null;
            tail = node;
        }
    }
    
    public void set(int key, int value) {
        Node node = map.get(key);
        if (node != null) {
            //set node's value
            node.val = value;
            updateToLatest(key, node);
        } else {
            Node target = new Node(key, value);
            //If cache is full, remove least recent from head
            if (map.size() >= capacity) {
                map.remove(head.key);
                head = head.next;
                if (head != null) {
                    head.pre = null;
                } else {
                    tail = null;
                }
            }
            if (head == null){
                head = target;
                tail = target;
            } else {
                tail.next = target;
                target.pre = tail;
                tail = target;
                map.put(key, target);
            }
            map.put(key, target);
        }
    }
}

```

<br>
<br>


###147 Insertion Sort List	
> Sort a linked list using insertion sort.


**Idea**: It's similar to insertion sort array. The difference is that in array, if we want to insert i into (0....i-1), we can swap form i-1 if array[i] < array[i-1]. But we can not visit a linkedlist by index. What we can do is visit from the first element.

Something we can do to simplify the insert:
 
- 1) first check if current.val >= pre.val. If true, it's already in right place. we can just go to the next element. 
- 2) then check if current.val <= head.val. If true, we can just insert it before the head.
- 3) If it's not eh two cases above, we need to find the right place to insert the element. Because we have eliminate the corner case above, thus we just need to find the insertion spot, then change the relationship of the pointers.

If we add a fakeHead pointer to avoid the null pointer cases, we can have more concise code.

**Time***: O(n^2)

<br>
```java
    public ListNode insertionSortList(ListNode head) {
        if(head == null) return null;
        ListNode fakeHead = new ListNode(-1);
        ListNode cur = head;
        ListNode temp = fakeHead;
        while(cur != null){
            ListNode next = cur.next;
            ListNode pre = fakeHead;
            temp = fakeHead.next;
            while(temp != null && temp.val < cur.val){
                pre = temp;
                temp = temp.next;
            }
            pre.next = cur;
            cur.next = temp;
            cur = next;
        }
        return fakeHead.next;
    }
```

<br>

 Actually, in some cases the code below is a little faster then above. 	Because when the element is alreay in the right place, we don't need to find 	from the beginning 

```java	
	 public ListNode insertionSortList(ListNode head) {
	        if(head == null) return null;
	        ListNode cur = head.next;
	        ListNode preCur = head;
	        while(cur != null){
	            ListNode next = cur.next;
	            if(cur.val >= preCur.val){
	                preCur = cur;
	            }else if(cur.val <= head.val){
	                cur.next = head;
	                head = cur;
	                preCur.next = next;
	            }else{
	                ListNode insertPre = head;
	                ListNode temp = head.next;
	                while(temp != null && temp.val < cur.val){
	                    insertPre = temp;
	                    temp = temp.next;
	                }
	                insertPre.next = cur;
	                cur.next = temp;
	                preCur.next = next;
	            }
	            cur = next;
	        }
	        return head;
	    }
```


<br>
<br>

###148 Sort List

> Sort a linked list in O(n log n) time using constant space complexity.

**Idea**: It require us to sort in O(nlgn) time. "Mergesort" and "Quicksort" is the typical O(nlgn) sort algorithm. When use merge sort, similar with mergesort an array, we fisrt need to find the mid of the list. (The typical two pointer method to find the middle). Then sort(left, mid-1), sort(mid , right) and merge the result.


<br>
```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode faster = head;
    ListNode slower = head;
    while (faster.next != null && faster.next.next != null) {
        faster = faster.next.next;
        slower = slower.next;
    }
    ListNode right = sortList(slower.next);
    slower.next = null;
    return merge(sortList(head), right);
}

private ListNode merge(ListNode h1, ListNode h2) {
    ListNode fakeHead = new ListNode(-1);
    ListNode h = fakeHead;
    while (h1 != null && h2 != null) {
        if (h1.val < h2.val) {
            h.next = h1;
            h1 = h1.next;
        } else {
            h.next = h2;
            h2 = h2.next;
        }
        h = h.next;
    }
    if (h1 != null) {
        h.next = h1;
    } else if (h2 != null) {
        h.next = h2;
    }
    return fakeHead.next;
}
```		


<br>
<br>

###149 Max Points on a Line

>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

**Note**:

- Make sure to consider the same points ( x and y both the same)
- Make sure to consider x1 = x2
- Make sure when y1 = y2, don't use (y1 - y2)/(x1 - x2) to calculate the k, because they have twp values
  **0.0 / -0.0**

```java
  public int maxPoints(Point[] points) {
        if (points.length <= 1) {
            return points.length;
        }
        int res = 0;
        for (int i = 0; i < points.length; i++) {
            Map<Double, Integer> map = new HashMap<>();
            Point p1 = points[i];
            int same = 1;
            for (int j = i + 1; j < points.length; j++) {
                Point p2 = points[j];
                if (p1.x == p2.x && p1.y == p2.y) {
                    same++;
                } else {
                    double k = 0;
                    if (p1.x == p2.x) {
                        k = Double.MAX_VALUE;
                    } else if (p1.y == p2.y) {
                        k = 0.0;
                    } else {
                        k = (double) (p1.y - p2.y) / (double) (p1.x - p2.x);
                    }
                    Integer count = map.get(k);
                    if (count == null) {
                        map.put(k, 1);
                    } else {
                        map.put(k, count + 1);
                    }
                }
            }
            int local = 0;
            for (Map.Entry<Double, Integer> entry : map.entrySet()) {
                local = Math.max(local, entry.getValue());
            }
            res = Math.max(res, local + same);
        }
        return res;
    }
```
<br>
<br>

###150 Evaluate Reverse Polish Notation

>Evaluate the value of an arithmetic expression in Reverse Polish Notation.

<pre>
Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
</pre>

**Idea**:

Use a stack, when number, push to stack. when operator, pop two elements from the stack, then push the result to stack

```java
    public int evalRPN(String[] tokens) {
        int res = 0;
        Deque<Integer> stack = new LinkedList<>();
        for (String token : tokens) {
            if (isOperator(token)) {
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                res = getValue(num1, num2, token);
                stack.push(res);
            } else {
                stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
    private boolean isOperator(String s) {
        return s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/"); 
    }
    private int getValue(int num1, int num2, String token) {
        if (token.equals("+")) {
            return num2 + num1;
        } else if (token.equals("-")) {
            return num2 - num1;
        } else if (token.equals("*")){
            return num2 * num1;
        } else {
            return num2 / num1;
        }
    }
```

**More concise code, jdk >= 1.7**:

```java
 public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<>();
        for (String token : tokens) {
            switch (token) {
                case "+":
                    stack.push(stack.pop() + stack.pop());
                    break;
                case "-":
                    stack.push(-stack.pop() + stack.pop());
                    break;
                case "*":
                    stack.push(stack.pop() * stack.pop());
                    break;
                case "/":
                    int num1 = stack.pop();
                    stack.push(stack.pop() / num1);
                    break;
                default:
                    stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
```


<br>
<br>


###151 reverse words in a string

**Idea**:

- 1) First remove spaces at beginning and at end
- 2) use regular expression split words.
- 3) recreate result string

**Solution**:

```java
public String reverseWords(String input) {
    if (input == null || input.length() == 0) {
      return input;
    }
    input = input.trim();
    String[] arr = input.split("\\s+");
    StringBuilder res = new StringBuilder();
    for (int i = arr.length - 1; i >= 0; i--) {
      res.append(arr[i] + " ");
    }
    return res.toString().trim();
}

```


**Solution without use regular expresssion**:

```java
public String reverseWords(String input) {
        input = input.trim();
        if (input.length() == 0) {
            return input;
        }
        char[] arr = input.toCharArray();
        reverse(arr, 0, arr.length - 1);
        int i = 0;
        StringBuilder res = new StringBuilder();
        while (i < arr.length) {
            int j = i;
            while (j < arr.length && arr[j] != ' ') {
                j++;
            }
            reverse(arr, i, j - 1);
            res.append(new String(Arrays.copyOfRange(arr, i, j)) + " ");
            while (j < arr.length && arr[j] == ' ') {
                j++;
            }
            i = j;
        }
        return res.toString().trim();
    }
    private void reverse (char[] arr, int i, int j) {
        while (i < j) {
            swap(arr, i++, j--);
        }
    }
    private void swap(char[] arr, int i, int j) {
        char c = arr[i];
        arr[i] = arr[j];
        arr[j] = c;
    }
```
<br>

###152 Maximum Product Subarray

>Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.


**Idea**: dp

```java
 public int maxProduct(int[] nums) {
    int max = nums[0];
    int min = nums[0];
    int res = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] >= 0) {
            max = Math.max(max * nums[i], nums[i]);
            min = Math.min(min * nums[i], nums[i]);
        } else {
            int temp = max;
            max = Math.max(min * nums[i], nums[i]);
            min = Math.min(temp * nums[i], nums[i]);
        }
        res = Math.max(max, res);
    }
    return res;
}
```

**A more simple solution**:

```java
public int maxProduct(int[] nums) {
    int max = nums[0];
    int min = nums[0];
    int res = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int temp = max;
        max = Math.max(Math.max(nums[i] * max, nums[i]), min * nums[i]);
        min = Math.min(Math.min(temp * nums[i], nums[i]), min * nums[i]);
        res = Math.max(max, res);
    }
    return res;
}
```

<br>
<br>


###153 Find Minimum in Rotated Sorted Array

>Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>Find the minimum element.

>You may assume ***no duplicate*** exists in the array.

**Idea**: The idea is same to * [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array). 

Each time we find the increasing interval. For example, if A[mid] > A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. 

Time complexity: O(lgn)


**Java code**:

```java
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Integer.MIN_VALUE;
        }
        int l = 0;
        int r = nums.length - 1;
        int result = Integer.MAX_VALUE;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            //the left half is in order
            if (nums[mid] >= nums[l]) {
                result = Math.min(result, nums[l]);
                l = mid + 1;
            } else if (nums[mid] < nums[r]) {
            	//can also use  else if (nums[mid] < numd[r])
                result = Math.min(result, nums[mid]);
                r = mid - 1;
            }
        }
        return result;
    }
```



<br>
<br>

154 Find Minimum in Rotated Sorted Array


>Follow up for "Find Minimum in Rotated Sorted Array":
***What if duplicates are allowed?***

>Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

>Find the minimum element.

>The array may contain duplicates.


**Idea**: Same way to handle duplicates with *[81 Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-ii). 

To find the minimum, use the method in 153. 

Each time we find the increasing interval. For example, if A[mid] > A[l], then the left part must in order. Thus we update the minimum if needed, then jump to the right part. 


**Attention**: When nums[mid] = nums[l], we need to check if we have to update minimum with A[l] before l++


**Java Solution**:


```java
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Integer.MIN_VALUE;
        }
        int l = 0;
        int r = nums.length - 1;
        int result = Integer.MAX_VALUE;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            //the left half is in order
            if (nums[mid] > nums[l]) {
                result = Math.min(result, nums[l]);
                l = mid + 1;
            } else if (nums[mid] < nums[l]) {
                result = Math.min(result, nums[mid]);
                r = mid - 1;
            } else {
                result = Math.min(result, nums[l]);
                l++;
            }
        }
        return result;
    }


```





<br>
<br>




###155 Min Stack
>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
<pre>
push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
</pre>


**Idea**: Memory limits. If we just a corresponding minstack with the same length of the stack, we would exceed the limit on leetcode. What should we do? We just need to keep the current smallest element. Eg: push(1) to stack, we push(1) to minstack. Next time we push(2) to stack, we don't need to push(2) to minstack. Because the min value is still 1. Thus, every time we push an element to stack, we check if element x > minstack.peek(), if true, we don't need to push. When pop, we check if element x == minstack.peek(), if equals, minstack.pop().

**Attention** :

-  Duplicate elements. (less or equal than, push into min stack). Eg: push (0), push(1), push(0), the minstack should have element 0, 0. 

- **Stack class comeout at Java version 1.0. It's not efficient enough, we should avoid using stack.** 


```java

public class Solution {
  private Deque<Integer> stack;
  private Deque<Integer> minStack;
  public Solution() {
    stack = new LinkedList<Integer>();
    minStack = new LinkedList<Integer>();
  }
  
  public Integer pop() {
    if (stack.isEmpty()) {
      return null;
    }
    if (stack.peek() <= minStack.peek()) {
      minStack.pop();
    }
    return stack.pop();
  }
  
  public void push(int element) {
    if (minStack.isEmpty() || minStack.peek() >= element) {
      minStack.push(element);
    } 
    stack.push(element);
  }
  
  public Integer top() {
    return stack.isEmpty() ? null : stack.peek();
  }
  
  public Integer min() {
    return stack.isEmpty() ? null : minStack.peek();
  }
}

```

**Related**: Implement queue with two stacks

```java
class Solution
{
  private Stack<Integer> stackOne;
  private Stack<Integer> stackTwo;
  private int size;
  public Solution() {
    // Write your solution here.
    stackOne = new Stack<Integer>();
    stackTwo = new Stack<Integer>();
    size = 0;
  }
  
  public Integer poll() {
    if (!stackTwo.isEmpty()) {
      size--;
      return stackTwo.pop();
    }
    while (!stackOne.isEmpty()) {
      stackTwo.push(stackOne.pop());
    }
    if (!stackTwo.isEmpty()) {
      size--;
      return stackTwo.pop();
    } else {
      return null;
    }
  }
  
  public void offer(int element) {
    stackOne.push(element);
    size++;
  }
  
  public Integer peek() {
    if (!stackTwo.isEmpty()) {
      return stackTwo.peek();
    }
    while (!stackOne.isEmpty()) {
      stackTwo.push(stackOne.pop());
    }
    if (!stackTwo.isEmpty()) {
      return stackTwo.peek();
    } else {
      return null;
    }
  }
  
  public int size() {
    return size;
  }
  
  public boolean isEmpty() {
    return size == 0;
  }
}
```
 		
    
### 156 Binary Tree Upside Down

> Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares a same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

<pre>
For example:
Given a binary tree {1,2,3,4,5},
    1
   / \
  2   3
 / \
4   5

return the root of the binary tree [4,5,2,#,#,3,1].
   4
  / \
 5   2
    / \
   3   1  				   
   
</pre>

**Idea:** 

The structure of the original tree: 

* 1) right child doesn't have children
* 2) If right child exist, left child must exist. 

Structure of result tree:

* 1) Right child turn to left child: p.left = parent.right

* 2) Parant becomes right child: p.right = parent 

* 3) Left child becomes root. 

**Solution**: Iterative

```java
public TreeNode upsideDownBinaryTree(TreeNode root){
	TreeNode parent = null;
    TreeNode rightChild = null;
    TreeNode leftChild = null;
	while (root != null) {
		leftChild = root.left;
		root.left = rightChild; //  Right child turn to left child
		rightChild = root.right;
		root.right = parent;   //Parant becomes right child
		parent = root;
		root = leftChild;  //Left child becomes root
	}
	return parent;	
}	

```

**Solution**: recursive

**Note**: In this method, after change the tree, we need to set root.left = null and root.right = null. Otherwise, there will be a cycle.

```java
public TreeNode UpsideDownBinaryTree(TreeNode root) {  
    if (root == null) {
        return null;
    }  
    TreeNode parent = root;
    TreeNode left = root.left;
    TreeNode right = root.right;  
    if (left != null) {  
        TreeNode ret = upsideDownBinaryTree(left);  
        left.left = right;  
        left.right = parent;  
        root.left = null;
        root.right = null;
        return ret;  
    } 
 
    return root;  
}   

```

<br>

**Related**: reverse binary tree.

<pre>
        1

      /    \

    2        5

  /   \

3      4

is reversed to

        3

      /    \

    2        4

  /   \

1      5


</pre>

```java
  public TreeNode reverse(TreeNode root) {
    TreeNode parent = null;
    TreeNode preRight = null;
    TreeNode right = null;
    TreeNode left = null;
    while (root != null) {
      left = root.left;
      right = root.right;
      root.left = parent;
      root.right = preRight;
      parent = root;
      root = left;
      preRight = right;
    }
    return parent;
  }

```
<br>
<br>


### 157 Read N Characters Given Read4 

> The API: int read4(char *buf) reads 4 characters at a time from a file.
> 
> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
> 
> Note:The read function will only be called once for each test case.

**Idea:**Iterative call read4 before end of file or each n, store and copy it to the destination buf. 

**Ambiguity:**What if n exceeds the buf's length? 
```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	public int read(char[] buf, int n){
		char[] buffer = new char[4];
		int count = 0;
		int current = 0;
		int needAdd = 0;
		while(true){
			current = read(buffer);
			if(current == 0 || n == count) return count;
			needAdd = Math.min(n-count, current);
			for(int i = 0; i < needAdd; i++){
				buf[count++] =  buffer[i];
			}
		}
	}
```	


<br>
<br>

	

### 158 Read N Characters Given Read4 II - Call multiple times. 

> The API: int read4(char *buf) reads 4 characters at a time from a file.

> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

> Note:
> The read function may be called multiple times.


**Idea:** Because the read function maybe called multiple times, so at the next call, there might be some data remain in the read4 buffer due to the up amount data of n at each readN bytes call. So we need to keep track of the state of read 4 buffer. If there remains data at read4 buffer at the call, we need start from that position instead of call read4 function. 

```java
	/* read 4 characters each time, return the exact number of characters read. */
	int read(char[] buf);
	int read4Ptr = 0;
	int read4Count = 0;
	char[] buffer = new char[4];
	public int read(char[] buf, int n){	
		int count = 0;
		while(true){
			if(read4Ptr == 0){
				read4Count = read(buffer);
			}
			if(read4Count == 0 || n == count) return count;
			while(count < n && read4Ptr < read4Count){
				buf[count++] =  buffer[read4Ptr++];
			}
			read4Ptr = read4Ptr%read4Count;
			
		}
	}
```	




<br>
<br>


### 159 Longest String with At Most Two Distinct Characters
> Given a string, find longest substring T that contains at most 2 distinct characters.For example, Given s = “eceba”,T is "ece" which its length is 3.

**Idea**: Using a slide window keep track of the substring with at most 2 distinct characters. Each time we encounter the third distinct character, we first calculate the length of the substring, then we move the start position of our slide window to the position that contains only the third character, the first character or the third character, the second character. 

**Example:** Assume the string is accacccbac....., when we encounter "b" at index 7, we calculate the length of substring accaccc and do related operations, then we move the start position of slide window to index 4, then keep going... 

**Solution && time complexity:**	Time complexity: O(n), map contains only two elements. Here, we can use two variables to replace the hashmap, if we extend the problem to k characters, then hashmap maybe more convenient 

```java
	public String subString(String s){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == 2 && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	
	
```	

**Another way**: This is **not as fast as** the method above. If we encounter the third different element, we can find back from this element and reset the start window to make it contains only two different elements.

```java
	public String subStr(String s){
		if(s == null || s.length() == 0) return s;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		int start = 0;
		int max = 0;
		int end = 0;
		int j = 0;
		for(int i = 0; i < s.length(); i++){
			if(i == s.length()-1 && map.size() <= 2 && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(!map.containsKey(s.charAt(i)) && map.size() == 2){
				if(i - j > max){
					start = j;
					end = i-1;
					max = i-j;
				}
				int temp = i-1;
				char c = s.charAt(temp);
				while(temp >= 0 && s.charAt(temp) == c) temp--;
				j = temp + 1;
				map.remove(s.charAt(temp));
			}
			map.put(s.charAt(i), i);
		}
		return j == 0 ? s : s.substring(start, end+1);
		
	}

```
**Extention:** Find the longest substring contains at most k unique elements. Idea is much similar with k = 2. When we encounter the k+1 character, we need to calculate the length of string do related operations and move slide window, let it contains only k-1 different characters, add the k+1 character, and keep going.  

**Time Complexity:** O(k * n)

```java
	public String subString(String s, int k){
		int start = 0; // start of longest substring
		int end = 0;   // end of longest substring
		int j = 0;     // start of slide window
		int max = 0;
		Map<Character, Integer> map = new HashMap<Character, Integer>();
		for(int i = 0; i < s.length(); i++){
			//check: contains <= 2 characters && substring ends at the end 
			if(i == s.length()-1 && map.size() <= k && map.containsKey(s.charAt(i))){
				if(end == 0) return s;
				else{
					if(max < s.length() - j){
						start = j;
						end = s.length()-1;	
					}
				}
			}
			if(map.size() == k && !map.containsKey(s.charAt(i))){
				if(max < i - j){
					max = i - j ;
					start = j;
					end = i-1;
				}
				j = s.length();
				char needToRemove = ' ';
				for(char c : map.keySet()){
					if(j > map.get(c)){
						j = map.get(c);
						needToRemove = c;
					}
				}
				j++;
				map.remove(needToRemove);
			}
				map.put(s.charAt(i), i);
		}
		return s.substring(start, end+1);
	}
```




<br>
**Related**: longest substring without repeating characters.

**Time complexity**: O(2 * n) = O(n)

```java
  public int lengthOfLongestSubstring(String s) {
    if (s == null || s.length() == 0) {
      return 0;
    }
    int res = 0;
    int start = 0;
    int current = 0;
    Set<Character> set = new HashSet<Character>();
    while (current < s.length()) {
      char c = s.charAt(current);
      if (!set.contains(c)) {
        set.add(c);
      } else {
        res = Math.max(res, current - start);
        while (s.charAt(start) != c) {
          set.remove(s.charAt(start++));
        }
        start++;
      }
      current++;
    }
    res = Math.max(res, current - start);
    return res;
  }

```

<br>
<br>


###160 Intersection of Two Linked Lists
>Write a program to find the node at which the intersection of two singly linked lists begins.


<pre>
For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3

begin to intersect at node c1.

</pre>


Notes:

If the two linked lists have no intersection at all, return null.

The linked lists must retain their original structure after the function returns.

You may assume there are no cycles anywhere in the entire linked structure.

Your code should preferably run in O(n) time and use only O(1) memory.


<br>

**Idea**: 

Solustion1: 

We can get the length of two linkedlist, assume len1 > len2. We move head1 move len1-len2 steps, then compare each node in list1 and list2, until two lists have the same nodes. 

Solution2: We don't need to calculae the length of list1 and list2. Use two pointers p1 p2, when one pointer reaches the end, assume it's p1, we change p1  to head2. Then continues until p2 reach to the end. By this time, p1 is pointer to len2 -len1 of list2, we let p2 points to head1. So we can continue to compare until we encounter same nodes. 


**Attention**: Null pointer! We need to take care of null pointer for all linkedlist problems.

Solution1 :
```java
	 public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       int lenA = 0;
	       int lenB = 0;
	       ListNode temp = headA;
	       while(temp != null){
	           lenA++;
	           temp = temp.next;
	       }
	       temp = headB;
	       while(temp != null){
	           temp = temp.next;
	           lenB++;
	       }
	       int diff = Math.abs(lenA - lenB);
	       if(lenA > lenB){
	           while(diff > 0) {
	               headA = headA.next;
	               diff--;
	           }
	       }else{
	           while(diff > 0){
	               headB = headB.next;
	               diff--;
	           }
	       }
	       while(headA != null && headB != null && !headA.equals(headB)){
	           headA = headA.next;
	           headB = headB.next;
	       }
	       return headA;
	 }
```
Solution2:
```java
	 public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
	       if(headA == null || headB == null) return null;
	       ListNode tempA = headA;
	       ListNode tempB = headB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	       tempA = tempA == null ? headB : tempA;
	       tempB = tempB == null? headA : tempB;
	       while(tempA != null && tempB != null){
	           tempA = tempA.next;
	           tempB = tempB.next;
	       }
	      tempA = tempA == null ? headB : tempA;
	      tempB = tempB == null ? headA : tempB;
	      while(tempA != null && tempB != null && !tempA.equals(tempB)){
	          tempA = tempA.next;
	          tempB = tempB.next;
	      }
	      return tempA;
	 }
```


<br>
<br>


###161 One edit distance

>Given two string, after one edit, if they equals, return true, otherwise return false. 

**Idea**:

- One edit contains: one delete, one add or one change.

- if abs (word1.length() - word2.length()) > 1, return false

- if length equals, then they should have one different character

- if length1 < length2, then after find the first different character, the remain should be the same.

```java

    public boolean isOneEditDistance(String word1, String word2){
        //After swap, word1.length() <= word2.length
        String temp = word1.length() < word2.length() ? word1 : word2;
        word2 = temp.equals(word1) ? word2 : word1;
        word1 = temp.equals(word1) ? word1 : temp;
        
        int len1 = word1.length();
        int len2 = word2.length();
        
        if (len2 > len1+1) {
            return false;
        }
        int i = 0;
        while (i < len1 && word1.charAt(i) == word2.charAt(i)) {
            i++;
        }
        if (i == len1) {
            return (len2-len1) == 1;
        }
        if(len1 == len2) {
            i++;
        }
        
        /* if two len equals, two of them start from i+1, if not equals, word2 start from i+1*/
        while(i < len1 && word1.charAt(i) == word2.charAt(i+len2-len1)) {
            i++;
        }
        return i == len1;
    }

```


<br>

**Related**: Edit distance

> Given two strings, return the minimum edits to make them equal.

**Idea**:

- Base case: i = 0 , arr[i][j] = j
             j = 0, arr[i][j] = i

- induction: arr[i][j] = arr[i-1][j-1] if one[i-1] = two[j-1] otherwise, arr[i][j] = min(arr[i-1][j-1], arr[i-1][j], arr[i][j-1]) + 1

```java
  public int editDistance(String one, String two) {
    int[][] arr = new int[one.length() + 1][two.length() + 1];
    for (int i = 0; i <= one.length(); i++) {
      for (int j = 0; j <= two.length(); j++) {
        //base case
        if (i == 0) {
          arr[i][j] = j;
        } else if (j == 0) {
          arr[i][j] = i;
        } else if (one.charAt(i - 1) == two.charAt(j - 1)) {
          arr[i][j] = arr[i - 1][j - 1];
        } else {
          int min = Math.min(arr[i - 1][j], arr[i][j - 1]);
          arr[i][j] = Math.min(min, arr[i - 1][j - 1]) + 1;
        }
      }
    }
    return arr[one.length()][two.length()];
  }

```

<br>
<br>

###162 Find Peak Element


>A peak element is an element that is greater than its neighbors.

>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

>You may imagine that num[-1] = num[n] = -∞.

>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.


**Idea**: Since there is no duplicate, and num[-1] = num[n] = -inf, thus the peak must exist. We can eaisly solve this problem in brute force in O(n) time. Can we improve it? 

Sure, use **binary search!.**

Since we only need to return one of the peaks, thus if we encounter an element which satisfies that num[i-1] < num[i], num[i] > num[i+1], then we can return. 

Then how to change window in binary search?
We move to the side that has has peeks. We can check if num[i-1] > num[i], if it is true, then we move to the left, otherwise, we move to the right.

Look at the following picture:

![peak](https://wishyouhappy.github.io/pictures/peakelement.png)

Suppose in the above three cases, 5 is the mid.

- case 1: return 5, because 5 is a peak
- case 2: num[mid -1] > num[mid], thus there must exist a peak on the left side. Why? If 7 is larger than the element on the left side of it, then 7 is a peak, otherwise, the element on the left side of 7 might be a peak. Because we know that there is a -inf on the leftmost.
- case 3: num[mid - 1] < num[mid], then we move to the right part. Because the element on the right side of 5 must be larger than 5. Otherwise, 5 is a peak.

**Java code**: 


**Binary search**: TIME : O(lgn)


```java
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int l = 0;
        int r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((mid == 0 || nums[mid] > nums[mid - 1]) && (mid == nums.length -1 || nums[mid] > nums[mid + 1])) {
                return mid;
            } else if (mid > 0 && nums[mid] < nums[mid - 1]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

```

**Brute force**: Time complexity: O(n)
```java
    public int findPeakElement1(int[] num) {
        if(num == null || num.length == 0) return -1;
        if(num.length == 1) return 0;
        for(int i = 0; i < num.length-1; i++){
        	if(i == 0){
        		if(num[i] > num[i+1]) return i;
        	}else{
        		if(num[i] > num[i+1] && num[i] > num[i-1]) return i;
        	}
        }
        if(num[num.length-1] > num[num.length-2]) return num.length -1;
        return -1;
    }

```



<br>
<br>

###163 Missing Ranges

>Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.
For example, given [0, 1, 3, 50, 75], return [“2”, “4->49”, “51->74”, “76->99”]

**Idea**:

Check if the end - start > 1, if true, add range. Otherwise, continue.



```java
public List<String> findMissingRanges(int[] vals, int lower, int upper) {
    List<String> res = new ArrayList<>();
    int start = lower;
    for (int i = 0; i <= vals.length; i++) {
        int end = (i == vals.length) ? upper + 1: vals[i];
        if (end > start + 1) {
            res.add(getRangeString(start, end));
        }
        start = end;
    }
    return res;
}
private String getRangeString(int start, int end) {
    return (end - start == 2) ? ("" + (start + 1)) : (start + 1) + "->" + (end - 1);
}
```

<br>
<br>

###164 Maximum Gap

>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

>Try to solve it in linear time/space.

>Return 0 if the array contains less than 2 elements.

>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.


**Solution 1** : radix sort

```java
   public int maximumGap(int[] num) {
        if (num == null || num.length <= 1) {
            return 0;
        }
    LinkedList<Integer>[] bucket = new LinkedList[10];
        for (int i = 0; i <10; i++) {
          bucket[i] = new LinkedList<Integer>();
        }
        int mod = 10;
        int divider = 1;
        
        /* sort the array use radix sort*/
        for (int i = 0; i < 10; i++, mod *= 10, divider *= 10) {
          for (int j = 0; j < num.length; j++) {
            bucket[(num[j] % mod)/divider].add(num[j]);
          }
          int pos = 0;
          for (int j = 0; j < 10; j++){
            while (bucket[j].peek() != null) {
              num[pos++] = bucket[j].poll();
            }
          }
        }
        
        /* find the maximumGap */
        int max = 0;
        for (int i = 1; i < num.length; i++) {
          max = Math.max (max, Math.abs(num[i] - num[i-1]));
        }
        return max;
    }
```

**Solution 2** : bucket sort


```java
 class Bucket {
    int start;
    int end;
    public Bucket() {
        start = -1;
        end = -1;
    }
}
public int maximumGap(int[] nums) {
    if (nums.length < 2) {
        return 0;
    }
    int max = nums[0];
    int min = nums[0];
    for (int i = 1; i < nums.length; i++) {
        max = Math.max(max, nums[i]);
        min = Math.min(min, nums[i]);
    }
    Bucket[] buckets = new Bucket[nums.length + 1];
    for (int i = 0; i < buckets.length; i++) {
        buckets[i] = new Bucket();
    }
    double gap = (double) (max - min) / (double) (nums.length);
    for (int i = 0; i < nums.length; i++) {
        int index = (int) ((nums[i] - min) / gap);
        if (buckets[index].start == -1) {
            buckets[index].start = nums[i];
            buckets[index].end = nums[i];
        } else {
            buckets[index].start = Math.min(buckets[index].start, nums[i]);
            buckets[index].end = Math.max(buckets[index].end, nums[i]);
        }
    }
    int res = 0;
    int pre = buckets[0].end;
    for (int i = 1; i < buckets.length; i++) {
        if (buckets[i].start != -1) {
            res = Math.max(res, buckets[i].start - pre);
            pre = buckets[i].end;
        }
    }
    return res;
}
```
<br>
<br>

###165 Compare Version Numbers

>Compare two version numbers version1 and version2.
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.
>
>You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.
>
>Here is an example of version numbers ordering:

0.1 < 1.1 < 1.2 < 13.37


**Solution 1**: use two pointers, compare each segment.

```java
   public int compareVersion(String version1, String version2) {
      int i = 0;
      int j = 0;
      while (i < version1.length() || j <= version2.length()) {
          int num1 = 0;
          int num2 = 0;
          while (i < version1.length() && version1.charAt(i) != '.') {
              num1 = num1 * 10 + version1.charAt(i) - '0';
              i++;
          }
          while (j < version2.length() && version2.charAt(j) != '.') {
              num2 = num2 * 10 + version2.charAt(j) - '0';
              j++;
          }
          if (num1 > num2) {
              return 1;
          } else if (num1 < num2) {
              return -1;
          } else {
              i++;
              j++;
          }
      }
      return 0;
    }
```

**Solution 2**: use split to get all segements then compare.

```java
 public int compareVersion(String version1, String version2) {
    String[] arr1 = version1.split("\\.");
    String[] arr2 = version2.split("\\.");
    int i = 0;
    while (i < arr1.length || i < arr2.length) {
        int num1 = (i < arr1.length) ? Integer.parseInt(arr1[i]) : 0;
        int num2 = (i < arr2.length) ? Integer.parseInt(arr2[i]) : 0;
        if (num1 < num2) {
            return -1;
        } else if (num1 > num2) {
            return 1;
        }
        i++;
    }
    return 0;
}
```


<br>
<br>


###166 Fraction to Recurring Decimal

>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
	
>If the fractional part is repeating, enclose the repeating part in parentheses.

	For example,

	Given numerator = 1, denominator = 2, return "0.5".
	Given numerator = 2, denominator = 1, return "2".
	Given numerator = 2, denominator = 3, return "0.(6)".

<br>

**Idea**: Just do the divide like what we normally do in math. 

For example, 3/7 

- quotient = 0, remainer = 3 , string = 0.
- **3 * 10/7** quotient = 4, remainder = 2; string = 0.4
- 2 * 10/ 7 quotient = 2, remainder = 6; string = 0.42
- 6 * 10/7 quotient = 8, remainder = 4; string = 0.428
- 4 * 10 /7 quotient = 5, remainder = 5; string = 0.4285
- 5 * 10/7 quotient = 7, remainder = 1, string = 0.42857
- 1 * 10/7 quotient = 1, remainder = 3, string = 0.428571
- **3 * 10/7**

Thus, we know the result is 0.(428571)

In order to know when the recuisive begins, we need to record the remainder at each iteration.

**Attention**

- 1)We need to do abs for both numbers, otherwise, there might be unnecessary "-" in the result string
- 2)abs(Integer.MIN_VALUE)
- 3)use hashmap to record the position of each remainder.


<br>
```java
   public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        boolean positive = ((numerator ^ denominator) >>> 31) == 0;
        if (!positive) {
            res.append("-");
        }
        long num = Math.abs((long) numerator);
        long denom = Math.abs((long) denominator);
        res.append(num / denom);
        if (num % denom == 0) {
            return res.toString();
        }
        num = num % denom;
        res.append(".");
        Map<Long, Integer> map = new HashMap<>();
        while (num != 0) {
            if (map.containsKey(num)) {
                res.insert(map.get(num), "(");
                res.append(")");
                return res.toString();
            }
            map.put(num, res.length());
            num *= 10;
            res.append(num / denom);
            num = num % denom;
        }
        return res.toString();
    }

```



<br>

<br>


###167 Two Sum II Input array is sorted

>Given an array of integers that is already **sorted in ascending order**, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are **not zero-based**.
You may assume that each input would have exactly one solution.

	Input: numbers={2, 7, 11, 15}, target=9
	Output: index1=1, index2=2

<br>

**Idea**: We can solve this problem use the second method in * [1 Two Sum](#1-two-sum). Just use two pointers, one at the beginning, one at the ending. Compare num[l] + num[r] and target. If the former is larger, then r--, if the latter is larger, l++.

```java
	public int[] twoSum(int[] numbers, int target){
		int[] res = new int[2];
		if(numbers == null || numbers.length <= 1) return res;
		int l = 0;
		int r = numbers.length -1;
		while(l < r){
			if(numbers[l] + numbers[r] == target){
				res[0] = l+1;
				res[1] = r+1;
				return res;
			}else if(numbers[l] + numbers[r] > target) r--;
			else l++;
		}
		return res;
	}

```


<br>

<br>

###168 Excel Sheet Column Title

>Given a positive integer, return its corresponding column title as appear in an Excel sheet.

<pre>
For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
</pre>

**Note**:

Here A = 1, Z = 26. It's not A = 0, Z = 25, thus we need to do n - 1 for divide and mod.

```java
public String convertToTitle(int n) {
    StringBuilder res = new StringBuilder();
    while (n > 0) {
        res.insert(0, (char) ((n - 1) % 26 + 'A'));
        n = (n - 1) / 26;
    }
    return res.toString();
}
```

<br>
<br>

###169 Majority Element

>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
>
>You may assume that the array is non-empty and the majority element always exist in the array.

**Solution 1: Sort, then pick the n/2th element, O(nlgn)**

```java
public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}
```

**Solution 2: voting algorithm**:

```java
    public int majorityElement(int[] nums) {
        int count = 1;
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (res == nums[i]) {
                count++;
            } else if (count > 0) {
                count--;
            } else if (count == 0) {
                res = nums[i];
            }
        }
        return res;
    }
```
<br>
<br>


###170 Two Sum III Data Structure Design

>Design and implement a TwoSum class. It should support the following operations: add and find.

>add - Add the number to an internal data structure.

>find - Find if there exists any pair of numbers which sum is equal to the value.

	For example,
	add(1); add(3); add(5);
	find(4) -> true
	find(7) -> false
	
<br>

**Idea**: How to design the structure is based on our needs. Remember in * [1 Two Sum](#1-two-sum) , the first method we use hashmap to record each number, and check if sum - number exist. If we do this the same way in this problem, we can use hashmap to record each number when add, and find the number use the method in * [1 Two Sum](#1-two-sum). 

**Time complexity** : add O(1) find O(n)

**Space**: O(n)

***What if we want to find sum in O(1)?***

We need to record the all possible sum when add new numbers. Then the time complexity would change to O(n). Also, we need a set to record the possible sum. So we need to increase the space. 
```java
	public class TwoSum{
		private Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		public void add(int number){
			if(map.containsKey(number)) map.put(number, map.get(number)+1);
			else map.put(number, 1);
		}
		
		public boolean find(int value){
			for(Integer i : map.keySet()){
				int remain = value -i;
				if(map.containsKey(remain)){
					if(remain == i && map.get(remain) < 2) continue;
					else return true;
				}
			}
			return false;
		}
	}
	
```



<br>

<br>

### 171 Excel Sheet Column Number

> Given a column title as appear in an Excel sheet, return its corresponding column number.
>
> For example:
>
> ```
>   A -> 1
>   B -> 2
>   C -> 3
>   ...
>   Z -> 26
>   AA -> 27
>   AB -> 28 
> ```

**Analysis:** 

for example: CABD

`C * 26 ^ 3 + A * 26 ^ 2 + B * 26 ^ 1 + D * 26 ^ 0`

which is

`3 * 26 ^ 3 + 1 * 26 ^ 2 + 2 * 26 ^ 1 + 4`

The following code takes O(N) time and O(1) space.

``` C
int titleToNumber(char *s) {
    int i = 0, val = 0, x = 1;
    
    if (s[0] == 0) { return 0; } // if empty string
    for (; s[i+1] != 0; i ++); // find the end of string
    
    for (; i >= 0; i --) {
        val += x * (s[i] - 'A' + 1);
        x *= 26; // if we use something like pow(26, length - i) it 
                 // will cause extra calculation and takes more time.
    }
    
    return val;
}
```

**Java solution**:

```java
public int titleToNumber(String s) {
    int res = 0;
    for (int i = 0; i < s.length(); i++) {
        res = res * 26 + (s.charAt(i) - 'A' + 1);
    }
    return res;
}
```

<br>
<br>

###172 Factorial Trailing zeros

>Given an integer n, return the number of trailing zeroes in n!.

>Note: Your solution should be in logarithmic time complexity.

**Idea**: To find the number of trailing zeroes, we need to find the number of 2 and number od 5. Since the number of 2 is more than number of 5, thus we only need to count the number of 5. 

Here is the solution.

```java
public int trailingZeroes(int n) {
  int res = 0;
  while (n > 0) {
      n /= 5;
      res += n;
  }
  return res;
}

```

<br>
<br>

###173 Binary Search Tree Iterator

>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

>Calling next() will return the next smallest number in the BST.

>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

**Idea**:

- 1) Here we maintain a stack, from top to bottom is the smallest to largest. Because we use the stack data structure, thus we visit the tree in the following order: right -> root -> left. In this way, the top element in the stack would be the smallest element. 

However, the space would be O(n). So how could we solve it in O(h) space? 

- 2) O(h) is the height of the tree, thus we can store an path of root to leaf element in stack. Because we need to return the next smallest element each time, thus we need to traverse the tree inorder. And each time we return the next successor

In this method, we fist store the left path of the tree in stack. When right child is not empty, we need to store the left path of its right child in stack until stack is empty. 


**Solution 1**: O(n) space, unqualified

```java
public class BinarySearchTreeIterator {
    Stack<Integer> stack; 
    public BSTIterator(TreeNode root) {
        stack = new Stack<Integer>();
        inorderReverse(stack, root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if (hasNext()) {
            return stack.pop();
        }
        return -1;
    }
    
    private void inorderReverse(Stack<Integer> stack, TreeNode root) {
        if (root == null) {
            return;
        }
        inorderReverse(stack, root.right);
        stack.push(root.val);
        inorderReverse(stack, root.left);
    }
}
```

<br>

**Solution 2**:

```java
public class BSTIterator {
  Deque<TreeNode> stack = new LinkedList<>();
  public BSTIterator(TreeNode root) {
      while (root != null) {
          stack.push(root);
          root = root.left;
      }
  }

  /** @return whether we have a next smallest number */
  public boolean hasNext() {
      return !stack.isEmpty();
  }

  /** @return the next smallest number */
  public int next() {
      if (!hasNext()) {
          return -1;
      }
      TreeNode res = stack.pop();
      TreeNode temp = res.right;
      while (temp != null) {
          stack.push(temp);
          temp = temp.left;
      }
      return res.val;
  }
}

```
<br>
<br>

###174 Dungeon Game

>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.
>
>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.
>
>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).
>
In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.
>
>
>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

<pre>
For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.

-2 (K)  -3  3
-5  -10 1
10  30  -5 (P)

Notes:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.

</pre>

**Idea**: DP, start from the bottom-right. dp[i][j] represents the minimum health point the knight should have to maintain alive when enter room room[i][j].

The Knight should have at least 1 point to maintain alive. 

Thus if knight go down from room[i][j] to room[i + 1][j], 

if room[i][j]  >= 0, then dp[i][j] = dp[i + 1][j] - room[i][j] > 0 ? dp[i + 1][j] - room[i][j] : 1; 

if room[i][j] < 0, dp[i][j] = dp[i + 1][j] - room[i][j]. 

Combine the above two case, dp[i][j] = Math.max(1, dp[i + 1][j] - room[i][j]) if knight go down.

For each step, the knight can go down or right(if not on the border), thus, dp[i][j] = Math.min(pointDown, pointRight);


```java
public int calculateMinimumHP(int[][] dungeon) {
    int[][] healthPoint = new int[dungeon.length][dungeon[0].length];
    for (int i = dungeon.length - 1; i >= 0; i--) {
        for (int j = dungeon[0].length - 1; j >= 0; j--) {
            if (i == dungeon.length - 1 && j == dungeon[0].length - 1) {
                healthPoint[i][j] = dungeon[i][j] >= 0 ? 1 : (1 - dungeon[i][j]);
            } else if (j == dungeon[0].length - 1) {
                healthPoint[i][j] = Math.max(1, healthPoint[i + 1][j] - dungeon[i][j]);
            } else if (i == dungeon.length - 1) {
                healthPoint[i][j] = Math.max(1, healthPoint[i][j + 1] - dungeon[i][j]);
            } else {
                int pointDown = Math.max(1, healthPoint[i + 1][j] - dungeon[i][j]);
                int pointRight = Math.max(1, healthPoint[i][j + 1] - dungeon[i][j]);
                healthPoint[i][j] = Math.min(pointDown, pointRight);
            }
        }
    }
    return healthPoint[0][0];
}
```


<br>
<br>

###179 Largest Number

>Given a list of non negative integers, arrange them such that they form the largest number.
>
>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.
>
>Note: The result may be very large, so you need to return a string instead of an integer.

<br>
<br>
	


###186 Reverse Words in a String II

>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.
>
>The input string does not contain leading or trailing spaces and the words are always separated by a single space.
>
>For example,
>Given s = "the sky is blue",
>return "blue is sky the".

>Could you do it in-place without allocating extra space?

**Idea**: Same with 151, actually, this problem is simpler. Because it don't have leading/trailing space and only single space between words.

```java
public void reverseWords(char[] arr) {
    reverse(arr, 0, arr.length - 1);
    int start = 0;
    for (int i = 0; i <= arr.length; i++) {
        if (i == arr.length || arr[i] == ' ') {
            reverse(arr, start, i - 1);
            start = i + 1;
        }
    }
}

private void reverse(char[] arr, int l, int r) {
   while (l < r) {
       swap(arr, l++, r--);
   }
}

private void swap(char[] arr, int i, int j) {
    char c = arr[i];
    arr[i] = arr[j];
    arr[j] = c;
}
```


<br>
<br>

###187 Repeated DNA Sequences

>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
>
>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
>
>For example,
>
>Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",
>
>Return:
>["AAAAACCCCC", "CCCCCAAAAA"].

**Idea**: convert String to integer use bit operation.

A - 0

C - 1

G - 2

T - 3

```java
public List<String> findRepeatedDnaSequences(String s) {
    Map<Integer, Integer> map = new HashMap<>();
    List<String> res = new ArrayList<>();
    char[] codes = new char[26];
    codes['C' - 'A'] = 1;
    codes['G' - 'A'] = 2;
    codes['T' - 'A'] = 3;
    for (int i = 0; i <= s.length() - 10; i++) {
        int val = 0;
        StringBuilder sb = new StringBuilder();
        for (int j = i; j < i + 10; j++) {
            val |= codes[s.charAt(j) - 'A'];
            val <<= 2;
            sb.append(s.charAt(j));
        }
        Integer count = map.get(val);
        if (null == count) {
            map.put(val, 1);
        } else if (count == 1) {
            res.add(sb.toString());
            map.put(val, count + 1);
        }
    }
    return res;
}
```


<br>
<br>

### 188 Best Time to Buy and Sell Stock IV

> Say you have an array for which the ith element is the price of a given stock on day i.

>Design an algorithm to find the maximum profit. You may complete **at most k transactions**.

>Note:

>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**First try:** Use the idea in [Best time to buy and sale stock iii](#123-best-time-to-buy-and-sell-stock-iii).
global[i][j]: denotes max profit, at most j transactions before day i:

 **global[i][j]=max(local[i][j],global[i-1][j])**

local[i][j]: denotes max profit, at most j transactions before day i, and last transaction is saled on day i: 

**local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)**

**Time complexity**: O(k * n)

**Space** : O(k)

Looks good, right? But we'll get out of memory error. Because in one test case, k = 100000. 

```java
  public int maxProfit(int k, int[] prices){
    if(prices == null || prices.length <= 1) return 0;
    int[] global = new int[k+1];
    int[] local = new int[k+1];
    for(int i = 1; i < prices.length; i++){
      int dif = prices[i] - prices[i-1];
      for(int j = k; j >= 1; j--){
        local[j] = Math.max(global[j-1] + Math.max(dif, 0), local[j] + dif);
        global[j] = Math.max(local[j], global[j]);
      }
    }
    return global[k];
  }
```

Handle TLE.



```java
public int maxProfit(int k, int[] prices) {
    if (k >= prices.length / 2) {
        //process as many transactions to reach max profits.
        int res = 0;
        for (int i = 1; i < prices.length; i++) {
            res += Math.max(0, prices[i] - prices[i - 1]);
        }
        return res;
    }
    
    int[] global = new int[k + 1];
    int[] local = new int[k + 1];
    for (int i = 1; i < prices.length; i++) {
        int dif = prices[i] - prices[i - 1];
        for (int j = k; j >= 1; j--) {
            local[j] = Math.max(global[j - 1] + Math.max(dif, 0), local[j] + dif);
            global[j] = Math.max(local[j], global[j]);
        }
    }
    return global[k];
}
```




<br>
<br>


###189 Rotate Array

>Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].


Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

**Idea**

- 1)Solution1:  In place. Reverse the array three times. (0, n-1) (0, k-1), (k-n-1)
- 2)Solution2:  Use an extra array, and copy to the right place.

<br>
**Solution1**:
```java
   public void rotate(int[] nums, int k) {
       if(nums == null || nums.length == 0 || k <= 0) return;
       k = k % nums.length;
       reverse(nums, 0, nums.length-1);
       reverse(nums, 0, k-1);
       reverse(nums, k, nums.length-1);
    }
    
    public void reverse(int[] nums, int left, int right){
        while(left < right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
```    
**Solution 2**:
```java
    public void rotate1(int[] nums, int k) {
        if(nums == null || nums.length == 0 || k <= 0) return;
        int[] result = new int[nums.length];
        k = k % nums.length;
        for(int i = 0; i < k; i++){
            result[i] = nums[nums.length -k + i];
        }
        for(int i = k; i < nums.length; i++){
            result[i] = nums[i-k];
        }
        for(int i = 0; i < nums.length; i++){
            nums[i] = result[i];
        }
    }
```

###190 Reverse Bits

>Reverse bits of a given 32 bits unsigned integer.

>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

>Follow up:

>If this function is called many times, how would you optimize it?

>Related problem: Reverse Integer


**Idea**: Like reverse a string, we swap each bit i with 32 -i -1 for 1/2 of the total bit length. 

```java

    public int reverseBits(int n) {
        int l = 0;
        int r = 31;
        while (l < r) {
            n = swap(n, l++, r--);
        }
        return n;
    }
    
    private int swap(int n, int i, int j) {
        int bitI = (n >> i) & 1;
        int bitJ = (n >> j) & 1;
        if ((bitI ^ bitJ) == 1) {
            n ^= (1 << i) | (1 << j);
        }
        return n;
    }

```

**Another solution in c++**: If the binary of number  a is  10001111 we can represent it as 2 ^ 7 + 2 ^ 3 + 2 ^2 + 2 ^ 1 + 2 ^ 0. Thus we use mod 2 and * 2 to reserve this number. Because in java int is not unsigned, so use this method in java have sign problem.

```c++

	uint32_t reverseBits(uint32_t n) {
        if(n == 0) return 0;
        int res = 0;
        for(int i = 0; i < 32; i++){
            int mod = n % 2;
            n = n >> 1;
            res = (res << 1) + mod;
        }
        return res;
    }


```



<br>

<br>


###191 Number of 1 Bits

>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

>For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.


**Idea**: There are three ways to deal with this problem.

- 1) n & 1, if result is 1, count ++, n >>>= 1, till n = 0; ** Remember use >>>**
- 2) use n = n & n-1 to remove the rightmost 1. **Time complexity is O(number od 1s)**
- 3) use left shift. 



**Solution1 : Java code**:



```java
    public int hammingWeight(int n) {
        if(n == 0) return 0;
        int res = 0;
        while(n != 0){
            if((n & 1) != 0) res++;
            n = n >>> 1;
        }
        return res;
    }

```

**Solution 2: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
          int res = 0;
          while(n > 0){
        	  n &= n-1;
        	  res++;
          }
          return res;
    }

```

**Solution 3: c++ code**:

```c++

    int hammingWeight(uint32_t n) {
      int res = 0;
      unsigned int flag = 1;
      while(flag){
         if(n&flag){
            res++;
        }
        flag = flag << 1;
      }
      return res;
    }

```


<br>
<br>

###198 House Robber


>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.


**Idea**: It's an one dimensional dp problem, like the **Best time to buy and sell stocks. We need to find the maximum nonadjacent sum. Thus, for each room our choice is either rob or not rob, based on the previous room, and we need to mantain the max money on the current. If we want to rob this room, the condition is that we don't rob the previous room. Thus robYes = robNo + room[i]. And if we don't rob this room, then we can choose the max from previous robYes and robNo. See details on the following code.

 

**Solution 1 **:


```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int robYes = 0;
        int robNo = 0;
        for(int money : num){
            int temp = robNo;
            robNo = Math.max(robYes, robNo);
            robYes = temp + money;
        }
        return Math.max(robYes, robNo);
    }


```



**Solution 2**:

```java

    public int rob(int[] num) {
        if(num == null || num.length == 0) return 0;
        int even = 0;
        int odd = 0;
        for(int i = 0; i < num.length; i++){
            if(i % 2 == 0){
                even += num[i];
                even = Math.max(even, odd);
            }else{
                odd += num[i];
                odd = Math.max(even, odd);
            }
        }
        return Math.max(odd, even);
    }

```


<br>
<br>



###199 Binary Tree Right Side View


>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

<pre>

For example:
Given the following binary tree,
   1         
 /   \
2     3         
 \     \
  5     4      
You should return [1, 3, 4].

</pre>

**Idea**: This problem is similar to the **breadth first search** of a binary search tree. If you can figure out this, the problem is easy. We use a queue, more precisely a deque to store element of each level. Then each time we store the rightmost element in each level to the result list. 


**Java code**:


```java

public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null) {
        return res;
    }
    Deque<TreeNode> deque = new LinkedList<TreeNode>();
    deque.offer(root);
    while (!deque.isEmpty()) {
        TreeNode cur = null;
        for (int i = 0, size = deque.size(); i < size; i++) {
            cur = deque.pollLast();
            if (cur.right != null) {
                deque.addFirst(cur.right);
            }
            if (cur.left != null) {
                deque.addFirst(cur.left);
            }
            if(i == 0){
                res.add(cur.val);
            } 
        }
    }
    return res;
}

```

<br>
<br>


###200 Number of Islands

>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

<pre>
Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3


</pre>


**Idea**: Basically, the idea is similar to flood fill or bfs/dfs of graph. Each time we visited a land, we marked it as visited, then go north/west/south/east. When dfs ends, that means we have visited every land of a certain island. In the same way, we can count the number of all islands.


**Java code**:

```java
public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int res = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1' && visited[i][j] == false){
                    dfs(visited, grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }
    
    public void dfs(boolean[][] visited, char[][] grid, int i, int j){
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)
            return;
        if(visited[i][j] == true || grid[i][j] == '0')
            return;
        visited[i][j] = true;
        dfs(visited, grid, i-1, j);
        dfs(visited, grid, i, j-1);
        dfs(visited, grid, i+1, j);
        dfs(visited, grid, i, j+1);
    }

```


<br>


**Related**: Longest 1s

>Given an array containing only 0s and 1s, find the length of the longest subarray of consecutive 1s.

**Idea**: One-d dp. 


```java
  public int longest(int[] array) {
    int[] arr = new int[array.length + 1];
    int res = 0;
    for (int i = 1; i <= array.length; i++) {
      if (array[i - 1] == 0) {
        arr[i] = 0;
      } else {
        arr[i] = arr[i - 1] + 1;
        res = Math.max(res, arr[i]);
      }
    }
    return res;
  }

```

<br>

**Related**: Longest cross of 1s

>Given a 2d grid map of '1's and 0s, find the largest cross which contains only 1s, with the same arm lengths and the four arms joining at the central point.


**Idea**: For each row and columns, calcualte the longest 1s, then we take the minimum of left/right/up/down.



```java
  public int largest(int[][] matrix) {
    int m = matrix.length;
    int n = m > 0 ? matrix[0].length : 0;
    //calculate left
    int[][] left = new int[m][n + 1];
    for (int i = 0; i < m; i++) {
      for (int j = 1; j <= n; j++) {
        if (matrix[i][j - 1] == 0) {
          left[i][j] = 0;
        } else {
          left[i][j] = left[i][j - 1] + 1;
        }
      }
    }
    //calculate right
    int[][] right = new int[m][n + 1];
    for (int i = 0; i < m; i++) {
      for (int j = n - 1; j >= 0; j--) {
        if (matrix[i][j] == 0) {
          right[i][j] = 0;
        } else {
          right[i][j] = right[i][j + 1] + 1;
        }
      }
    }
    
    //calculate up
    int[][] up = new int[m + 1][n];
    for (int i = 0; i < n; i++) {
      for (int j = 1; j <= m; j++) {
        if (matrix[j - 1][i] == 0) {
          up[j][i] = 0;
        } else {
          up[j][i] = up[j - 1][i] + 1;
        }
      }
    }
    
    //calculate down
    int[][] down = new int[m + 1][n];
    for (int i = 0; i < n; i++) {
      for (int j = m - 1; j >= 0; j--) {
        if (matrix[j][i] == 0) {
          down[j][i] = 0;
        } else {
          down[j][i] = down[j + 1][i] + 1;
        }
      }
    }
    
    int res = 0;
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        int minRow = Math.min(left[i][j + 1], right[i][j]);
        int minCol = Math.min(up[i + 1][j], down[i][j]);
        res = Math.max(res, Math.min(minRow, minCol));
      }
    }
    return res;
  }

```

<br>

**Related**: Largest X Of 1s

```java
  public int largest(int[][] matrix) {
    int m = matrix.length;
    int n = m > 0 ? matrix[0].length : 0;
    //calculate left
    int[][] left = new int[m][n];
    int[][] up = new int[m][n];
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (matrix[i][j] == 1) {
          left[i][j] = getNum(left, i - 1, j - 1, m, n) + 1;
          up[i][j] = getNum(up, i - 1, j + 1, m, n) + 1;
        }
      }
    }
    //calculate down
    int[][] right = new int[m][n];
    int[][] down = new int[m][n];
    for (int i = m - 1; i >= 0; i--) {
      for (int j = n - 1; j >= 0; j--) {
        if (matrix[i][j] == 1) {
          right[i][j] = getNum(right, i + 1, j + 1, m, n) + 1;
          down[i][j] = getNum(down, i + 1, j - 1, m, n) + 1;
        }
      }
    }
    
    int res = 0;
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        int minRow = Math.min(left[i][j], right[i][j]);
        int minCol = Math.min(up[i][j], down[i][j]);
        res = Math.max(res, Math.min(minRow, minCol));
      }
    }
    return res;
  }
  
  private int getNum(int[][] arr, int i, int j, int m, int n) {
    return i < 0 || j < 0 || i >= m || j >= n ? 0 : arr[i][j];
  }
```
<br>
<br>


###201 Bitwise AND of Numbers Range

>Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

>For example, given the range [5, 7], you should return 4.

**Idea**: what we need to do is to  find the similar bits of of m and n on the left side. For eample, if n = 111, m = 101, we need to find the similar part on the left side of m and n. Similar left side + Fill 0s on the right side is the result.


**Java code**:


```java


    public int rangeBitwiseAnd(int m, int n) {
        int count = 0;
        while(m != n){
            m >>= 1;
            n >>= 1;
            count++;
        }
        return m << count;
    }

```

Another solution:

```java
public int rangeBitwiseAnd(int m, int n) {
    while (m < n) {
        n = n & (n - 1);
    }
    return n;
}
```

<br>
<br>

###202 Happy Number

>Write an algorithm to determine if a number is "happy".

>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

<pre>

Example: 19 is a happy number

1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

</pre>


**Idea**:If it is not a happy number, then it will have a circle, that is, when we continue calculate, we will return to a certain value. So we need to save the history number. When we find that a number has existed before, then it is not a happy number. 

**Java code**:

```java

    public boolean isHappy(int n) {
        if(n <= 0) return false;
        Set<Integer> set = new HashSet<Integer>();
        set.add(n);
        while(n != 1){
            int temp = 0;
            while(n != 0){
                temp += (n%10) * (n%10);
                n = n/10;
            }
            if(set.contains(temp)) return false;
            set.add(temp);
            n = temp;
        }
        return true;
    }

```

In python, we can use the string convertion for this problem:

``` python
class Solution:
    # @param {integer} n
    # @return {boolean}
    def isHappy(self, n):
        m = n
        mem = set()
        while m not in mem:
            mem.add(m)
            m = sum([int(x) ** 2 for x in str(m)])
            if m == 1:
                return True
        return False
```

<br>
<br>


### 203 Remove Linked List Elements

> Remove all elements from a linked list of integers that have value val.
>
> Example
> Given: `1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6`
> Return: `1 --> 2 --> 3 --> 4 --> 5`

The `head` of this problem contains value. If it doesn't contains the value,
declaration of `p` and `q` to `p, q = head, head->next`.

Becareful if:
- The node is `head`
- The node is `tail`, which means `.next = None`
- How to move the pointers ahead.

**Java code**:

```java

    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return head;
        ListNode fakeHead = new ListNode(-1);
        fakeHead.next = head;
        ListNode pre = fakeHead;
        while(head != null){
            if(head.val == val){
                pre.next = head.next;
                head = pre.next;
            }else{
                pre = head;
                head = head.next;
            }
        }
        return fakeHead.next;
    }

```
**python**:

``` python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @param {integer} val
    # @return {ListNode}
    def removeElements(self, head, val):
        if not head:
            return None
            
        p, q = None, head
            
        while q is not None:
            if q.val == val:
                if p is None:  # q is head  
                    head = q.next
                else:
                    p.next = q.next
                q = q.next
            else:
                p, q = q, q.next
                
        return head
```


###204 Count Primes

>Description:Count the number of prime numbers less than a non-negative number, n

**Idea**: The straight forward way is that we check each number, if it is prime, resut++.

So at first try code like this:

```java 

public int countPrimes(int n) {
    if(n <= 2) {
        return 0;
    }
    boolean[] notPrime = new boolean[n];
    for (int i = 2; i <= n / 2; i++) {
        if (!notPrime[i]) {
            for (int j = i + i; j < n; j += i) {
                notPrime[j] = true;
            }
        }
    }
    int res = 1;
    for (int i = 3; i < n; i++) {
        res += (notPrime[i] ? 0 : 1);
    }
    return res;
}


```


***There are a few places can be modified.***

1) the outer loop, i can be changed to sqrt(n)

2) when count the primes in the last loop, i can be changed to i+2

3) the inside loop, i can be changed to i*i

then the changed code is below:


```java

    public int countPrimes(int n) {
        if(n <= 2) {
            return 0;
        }
        boolean[] prime = new boolean[n];
        for(int i = 2, sqr = (int)Math.sqrt(n); i <= sqr; i++ ) {
            // if i is prime
            if(!prime[i]){
                for(int j = i*i; j < n; j += i) {
                    prime[j] = true;
                }
            }
        }
        int res = 1;
        for(int i = 3; i < n; i += 2){
            if(!prime[i]){
                res++;
            }
        }
        return res;
    }

```

From the suggestions of friends, I realized that I can use bitset to save space.  If you are not familiar with bitset like me, check this [link](https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html) The code is below:


```java


 public int countPrimes(int n) {
        if(n <= 2) {
            return 0;
        }
        BitSet set = new BitSet();
        for(int i = 2, sqr = (int)Math.sqrt(n); i <= sqr; i++ ) {
            // if i is prime
            if(!set.get(i)){
                for(int j = i*i; j < n; j += i) {
                    set.set(j);
                }
            }
        }
        set.set(0);
        set.set(1);
        return n - set.cardinality();
    }


```
<br>

<br>


###205 Isomorphic Strings

>Given two strings s and t, determine if they are isomorphic.

>Two strings are isomorphic if the characters in s can be replaced to get t.

>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

>For example,

>Given "egg", "add", return true.

>Given "foo", "bar", return false.

>Given "paper", "title", return true.

>Note:
>You may assume both s and t have the same length.


**Idea**:

- method 1: Use one hashmap, check their map relation. Since **we need to use the containsvalue, it takes O(n)**, thus the worst case time complexity is O(n ^ 2)

- method 2: Use two hashmap, store the map relation of two string. Time: O(n). We need more space. 

- method 3: if we only consider Ascii, then we can use array to replace hashmap in method 2.



**Java code**:

*Method 1*:

```java

    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> map = new HashMap<Character, Character>();
        for(int i = 0; i < s.length(); i++) {
           char cs = s.charAt(i);
           char ct = t.charAt(i);
           if(!map.containsKey(cs)) {
               if(map.containsValue(ct)) {
                   return false;
               }
               map.put(cs, ct);
           } else {
               if(map.get(cs) != ct) {
                   return false;
               }
           }
        }
        return true;
    }

```

*Method 2*:

```java

    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> maps = new HashMap<Character, Character>();
        Map<Character, Character> mapt =  new HashMap<Character, Character>();
        for(int i = 0; i < s.length(); i++) {
           char cs = s.charAt(i);
           char ct = t.charAt(i);
           maps.putIfAbsent(cs, ct);
           mapt.putIfAbsent(ct, cs);
           if(maps.get(cs) != ct || mapt.get(ct) != cs) {
               return false;
           }
        }
        return true;
    }

```


*Method 3*:


```java


    public boolean isIsomorphic2(String s, String t) {
        int[] sArr = new int[256];
        int[] tArr = new int[256];
        for(int i = 0; i < s.length(); i++) {
            if(sArr[s.charAt(i)] != tArr[t.charAt(i)]) {
                return false;
            }
            sArr[s.charAt(i)] = i+1;
            tArr[t.charAt(i)] = i+1;
        }
        return true;
    }

```

<br>
<br>

###206 Reverse Linked List

> Reverse a singly linked list.


**Idea**: Really straight forward. Let the next node pointer to the previous node until to the end of the list. Just need to take care of the null pointer. 
**Iterative**:

```java

    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }

```

<br>
**Recursive**:

```java
  public ListNode reverse(ListNode head) {
    if (head == null || head.next == null) {
      return head;
    }
    ListNode res = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return res;
  }
```

<br>
<br>

###207 Course Schedule

>There are a total of n courses you have to take, labeled from 0 to n - 1.

>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

>For example:

>2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

>2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

>Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

**Idea**: 

- 1) solution 1: This problem is a typical example of topological sort. We can firt create the adjacent matrix, then do topological sort to check if all courses are finished. 

- 2) solution 2: For each edge we can use a stack to check if there is a cycle. If cycle exist, then we can not finish all the courses. 


**Java Solution**:

```java
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites == null || prerequisites.length == 0 || numCourses <= 0) {
            return true;
        }
        int[][] adj = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            int in = prerequisites[i][1];
            int out = prerequisites[i][0];
            if (adj[in][out] == 0) {
                inDegree[out]++;
            }
            adj[in][out] = 1;
        }
        
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            count++;
            for (int i = 0; i < numCourses; i++) {
                if (adj[temp][i] == 1) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) {
                        zeroDegrees.offer(i);
                    }
                }
            }

        }
        
        return count == numCourses;
    }

```

<br>
<br>
<br>



###208 Implement Trie Prefix Tree

>Implement a trie with insert, search, and startsWith methods.

>Note:You may assume that all inputs are consist of lowercase letters a-z.

**Idea**: If you are not familiar with Trie, look at my blog [Trie](http://wishyouhappy.github.io/2015/05/27/Trie/)

**Solution1**: the most original and simple method

```java
class TrieNode {
    // Initialize your data structure here.
    public TrieNode[] edges;
    public boolean isLeaf; //check if a trienode is a leaf node
    public TrieNode() {
        // all possible sons
        edges = new TrieNode[26];
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        if (word == null || word.length() == 0) {
            return;
        }
        root = insert(root, word, 0);
    }
    
    public TrieNode insert(TrieNode node, String word, int len) {
        if (node == null) {
            node = new TrieNode();
        }
        if (len == word.length()) {
            node.isLeaf = true;
            return node;
        }
        int pos = word.charAt(len) - 'a';
        node.edges[pos] = insert(node.edges[pos], word, len + 1);
        return node;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
       TrieNode temp = searchHelper(root, word, 0);
       return temp == null ? false : temp.isLeaf;    
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode temp = searchHelper(root, prefix, 0);
        return temp == null ? false : true;
    }
    
    public TrieNode searchHelper(TrieNode node, String word, int len) {
        if (node == null) {
            return null;
        }
        if (len == word.length()) {
            return node;
        }
        int pos = word.charAt(len) - 'a';
        return searchHelper(node.edges[pos], word, len + 1);
    }
}
```


**Solution2**: using hashmap

```java
class TrieNode {
    // Initialize your data structure here.
    public Map<Character, TrieNode> edges;
    public boolean isLeaf; //check if a trienode is a leaf node
    public TrieNode() {
        edges = new HashMap<Character, TrieNode>(); // all possible sons
    }
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
   public void insert(String word) {
        Map<Character, TrieNode> edges = root.edges;
        for(int i=0; i<word.length(); i++){
            char c = word.charAt(i);
            TrieNode current = null;
            if(edges.containsKey(c)){
                current = edges.get(c);
            }else{
                current = new TrieNode();
                edges.put(c, current);
            }
            edges = current.edges;
            if (i == word.length() - 1) {
                current.isLeaf = true;
            }
        }
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode res = searchHelper(word);
        return res == null ? false : res.isLeaf;
    }


    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
       TrieNode res = searchHelper(prefix);
       return res == null ? false : true;
    }
    
    private TrieNode searchHelper(String word) {
        Map<Character, TrieNode> edges = root.edges;
        TrieNode res = null;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (edges.containsKey(c)) {
                res = edges.get(c);
                edges = res.edges;
            } else {
                return null;
            }
        }
        return res;
    }
    
}
```





<br>
<br>

###209 Minimum Size Subarray Sum

> Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.

>For example, given the array [2,3,1,2,4,3] and s = 7,
>the subarray [4,3] has the minimal length under the problem constraint.**Subarray should be contiguous**.

**More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).**

**Idea**:  

- solution 1 : Sliding window. Use two pointers to record the beginning and the end of the subarray. If current sum >= s then update the min length of subarray and move the left pointer of the sliding window one step right. Otherwise, move the right pointer one step right and update the current sum. Time complexity is O(n)

- solution 2: nlgn solution. We can use binary search obtain lgn but the array should be sorted. Since the subarray should be contiguous,
thus we shouldn't sort the array. Then how could we implement the nlgn solution? 

**We need to get the minimum size subarray sum, we can sum the elements before i, then we can get a sorted array and apply binary search**
See details in the code below. 


**Solution 1**: O(n) time complexity

```java
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0 || s == 0) {
            return 0;
        }
        int start = 0;
        int end = 0;
        int res = Integer.MAX_VALUE;
        int sum = nums[0];
        while (end < nums.length  && start <= end) {
            if (sum < s) {
                end++;
                if (end < nums.length) {
                    sum += nums[end];
                }
            }
            if (sum >= s) {
                res = Math.min(end - start + 1, res);
                sum -= nums[start++];
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
```

**Solution 2**: O(nlgn) time complexity

```java
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0 || s == 0) {
            return 0;
        }
        int[] sums = new int[nums.length];
        sums[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            sums[i] = sums[i-1] + nums[i];
        }
        if (sums[sums.length - 1] < s) {
            return 0;
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            int l = i;
            int r = nums.length - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (sums[mid] - sums[i] + nums[i] >= s) {
                    res = Math.min(res, mid - i + 1);
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
```


<br>
<br>

###210 Course Schedule II 

>There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.


<br>

**Idea**: same method with Course Schedule I. Use topological sort

**Accept solution**: Time complexity: O(V + E)

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0) {
            return null;
        }
        int[] res = new int[numCourses];
        if (prerequisites == null || prerequisites.length == 0) {
            for (int i = 0; i < numCourses; i++) {
                res[i] = i;
            }
            return res;
        }
        int[] inDegree = new int[numCourses];
        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        for (int i = 0; i < prerequisites.length; i++) {
            int key = prerequisites[i][1];
            int val = prerequisites[i][0];
            if (!map.containsKey(key)) {
               map.put(key, new ArrayList<Integer>());
            }
            map.get(key).add(val);
            inDegree[val]++;
        }
        
       
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            res[count++] = temp;
            if (map.get(temp) != null) {
                for (Integer i: map.get(temp)) {
                    if (inDegree[i] >= 1) {
                        inDegree[i]--;
                        if (inDegree[i] == 0) {
                            zeroDegrees.offer(i);
                        }
                    }
                }
            }
        }
        
        return count == numCourses ? res : new int[0];
    }
```

**Here is an memory limit exceeded solution**:

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0) {
            return null;
        }
        int[] res = new int[numCourses];
        if (prerequisites == null || prerequisites.length == 0) {
            for (int i = 0; i < numCourses; i++) {
                res[i] = i;
            }
            return res;
        }
        int[][] adj = new int[numCourses][numCourses];
        int[] inDegree = new int[numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            int in = prerequisites[i][1];
            int out = prerequisites[i][0];
            if (adj[in][out] == 0) {
                inDegree[out]++;
            }
            adj[in][out] = 1;
        }
        
       
        Queue<Integer> zeroDegrees = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                zeroDegrees.offer(i);
            }
        }
        
        int count = 0;
        while (!zeroDegrees.isEmpty()) {
            int temp = zeroDegrees.poll();
            res[count++] = temp;
            
            for (int i = 0; i < numCourses; i++) {
                if (adj[temp][i] == 1) {
                    inDegree[i]--;
                    if (inDegree[i] == 0) {
                        zeroDegrees.offer(i);
                    }
                }
            }

        }
        
        return count == numCourses ? res : new int[0];
    }
```


<br>
<br>

###211 Add and Search Word - Data structure design

>Design a data structure that supports the following two operations:

<pre>

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.
</pre>

**Idea** based on trie

```java
class TrieNode {
    public TrieNode[] edges;
    public boolean isLeaf;
    public TrieNode() {
        edges = new TrieNode[26];
    }
}
public class WordDictionary {
    TrieNode root;
    
    public WordDictionary () {
        root = new TrieNode();
    }
    // Adds a word into the data structure.
    public void addWord(String word) {
        root = insert(root, word, 0);
    }
    private TrieNode insert(TrieNode node, String word, int index) {
        if (node == null) {
            node = new TrieNode();
        }
        if (index == word.length()) {
            node.isLeaf = true;
            return node;
        }
        int pos = word.charAt(index) - 'a';
        node.edges[pos] = insert(node.edges[pos], word, index + 1);
        return node;
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    public boolean search(String word) {
        return searchWord(root, word, 0);
    }
    private boolean searchWord(TrieNode node, String word, int index) {
        if (index == word.length()) {
            return node.isLeaf;
        }
        if (word.charAt(index) == '.') {
            for (TrieNode n : node.edges) {
                if (n != null && searchWord(n, word, index + 1)) {
                    return true;
                }
            }
        } else {
            int pos = word.charAt(index) - 'a';
            return node.edges[pos] != null && searchWord(node.edges[pos], word, index + 1);
        }
        return false;
    }
}
```


<br>
<br>

###212 Word Search II

>Given a 2D board and a list of words from the dictionary, find all words in the board.

<pre>
Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].
Note:
You may assume that all inputs are consist of lowercase letters a-z.
</pre>


**TLE** HashSet

```java
    public List<String> findWords(char[][] board, String[] words) {
        Set<String> dict = new HashSet<>();
        for (String s : words) {
            dict.add(s);
        }
        Set<String> res = new HashSet<>();
        boolean[][] visited = new boolean[board.length][board[0].length];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                dfs(board, visited, dict, i, j, "", res);
            }
        }
        return new ArrayList<String>(res);
    }
    private void dfs(char[][] board, boolean[][] visited, Set<String> dict, int i, int j, String s, Set<String> res) {
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j]) {
            return;
        }
        s += board[i][j];
        if (dict.contains(s)) {
            res.add(s);
        }
        visited[i][j] = true;
        dfs(board, visited, dict, i - 1, j, s, res);
        dfs(board, visited, dict, i + 1, j, s, res);
        dfs(board, visited, dict, i, j - 1, s, res);
        dfs(board, visited, dict, i, j + 1, s, res);
        visited[i][j] = false;
    }
```

**Accepted**: trie + dfs

```java
    if (!trie.startsWith(s)) {
        return;
    }
```

By using the above check, we can avoid and cut unnecessary dfs. Otherwise, we also get TLE use trie.

```java
public List<String> findWords(char[][] board, String[] words) {
    Trie trie = new Trie();
    for (String s : words) {
        trie.insert(s);
    }
    Set<String> res = new HashSet<>();
    boolean[][] visited = new boolean[board.length][board[0].length];
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs(board, visited, trie, i, j, "", res);
        }
    }
    return new ArrayList<String>(res);
}
private void dfs(char[][] board, boolean[][] visited, Trie trie, int i, int j, String s, Set<String> res) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j]) {
        return;
    }
    s += board[i][j];
    if (!trie.startsWith(s)) {
        return;
    }
    if (trie.search(s)) {
        res.add(s);
    }
    visited[i][j] = true;
    dfs(board, visited, trie, i - 1, j, s, res);
    dfs(board, visited, trie, i + 1, j, s, res);
    dfs(board, visited, trie, i, j - 1, s, res);
    dfs(board, visited, trie, i, j + 1, s, res);
    visited[i][j] = false;
}
```

<br>
<br>

###213 House Robber II

>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, **all houses at this place are arranged in a circle**. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.
>
>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

**Idea**: Two cases: rob the first house or not rob the first house.

```java
public int rob(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }
    return Math.max(robLine(nums, 0, nums.length - 2), robLine(nums, 1, nums.length - 1));
}

private int robLine(int[] nums, int start, int end) {
    int robYes = 0;
    int robNo = 0;
    for (int i = start; i <= end; i++) {
        int temp = robNo;
        robNo = Math.max(robNo, robYes);
        robYes = temp + nums[i];
    }
    return Math.max(robYes, robNo);
}
```

<br>
<br>

###214 Shortest Palindrome

>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.
>
>For example:
>
>Given "aacecaaa", return "aaacecaaa".
>
>sGiven "abcd", return "dcbabcd".


**Brute force** TLE:
```java
public String shortestPalindrome(String s) {
    int i = 0;
    int r = s.length() - 1;
    int j = r;
    while (i < j) {
        if (s.charAt(i) == s.charAt(j)) {
            i++;
            j--;
        } else {
            i = 0;
            r--;
            j = r;
        }
    }
    return new StringBuilder(s.substring(r + 1)).reverse().toString() + s;
}
```

**Accepted**:

```java
public String shortestPalindrome(String s) {
    int i = 0;
    for (int j = s.length() - 1; j >= 0; j--) {
        if (s.charAt(j) == s.charAt(i)) {
            i++;
        }
    }
    if (i == s.length()) {
        return s;
    }
    String suffix = s.substring(i);
    return new StringBuilder(suffix).reverse().toString() + shortestPalindrome(s.substring(0, i)) + suffix;
}
```

<br>
<br>

###215 Kth Largest Element in an Array

>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
>
>For example,
>Given [3,2,1,5,6,4] and k = 2, return 5.
>
>Note: 
>You may assume k is always valid, 1 ≤ k ≤ array's length.

**Idea** quicksort, pivot. Each time cut unnecessary parts in the array.

The cutting logic is as follows:

```java
int pivot = pivot(nums, start, end);
if (k == end - pivot + 1) {
    return nums[pivot];
} else if (k < end - pivot + 1) {
    return quicksort(nums, k, pivot + 1, end);
} else {
    return quicksort(nums, k - (end - pivot + 1), start, pivot - 1);
}
```

**Solution**:

```java
public int findKthLargest(int[] nums, int k) {
    return quicksort(nums, k, 0, nums.length - 1);
}
private int quicksort(int[] nums, int k, int start, int end) {
    int pivot = pivot(nums, start, end);
    if (k == end - pivot + 1) {
        return nums[pivot];
    } else if (k < end - pivot + 1) {
        return quicksort(nums, k, pivot + 1, end);
    } else {
        return quicksort(nums, k - (end - pivot + 1), start, pivot - 1);
    }
}
private int pivot(int[] nums, int start, int end) {
    int pivot = start + (end - start) / 2;
    swap(nums, pivot, end);
    int i = start;
    int j = end - 1;
    while (i <= j) {
        while (i <= end && nums[i] < nums[end]) {
            i++;
        }
        while (j >= start && nums[j] >= nums[end]) {
            j--;
        }
        if (i < j) {
            swap(nums, i++, j--);
        }
    }
    swap(nums, i, end);
    return i;
}
private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```



<br>
<br>

###216 Combination Sum III

> Find all possible combinations of k numbers that add up to a number n, given that only numbers from **1 to 9** can be used and each combination should be a **unique set of numbers**.

>Ensure that numbers within the set are **sorted in ascending order**.

<pre>

Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]

</pre>


**Idea**: This problem is the combination of [40 Combination Sum II](https://github.com/wishyouhappy/leetcode#40-combination-sum-ii) and [77 Combinations](https://github.com/wishyouhappy/leetcode#77-combinations). In the recursion termination condition, we need to take care of bothe the sum and number of elements. 


**Solution**:


```java
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (k * 9 < n) {
            return res;
        }
        combinationSum3(k, n, 1, res, new ArrayList<Integer>(), 0);
        return res;
    }
    
    public void combinationSum3(int k, int n, int start, List<List<Integer>> res, List<Integer> item, int sum) {
        if (item.size() == k && sum == n) {
            res.add(new ArrayList<Integer>(item));
            return;
        } 
        if (sum >= n || item.size()>= k) {
            return;
        }
        for (int i = start; i <= 9; i++) {
            item.add(i);
            combinationSum3(k, n, i + 1, res, item, sum + i);
            item.remove(item.size() - 1);
        }
       
    }
```
<br>
<br>

###217 Contains Duplicate

>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

```java
public boolean containsDuplicate(int[] nums) {
    if (nums.length <= 1) {
        return false;
    }
    Set<Integer> set = new HashSet<>();
    for (int i : nums) {
        if (set.contains(i)) {
            return true;
        }
        set.add(i);
    }
    return false;
}
```

<br>
<br>

###218-the-skyline-problem

> [Problem detail](https://leetcode.com/problems/the-skyline-problem/)

**Solution 1**: sort + priorityqueue. 

- Get lines of all the buildings.Each line contains x coordinate, y coordinate and flag indicates if it is the left outline of building or right outline.

- Sort lines. This part is important. The sort rules is below. Because for the right outline has the same x we print only the lower point. So when !el1.isLeft && !el2.isLeft, we put the lower line before the higher line. 

```java
 public int compare(Skyline el1, Skyline el2) {
     if (el1.x != el2.x) {
         return el1.x - el2.x;
     } else if (el1.isLeft && el2.isLeft) {
         return el2.y - el1.y;
     } else if (!el1.isLeft && !el2.isLeft) {
         return el1.y - el2.y;
     } else {
         return el1.isLeft ? -1 : 1;
     }
 }
```

**Code**: 

```java
public class Solution {
    class Skyline {
        int x;
        int y;
        boolean isLeft;
        public Skyline(int x, int y, boolean isLeft) {
            this.x = x;
            this.y = y;
            this.isLeft = isLeft;
        }
    }
    public List<int[]> getSkyline(int[][] buildings) {
        List<int[]> res = new ArrayList<>();
        if (buildings == null || buildings.length == 0 || buildings[0].length == 0) {
            return res;
        }
        List<Skyline> lines = new ArrayList<>();
        for (int[] b : buildings) {
            lines.add(new Skyline(b[0], b[2], true));
            lines.add(new Skyline(b[1], b[2], false));
        }
        sortLines(lines);
        getPoints(lines, res);
        return res;  
    }
    private void getPoints(List<Skyline> lines, List<int[]> res) {
        PriorityQueue<Integer> heap = new PriorityQueue<>(10, Collections.reverseOrder());
        for (Skyline line : lines) {
            if (line.isLeft) {
                if (heap.isEmpty() || line.y > heap.peek()) {
                    res.add(new int[] {line.x, line.y});
                }
                heap.add(line.y);
            } else {
                heap.remove(line.y);
                if (heap.isEmpty()) {
                    res.add(new int[] {line.x, 0});
                } else if (line.y > heap.peek()){
                    res.add(new int[] {line.x, heap.peek()});
                }
            }
        }
    }
    private void sortLines(List<Skyline> lines) {
        Collections.sort(lines, new Comparator<Skyline>() {
           @Override
           public int compare(Skyline el1, Skyline el2) {
               if (el1.x != el2.x) {
                   return el1.x - el2.x;
               } else if (el1.isLeft && el2.isLeft) {
                   return el2.y - el1.y;
               } else if (!el1.isLeft && !el2.isLeft) {
                   return el1.y - el2.y;
               } else {
                   return el1.isLeft ? -1 : 1;
               }
           }
        });
    }
}
```

**Solution 2**: divide and conquer, merge buildings recursively. 

```java
public List<int[]> getSkyline(int[][] buildings) {
    if (buildings == null || buildings.length == 0 || buildings[0].length == 0) {
        return new ArrayList<>();
    }
    return mergeSkyline(buildings, 0, buildings.length - 1);  
}
private List<int[]> mergeSkyline(int[][] buildings, int l, int r) {
    if (l == r) {
        List<int[]> res = new ArrayList<>();
        res.add(new int[] {buildings[l][0], buildings[l][2]});
        res.add(new int[] {buildings[l][1], 0});
        return res;
    } else {
        int mid = l + (r - l) / 2;
        return merge(mergeSkyline(buildings, l, mid), mergeSkyline(buildings, mid + 1, r));
    }
}
private  List<int[]> merge(List<int[]> l1, List<int[]> l2) {
    List<int[]> res = new ArrayList<>();
    int i = 0;
    int j = 0;
    int y1 = 0;
    int y2 = 0;
    while (i < l1.size() && j < l2.size()) {
        int[] b1 = l1.get(i);
        int[] b2 = l2.get(j);
        int x = 0;
        int y = 0;
        if (b1[0] < b2[0]) {
            x = b1[0];
            y1 = b1[1];
            i++;
        } else if (b1[0] > b2[0]) {
            x = b2[0];
            y2 = b2[1];
            j++;
        } else {
            x = b1[0];
            y1 = b1[1];
            y2 = b2[1];
            i++;
            j++;
        }
        y = Math.max(y1, y2);
        if (res.size() == 0 || y != res.get(res.size() - 1)[1]) {
            res.add(new int[] {x, y});
        }
    }
    while (i < l1.size()) {
        res.add(l1.get(i++));
    }
    while (j < l2.size()) {
        res.add(l2.get(j++));
    }
    return res;
}
```
<br>
<br>

###219 Contains Duplicate II

>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.


```java
 public boolean containsNearbyDuplicate(int[] nums, int k) {
    if (nums.length <= 1) {
        return false;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        Integer index = map.get(nums[i]);
        if (index != null) {
            if (i <= k + index) {
                return true;
            }
        }
        map.put(nums[i], i);
    }
    return false;
}

```

<br>
<br>

###220 Contains Duplicate III

>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.


**Time**:O(Nlogk)

```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    if (nums.length <= 1) {
        return false;
    }
    TreeSet<Long> set = new TreeSet<>();
    for (int i = 0; i < nums.length; i++) {
       Long floor = set.floor((long) nums[i] + t);
       Long ceiling = set.ceiling((long) nums[i] - t);
       if ((floor != null && floor >= nums[i]) || (ceiling != null && ceiling <= nums[i])) {
           return true;
       }
       set.add((long) nums[i]);
       if (i >= k) {
           set.remove((long) nums[i - k]);
       }
    }
    return false;
}
```

Another solution use bucket, time O(n)

https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation


<br>
<br>

###221 Maximal Square

>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.

<pre>
For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Return 4.
</pre>

**DP, two dimension**:

```java
public int maximalSquare(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }
    int[][] len = new int[matrix.length + 1][matrix[0].length + 1];
    int res = 0;
    for (int i = 1; i <= matrix.length; i++) {
        for (int j = 1; j <= matrix[0].length; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                len[i][j] = Math.min(len[i - 1][j - 1], Math.min(len[i - 1][j], len[i][j - 1])) + 1;
                res = Math.max(res, len[i][j]);
            }
        }
    }
    return res * res;
}
```

<br>
<br>



###222 Count Complete Tree Nodes

>Given a complete binary tree, count the number of nodes.

>Definition of a complete binary tree from Wikipedia:

>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

**Idea**: 

A O(n) solution is pretty straight forward. Here we discuss a O(logn * logn) solution

Look at the following picture: 

![completetree](https://wishyouhappy.github.io/pictures/completetree.png)

For a complete tree, it's easier to find the height of a tree or subtree. We can divide the count work into two parts. COunt the nodes in the left subtree and count the node in the right subtree, then sum them. 

How can we determine how many nodes to add?

In the figure above, we can first check if height of subtree root at 2 is equal tp height of subtree rooted at 3. There are two cases:

- 1) If it doesn't equal, then we know that right subtree's last level is empty. So we add 2 ^ (height of right subtree) - 1 + 1(parent). And go to the left subtree. **Note that in this case, the right subtree is full, but its height is 1 smaller than the height of the left subtree. 

- 2) What if they equal, then we know that left subtree is full. So we add 2 ^ (height of left subtree) - 1 + 1(parent). And go to the right subtree. 

Let's go over the above figure. 

- 1) count = 0; root = 1; height(2) = 3, height(3) = 2. Thus height(2) != height(3). It's case 1, so count += 2 ^ 2 - 1 + 1 = 4. root = root.left = 2;

- 2) count = 4; root = 2, height(4) = height(5) = 2. Thus it's case 2. So count += 2 ^ 2 - 1 + 1 = 8. root = root.right = 5

- 3) count = 8; root = 5, height(1) = height(2) = 1. Thus it's case 2. So count += 2 ^ 1 - 1 + 1 = 10. root = root.right = 2

- 4) count = 10; root = 2, height(left) = height(right) = 0. It's case 2. so count += 2 ^ 0 - 1 + 1 = 11. root = root.right = null.

- 5) count = 11; root = null. Stop, return 11. 

**Solution**:

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int res = 0;
    int h = getHeight(root);
    while (root != null) {
        //if left subtree is full
        if (getHeight(root.right) == h - 1) {
            res += 1 << (h - 1);
            root = root.right;
        } else {
            //if missing nodes begins at left subtree.
            res += 1 << (h - 2);
            root = root.left;
        }
        h--;
    }
    return res;
}
public int getHeight(TreeNode root) {
    return root == null ? 0 : 1 + getHeight(root.left);
}

```


<br>

**Related**: Check if a binary tree is complete?

**Idea**: Use level order traversal, once we find a node does not have both left chil and right child, then the remian nodes in the queue must be leaf node. 



**Solution**:


```java
  public boolean isCompleted(TreeNode root) {
    if (root == null) {
      return true;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    boolean isFull = true;
    while (!queue.isEmpty()) {
      TreeNode cur = queue.poll();
      if (cur.left != null) {
        if (!isFull) {
          return false;
        }
        queue.offer(cur.left);
      } else {
        isFull = false;
      }
      if (cur.right != null) {
        if (!isFull) {
          return false;
        }
        queue.offer(cur.right);
      } else {
        isFull = false;
      }
    }
    return true;
  }
```

<br>
<br>

###223 Rectangle Area

>Find the total area covered by two rectilinear rectangles in a 2D plane.
>
>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.
>
>Rectangle Area
>Assume that the total area is never beyond the maximum possible value of int.

**Idea** This problem is confusing. It asks to calculate the total area  other than the shared area.

```java
public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
    int r = Math.min(C, G);
    int l = Math.max(A, E);
    int u = Math.min(D, H);
    int d = Math.max(B, F);
    int shared = (C <= E || B >= H || A >= G || F >= D) ? 0 : Math.max(0, r - l) * Math.max(0, u - d);
    int total = (D - B) * (C - A) + (G- E) * (H - F);
    return total - shared;
}
```


<br>
<br>

###224 Basic Calculator

>Implement a basic calculator to evaluate a simple expression string.
>
>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .
>
>You may assume that the given expression is always valid.
>
>Some examples:
>
"1 + 1" = 2
>
>" 2-1 + 2 " = 3
>
>"(1+(4+5+2)-3)+(6+8)" = 23

**Idea**: 
- Use a stack to store the val and sign before ( 
- Pop from stack and calculate when encounter )
          

```java
public int calculate(String s) {
    int res = 0;
    int sign = 1;
    int num = 0;
    Deque<Integer> stack = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (isNumber(c)) {
            num = num * 10 + c - '0';
        } else if (c == '+' || c == '-') {
            res += num * sign;
            sign = c == '+' ? 1 : -1;
            num = 0;
        } else if (c == '(') {
            stack.push(res);
            stack.push(sign);
            sign = 1;
            res = 0;
        } else if (c == ')') {
            res += sign * num;
            res *= stack.pop();
            res += stack.pop();
            num = 0;
        }
    }
    res += sign * num;
    return res;
}
private boolean isNumber(char c) {
    return c >= '0' && c <= '9';
}
```

<br>
<br>

###225 Implement Stack using Queues

>Implement the following operations of a stack using queues.

<pre>
push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
empty() -- Return whether the stack is empty.
Notes:
You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).
</pre>

```java
class MyStack {
    Deque<Integer> queue1 = new LinkedList<>();
    Deque<Integer> queue2 = new LinkedList<>();
    
    // Push element x onto stack.
    public void push(int x) {
        queue1.offer(x);
    }

    // Removes the element on top of the stack.
    public void pop() {
        while (queue1.size() > 1) {
            queue2.offer(queue1.poll());
        }
        if (!queue1.isEmpty()) {
            queue1.poll();
        }
        Deque<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }

    // Get the top element.
    public int top() {
        int res = -1;
        while (queue1.size() >= 1) {
            res = queue1.poll();
            queue2.offer(res);
        }
        Deque<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
        return res;
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```


<br>
<br>

###226 Invert Binary Tree

>Invert a binary tree.

<pre>
     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1

</pre>

**Solution**:

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode temp = root.left;
    root.left = invertTree(root.right);
    root.right = invertTree(temp);
    return root;
}
```


**First try**:

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    invert(root.left, root.right, root);
    return root;
}
private void invert(TreeNode l, TreeNode r, TreeNode root) {
    if (l == null && r == null) {
        return;
    } else if (l == null) {
        root.left = r;
        root.right = null;
        invert(r.left, r.right, r);
    } else if (r == null) {
        root.right = l;
        root.left = null;
        invert(l.left, l.right, l);
    } else {
        root.left = r;
        root.right = l;
        invert(l.left, l.right, l);
        invert(r.left, r.right, r);
    }
    
}
```

<br>
<br>

###227 Basic Calculator II
>Implement a basic calculator to evaluate a simple expression string.
>
>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.
>
>You may assume that the given expression is always valid.
>
>Some examples:
>"3+2*2" = 7
>" 3/2 " = 1
>" 3+5 / 2 " = 5

**Solution 1** O(n) time, O(1) space. Remember to handle the last operation when string ends.

```java
public int calculate(String s) {
    int res = 0;
    char preSign = '+';
    int num = 0;
    int pre = 0;
    int i = 0;
    s = s.trim();
    while (i < s.length()) {
        while (i < s.length() && isNumber(s.charAt(i))) {
            num = num * 10 + s.charAt(i++) - '0';
        }
        if (i == s.length() || (!isNumber(s.charAt(i)) && s.charAt(i) != ' ')) {
            switch (preSign) {
                case '+':
                    res += pre;
                    pre = num;
                    break;
                case '-':
                    res += pre;
                    pre = -num; 
                    break;
                case '*':
                    pre *= num;
                    break;
                case '/':
                    pre /= num;
                    break;
            }
            num = 0;
            if (i != s.length()) {
                preSign = s.charAt(i);
            }
        }
        i++;
    }
    return res + pre;
}
private boolean isNumber(char c) {
    return c >= '0' && c <= '9';
}
```

**Soltion 2**: O(N) time + O(N) space. Pretty similar with the first solution. Since we only need to pop one element from the stack each time.

```java
public int calculate(String s) {
    int res = 0;
    int num = 0;
    Deque<Integer> stack = new LinkedList<>();
    char preSign = '+';
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (isNumber(c)) {
            num = num * 10 + s.charAt(i) - '0';
        } 
        if (i == s.length() - 1 || (!isNumber(c) && s.charAt(i) != ' ')) {
            switch (preSign) {
                case '+':
                    stack.push(num);
                    break;
                case '-':
                    stack.push(-num);
                    break;
                case '*':
                    stack.push(stack.pop() * num);
                    break;
                case '/':
                    stack.push(stack.pop() / num);
                    break;
            }
            num = 0;
            preSign = c;
        }
    }
    for (int i : stack) {
        res += i;
    }
    return res;
}
private boolean isNumber(char c) {
    return c >= '0' && c <= '9';
}
```


<br>
<br>

###228 Summary Ranges

>Given a sorted integer array without duplicates, return the summary of its ranges.
>
>For example, given [0,1,2,4,5,7], return ["0->2","4->5","7"].

```java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    if (nums.length == 0) {
        return res;
    }
    int start = nums[0];
    int end = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] - end == 1) {
            end++;
        } else {
            res.add(start == end ? start + "" : start + "->" + end);
            start = nums[i];
            end = nums[i];
        }
    }
    res.add(start == end ? start + "" : start + "->" + end);
    return res;
}
```



<br>
<br>

###229 Majority Element II
>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.

**Solution 1**: voting algorithm

```java
public List<Integer> majorityElement(int[] nums) {
    List<Integer> res = new ArrayList<>();
    int count1 = 0;
    int candidate1 = 0;
    int count2 = 0;
    int candidate2 = 1;
    for (int i : nums) {
        if (i == candidate1) {
            count1++;
        } else if (i == candidate2) {
            count2++;
        } else if (count1 == 0) {
            candidate1 = i;
            count1 = 1;
        } else if (count2 == 0) {
            count2 = 1;
            candidate2 = i;
        } else {
            count1--;
            count2--;
        }
    }
    count1 = 0;
    count2 = 0;
    for (int i : nums) {
        if (i == candidate1) {
            count1++;
        }
        if (i == candidate2) {
            count2++;
        }
    }
    if (count1 > nums.length / 3) {
        res.add(candidate1);
    }
    if (count2 > nums.length / 3) {
        res.add(candidate2);
    }
    return res;
}
```

**Solution 2**: quick select. This method can not pass test case "11...........1122.....22" in leetcode. If we handle it specially then it can be accepted.

```java
public List<Integer> majorityElement(int[] nums) {
    List<Integer> res = new ArrayList<>();
    if (nums.length == 0) {
        return res;
    }
    int candidate1 = quickSelect(nums, nums.length / 3 + 1, 0, nums.length - 1);
    int candidate2 = quickSelect(nums, (nums.length * 2) / 3 + 1, 0, nums.length - 1);
    int count1 = 0;
    int count2 = 0;
    for (int i : nums) {
        if (i == candidate1) {
            count1++;
        }
        if (i == candidate2) {
            count2++;
        }
    }
    if (count1 > nums.length / 3) {
        res.add(candidate1);
    }
    if (count2 > nums.length / 3 && candidate1 != candidate2) {
        res.add(candidate2);
    }
    return res;
}
private int quickSelect(int[] nums, int k, int start, int end) {
    int pivot = pivot(nums, start, end);
    if (k == end - pivot + 1) {
        return nums[pivot];
    } else if (k < end - pivot + 1) {
        return quickSelect(nums, k, pivot + 1, end);
    } else {
        return quickSelect(nums, k - (end - pivot + 1), start, pivot - 1);
    }
}
private int pivot(int[] nums, int start, int end) {
    int pivot = start + (end - start) / 2;
    swap(nums, pivot, end);
    int i = start;
    int j = end - 1;
    while (i <= j) {
        while (i <= end && nums[i] < nums[end]) {
            i++;
        }
        while (j >= start && nums[j] >= nums[end]) {
            j--;
        }
        if (i < j) {
            swap(nums, i++, j--);
        }
    }
    swap(nums, i, end);
    return i;
}
private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```



<br>
<br>

###230 Kth Smallest Element in a BST

>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
>
>Note: 
>You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

**Solution 1**: inorder traversal.

```java
public int kthSmallest(TreeNode root, int k) {
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            k--;
            if (k == 0) {
                return root.val;
            }
            root = root.right;
        }
    }
    return -1;
}
```

**Solution 2**: Count number of nodes in left and right substree. If the tree is a order-statistic tree, then this method would be simpler.

```java
public int kthSmallest(TreeNode root, int k) {
    int[] res = new int[1];
    getK(res, root, k);
    return res[0];
}
private int getK(int[] res, TreeNode root, int k) {
    if (root == null) {
        return 0;
    }
    int left = getK(res, root.left, k);
    if (k == left + 1) {
        res[0] = root.val;
    }
    int right = getK(res, root.right, k - left - 1);
    return left + right + 1;
}
```



<br>
<br>

###231 Power of Two

>Given an integer, write a function to determine if it is a power of two.

```java
public boolean isPowerOfTwo(int n) {
    if (n <= 0) {
        return false;
    }
    return (n & (n - 1)) == 0;
}
```

**Solution 2**:

```java
public boolean isPowerOfTwo(int n) {
    return n > 0 && Integer.bitCount(n) == 1;
}
```
<br>
<br>
###232 Implement Queue using Stacks

>Implement the following operations of a queue using stacks.

<pre>
push(x) -- Push element x to the back of queue.
pop() -- Removes the element from in front of queue.
peek() -- Get the front element.
empty() -- Return whether the queue is empty.
Notes:
You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).
</pre>

```java
class MyQueue {
    // Push element x to the back of queue.
    Deque<Integer> stack1 = new LinkedList<>();
    Deque<Integer> stack2 = new LinkedList<>();
    public void push(int x) {
        stack1.push(x);
    }

    // Removes the element from in front of queue.
    public void pop() {
        if (!stack2.isEmpty()) {
            stack2.pop();
        } else {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            if (!stack2.isEmpty()) {
                stack2.pop();
            }
        }
    }

    // Get the front element.
    public int peek() {
        if (!stack2.isEmpty()) {
            return stack2.peek();
        } else {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            if (!stack2.isEmpty()) {
                return stack2.peek();
            }
            return -1;
        }
    }

    // Return whether the queue is empty.
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}
```




<br>
<br>
###233 Number of Digit One

>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

For example:
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.

**Idea**:
- 1 - 9 : 1

- 10 - 19 : 1 + 10

- 20 -29 : 1

-.....

- 90 -99 : 1

- 100 - 109 : 11

- 110 -119 : 11 + 10

- 120 - 129 : 11

- .....

- 190 - 199 : 11

- 200 - 209 : 1

- 210 - 219 : 1 + 10

-......

- 990 - 999 : 1

- 1000 - 1099 : 100 + 19 

- 1100 - 1199 : 100 + 100 + 19

- 1200 - 1299 : 100 + 19

- ......

- 1900 -1999 : 100 + 19

The idea of the solution below calculate number of one in each digit. For example, if n = 121

digit 1 = 12 + 1 : 1 11, 21 ...91, 101, 111, 121.
digit 10 = 20 : 10 - 19 110 - 119
digit 100 = 22 : 100 - 121 

```java
public int countDigitOne(int n) {
    int res = 0;
    int digit = 1;
    int r = 1;
    while (n > 0) {
        int lastDigit = n % 10;
        res += lastDigit >= 2 ? ((n / 10) + 1) * digit : (n / 10) * digit;
        res += lastDigit == 1 ? r : 0;
        r += lastDigit * digit;
        digit *= 10;
        n /= 10;
    }
    return res;
}

```

**More consice solution:** 

Use (n + 8) / 10 to check if number is >20 or > 120 ....

```java
public int countDigitOne(int n) {
    int res = 0;
    int m = 1;
    int r = 1;
    while (n > 0) {
        res += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0);
        r += (n % 10) * m;
        m *= 10;
        n /= 10;
    }
    return res;
}
```




<br>
<br>

###234 Palindrome Linked List
>Given a singly linked list, determine if it is a palindrome.
>
>Follow up:
Could you do it in O(n) time and O(1) space?

```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    ListNode faster = head;
    ListNode slower = head; 
    while (faster.next != null && faster.next.next != null) {
        faster = faster.next.next;
        slower = slower.next;
    }
    ListNode lastHalf = reverse(slower.next);
    while (lastHalf != null) {
        if (lastHalf.val != head.val) {
            return false;
        }
        lastHalf = lastHalf.next;
        head = head.next;
    }
    return true;
}
private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode next = null;
    while (head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```

<br>
<br>
###235 Lowest Common Ancestor of a Binary Search Tree

>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

<pre>
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</pre>

**Idea**: Pretty straight forward. 

- if both p and q < root, go left
- if both p and q > root, go right
- otherwise, root is the ancester.

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    } else if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    } else if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    } else {
        return root;
    }
}
```


<br>
<br>
###236 Lowest Common Ancestor of a Binary Tree

>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

<pre>
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</pre>


```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    } 
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    return left == null ? right : left;
}
```


<br>
<br>


###237 Delete Node in a Linked List

>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

>Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

**Idea**: Copy the next.val to the deleteNode.val, then point deleteNode.next = deleteNode.next.next.



**Solution**:

```java
    public void deleteNode(ListNode node) {
       if (node == null) {
           return;
       }
       ListNode next = node.next;
       if (next == null) {
           node = null;
       }
       ListNode nextNext = next.next;
       node.val = next.val;
       node.next = nextNext;
    }
```

<br>
<br>


###238 Product of Array Except Self

> Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

>Solve it without division and in O(n).

>For example, given [1,2,3,4], return [24,12,8,6].

>Follow up:
>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)

**idea**: O(n) space solution is pretty straightforward. 

We first calculate the product left of A[i] except A[i], then calculate the product right of A[i] except A[i]. Then we make product of them, we can get the product of array except self.

What about O(1) space solution?

We can use a variable to record the product left of A[i] or the product right of A[i] use a variable.

Here is the O(1) space solution below.


**Solution**: O(1) space

```java
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        res[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            res[i] = res[i -1] * nums[i - 1];
        }
        int pre = 1;
        for (int i = nums.length - 2; i >= 0; i--) {
            pre *= nums[i + 1];
            res[i] = res[i] * pre;
        }
        return res;
    }
```


<br>
<br>

###239 Sliding Window Maximum

>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

<pre>
For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Therefore, return the max sliding window as [3,3,5,5,6,7].

Note: 
You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.
</pre>

**Idea**: [36-sliding-window-maximum](https://github.com/wishyouhappy/Algorithm/blob/master/README.md#36-sliding-window-maximum)

```java

public int[] maxSlidingWindow(int[] A, int w) {
    if (A == null || A.length == 0) {
        return new int[0];
    }
    Deque<Integer> deque = new LinkedList<>();
    for (int i = 0; i < w; i++) {
        while (!deque.isEmpty() && A[deque.peekLast()] <= A[i]) {
            deque.pollLast();
        }
        deque.offerLast(i);
    }
    int[] res = new int[A.length - w + 1];
    for (int i = w; i < A.length; i++) {
        res[i - w] = A[deque.peekFirst()];
        while (!deque.isEmpty() && A[deque.peekLast()] <= A[i]) {
            deque.pollLast();
        }
        while (!deque.isEmpty() && deque.peekFirst() <= i - w) {
            deque.pollFirst();
        }
        deque.offerLast(i);
    }
    res[A.length - w] = A[deque.peekFirst()];
    return res;
}

```

<br>
<br>

###240 Search a 2D Matrix II

>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

<pre>
Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
For example,

Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.

Given target = 20, return false.
</pre>

**Idea and solution**: [https://github.com/wishyouhappy/Algorithm/blob/master/README.md#1-search-a-2d-matrix-ii](https://github.com/wishyouhappy/Algorithm/blob/master/README.md#1-search-a-2d-matrix-ii)


<br>
<br>


###241 Different Ways to Add Parentheses

>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.

<pre>
Example 1
Input: "2-1-1".

((2-1)-1) = 0
(2-(1-1)) = 2
Output: [0, 2]


Example 2
Input: "2*3-4*5"

(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
Output: [-34, -14, -10, -10, 10]

</pre>

**Idea**: Divide and conquer. Divide the String into two parts based on the operator. We calculate the left part and right part separately, then combine the result.

**Solution 1** :

```java   
public List<Integer> diffWaysToCompute(String input) {
  List<Integer> res = new ArrayList<Integer>();
  if (input == null || input.length() == 0) {
      return res;
  }
  for (int i = 0; i < input.length(); i++) {
      if (isOperator(input.charAt(i))) {
          List<Integer> left = diffWaysToCompute(input.substring(0, i));
          List<Integer> right = diffWaysToCompute(input.substring(i + 1));
          for (Integer num1 : left) {
              for (Integer num2 : right) {
                  res.add(input.charAt(i) == '+' ? num1 + num2 : (input.charAt(i) == '-' ? num1 - num2 : num1 * num2)); 
              }
          }
      }
  }
  if (res.size() == 0) {
      res.add(Integer.parseInt(input));
  } 
  return res;
}
private boolean isOperator(char c) {
  return c == '+' || c == '-' || c == '*';
}

```

<br>
There is some repeat operations in the above calculation. We can reduce it by store the calculated string into hashMap.

Here is the modified solution based on solution 1.

**Solution 2**:

```java
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> res = new ArrayList<Integer>();
        if (input == null || input.length() == 0) {
            return res;
        }
        Map<String, List<Integer>> map = new HashMap<String, List<Integer>>();
        return diffWaysToCompute(input, map);
    }
    private List<Integer> diffWaysToCompute(String input, Map<String, List<Integer>> map) {
        List<Integer> res = new ArrayList<Integer>();
        for (int i = 0; i < input.length(); i++) {
            if (isOperator(input.charAt(i))) {
                String lPart = input.substring(0, i);
                String rPart = input.substring(i + 1);
                List<Integer> left = map.containsKey(lPart) ? map.get(lPart) : diffWaysToCompute(lPart);
                List<Integer> right = map.containsKey(rPart) ? map.get(rPart) : diffWaysToCompute(rPart);
                map.put(lPart, left);
                map.put(rPart, right);
                for (Integer num1 : left) {
                    for (Integer num2 : right) {
                        res.add(input.charAt(i) == '+' ? num1 + num2 : (input.charAt(i) == '-' ? num1 - num2 : num1 * num2)); 
                    }
                }
            }
        }
        if (res.size() == 0) {
            res.add(Integer.parseInt(input));
        } 
        return res;
    }
    private boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*';
    }
```

<br>
<br>

###242 Valid Anagram

>Given two strings s and t, write a function to determine if t is an anagram of s.

>For example,

>s = "anagram", t = "nagaram", return true.

>s = "rat", t = "car", return false.

**Idea**:

- Solution 1 : sort two String, then compare.

- Solution 2 : use hash table, check if two strings have the same number of each char.

**Java code**:

**Solution 1**:

```java
public boolean isAnagram(String s, String t) {
    if (s == null || t == null) {
        return false;
    }
    char[] sArr = s.toCharArray();
    char[] tArr = t.toCharArray();
    Arrays.sort(sArr);
    Arrays.sort(tArr);
    return new String(sArr).equals(new String(tArr));
}
```

<br>

**Solution 2**:

```java
public boolean isAnagram(String s, String t) {
    if (s == null || t == null || s.length() != t.length()) {
        return false;
    }
    Map<Character, Integer> map = new HashMap<Character, Integer>();
    char[] sArr = s.toCharArray();
    char[] tArr = t.toCharArray();
    for (char c : sArr) {
        Integer temp = map.get(c);
        if (temp == null) {
            map.put(c, 1);
        } else {
            map.put(c, temp + 1);
        }
    }
    for (char c : tArr) {
        Integer temp = map.get(c);
        if (temp == null || temp <= 0) {
            return false;
        } else {
            map.put(c, temp - 1);
        }
    }
    return true;
}
```

<br>
<br>

###243 Shortest Word Distance
>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

<pre>
For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Given word1 = "coding", word2 = "practice", return 3.
Given word1 = "makes", word2 = "coding", return 1.

Note:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

</pre>

```java
public int shortestDistance(String[] words, String word1, String word2) {
    int index1 = -1;
    int index2 = -1;
    int res = Integer.MAX_VALUE;
    for (int i = 0; i < words.length; i++) {
        if (words[i].equals(word1)) {
            index1 = i;
        }
        if (words[i].equals(word2)) {
            index2 = i;
        }
        if (index1 != -1 && index2 != -1) {
            res = Math.min(res, Math.abs(index1 - index2));
        }
    }
    return res;
}
```
<br>
<br>

###244 Shortest Word Distance II
>Problem Description:
>
>This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?
>
>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.
>
>For example,
>Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
>
>Given word1 = "coding”, word2 = "practice”, return 3.
>Given word1 = "makes", word2 = "coding", return 1.
>
>Note:
>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

```java
import java.util.*;
public class WordDistance {

    private Map<String, List<Integer>> map;

    public WordDistance(String[] words) {
        map = new HashMap<>();
        for (int i = 0; i < words.length; i++) {
            List<Integer> ls = map.get(words[i]);
            if (ls == null) {
                ls = new ArrayList<>();
            }
            ls.add(i);
            map.put(words[i], ls);
        }
    }

    public int shortest(String word1, String word2) {
        List<Integer> ls1 = map.get(word1);
        List<Integer> ls2 = map.get(word2);
        int res = Integer.MAX_VALUE;
        int i = 0;
        int j = 0;
        while (i < ls1.size() && j < ls2.size()) {
            res = Math.min(res, Math.abs(ls1.get(i) - ls2.get(j)));
            if (ls1.get(i) < ls2.get(j)) {
                i++;
            } else {
                j++;
            }
        }
        return res;
    }
}

```

<br>
<br>

###245 Shortest Word Distance III

>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
>
>word1 and word2 may be the same and they represent two individual words in the list.
>
>For example,
>
>Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
>
>Given word1 = "makes", word2 = "coding", return 1. Given word1 = "makes", word2 = "makes", return 3.
>
>Note:
>
>You may assume word1 and word2 are both in the list.

```java
public int shortestDistance(String[] words, String word1, String word2) {
    int index1 = -1;
    int index2 = -1;
    boolean same = word1.equals(word2);
    int res = Integer.MAX_VALUE;
    for (int i = 0; i < words.length; i++) {
        if (words[i].equals(word1)) {
            if (same) {
                index1 = index2;
                index2 = i;
            } else {
                index1 = i;
            }
        } else if (words[i].equals(word2)) {
            index2 = i;
        }
        if (index1 != -1 && index2 != -1) {
            res = Math.min(res, Math.abs(index1 - index2));
        }
    }
    return res;
}
```


<br>
<br>

###246 Strobogrammatic Number
>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
>
>Write a function to determine if a number is strobogrammatic. The number is represented as a string.
>
>For example, the numbers "69", "88", and "818" are all strobogrammatic.

```java
public boolean isStrobogrammatic(String num) {
    Map<Character, Character> map = new HashMap<>();
    initiateStrobogrammaticNumberMap(map);
    int l = 0;
    int r = num.length() - 1;
    while (l <= r) {
        Character temp = map.get(num.charAt(l));
        if (temp == null) {
            return false;
        }
        if (temp != num.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}

private void initiateStrobogrammaticNumberMap(Map<Character, Character> map) {
    map.put('6', '9');
    map.put('9', '6');
    map.put('1', '1');
    map.put('0', '0');
    map.put('8', '8');
}
```

<br>
<br>
###247 Strobogrammatic Number II

> Find all strobogrammatic numbers that are of length = n.

**Idea**: Append two chars each time, until length is n.s 

```java
public List<String> findStrobogrammatic(int n) {
    Map<Character, Character> map = new HashMap<>();
    initiateStrobogrammaticNumberMap(map);
    return findS(n, n, map);
}

private List<String> findS(int index, int n, Map<Character, Character> map) {
    List<String> res = new ArrayList<>();
    if (index == 0) {
        res.add("");
        return res;
    } else if (index == 1) {
        res.add("0");
        res.add("1");
        res.add("8");
        return res;
    }
    List<String> next = findS(index - 2, n, map);
    for (String s : next) {
        StringBuilder sb = new StringBuilder();
        sb.append("0").append(s).append("0");
        for (Map.Entry<Character, Character> entry : map.entrySet()) {
            if (entry.getKey() == '0' && index == n) {
                continue;
            }
            res.add(setCharsAtBeginAndEnd(sb, entry.getKey(), entry.getValue()).toString());
        }
    }
    return res;
}

private StringBuilder setCharsAtBeginAndEnd(StringBuilder sb, char begin, char end) {
    sb.setCharAt(0, begin);
    sb.setCharAt(sb.length() - 1, end);
    return sb;
}

private void initiateStrobogrammaticNumberMap(Map<Character, Character> map) {
    map.put('6', '9');
    map.put('9', '6');
    map.put('1', '1');
    map.put('0', '0');
    map.put('8', '8');
}
```

<br>
<br>


###248 Strobogrammatic Number III

>Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.
>
>Given low = "50", high = "100", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.

```java
public int strobogrammaticInRange(String low, String high) {
    int res = 0;
    for (int i = low.length(); i <= high.length(); i++) {
        List<String> cur = findStrobogrammatic(i);
        for (String s : cur) {
            if ((s.length() == low.length() && s.compareTo(low) <0) ||
                    (s.length() == high.length() && s.compareTo(high) > 0)) {
                continue;
            }
            res++;
        }
    }
    return res;
}
public List<String> findStrobogrammatic(int n) {
    Map<Character, Character> map = new HashMap<>();
    initiateStrobogrammaticNumberMap(map);
    return findS(n, n, map);
}

private List<String> findS(int index, int n, Map<Character, Character> map) {
    List<String> res = new ArrayList<>();
    if (index == 0) {
        res.add("");
        return res;
    } else if (index == 1) {
        res.add("0");
        res.add("1");
        res.add("8");
        return res;
    }
    List<String> next = findS(index - 2, n, map);
    for (String s : next) {
        StringBuilder sb = new StringBuilder();
        sb.append("0").append(s).append("0");
        for (Map.Entry<Character, Character> entry : map.entrySet()) {
            if (entry.getKey() == '0' && index == n) {
                continue;
            }
            res.add(setCharsAtBeginAndEnd(sb, entry.getKey(), entry.getValue()).toString());
        }
    }
    return res;
}

private StringBuilder setCharsAtBeginAndEnd(StringBuilder sb, char begin, char end) {
    sb.setCharAt(0, begin);
    sb.setCharAt(sb.length() - 1, end);
    return sb;
}

private void initiateStrobogrammaticNumberMap(Map<Character, Character> map) {
    map.put('6', '9');
    map.put('9', '6');
    map.put('1', '1');
    map.put('0', '0');
    map.put('8', '8');
}
```

<br>
<br>

###249 Group Shifted Strings

>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -> “bcd”. We can keep “shifting” which forms the sequence:
>
>
>"abc" -> "bcd" -> ... -> "xyz"
>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.
>
>For example,
>
>given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], Return:
>
>
>[
 > ["abc","bcd","xyz"],
  >["az","ba"],
  >["acef"],
  >["a","z"]
>]

**Idea**: Use hashmap, for each string calculate the hash string based on itself so that for string in the same group would have the same hash string.

```java
    public List<List<String>> groupStrings(String[] strings) {
        List<List<String>> res = new ArrayList<>();
        Map<String, List<String>> map = new HashMap<>();
        for (String s : strings) {
            String key = getHash(s);
            List<String> cur = map.get(key);
            if (cur == null) {
                cur = new ArrayList<>();
            }
            cur.add(s);
            map.put(key, cur);
        }
        for (Map.Entry<String, List<String>> entry : map.entrySet()) {
            List<String> ls = entry.getValue();
            Collections.sort(ls);
            res.add(ls);
        }
        return res;
    }

    private String getHash(String s) {
        if (s.length() == 0) {
            return "";
        }
        StringBuilder res = new StringBuilder();
        int offset = s.charAt(0) - 'a';
        for (int i = 0; i < s.length(); i++) {
            char temp = (char) (s.charAt(i) - offset);
            res.append(temp >= 'a' ?  temp : temp + 26);
        }
        return res.toString();
    }
```


<br>
<br>
###250 Count Univalue Subtrees

>Given a binary tree, count the number of uni-value subtrees.
>
>A Uni-value subtree means all nodes of the subtree have the same value.
>
>For example:
>Given binary tree,

<pre>
              5
             / \
            1   5
           / \   \
          5   5   5
return 4.
</pre>

At first confusing about what is subtree. If the result of the above example is 4, then the subtree's meaning should be :
start from a node, the node and all of it's children construct the subtree.

```java
public int countUnivalSubtrees(TreeNode root) {
    int[] res = new int[1];
    count(res, root);
    return res[0];
}
private boolean count(int[] res, TreeNode root) {
    if (root == null) {
        return true;
    }
    boolean l = count(res, root.left);
    boolean r = count(res, root.right);
    if ((l && r) && (root.left == null || root.val == root.left.val) && (root.right == null || root.right.val == root.val)) {
        res[0]++;
        return true;
    }
    return false;
}
```


<br>
<br>
###251 Flatten 2D Vector

>Implement an iterator to flatten a 2d vector.
>
>For example,
>Given 2d vector =
>
>[
>  [1,2],
>  [3],
>  [4,5,6]
>]
>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].

**Native solution with two pointers:**: 

```java
public class Vector2D {
    private List<List<Integer>> vec2d;
    private int row = 0;
    private int col = 0;
    public Vector2D(List<List<Integer>> vec2d) {
        this.vec2d = vec2d;
    }

    public int next() {
        if (!hasNext()) {
            return -1;
        }
        int res = vec2d.get(row).get(col++);
        if (col == vec2d.get(row).size() && row != vec2d.size() - 1) {
            row++;
            col = 0;
        }
        return res;
    }

    public boolean hasNext() {
        while (row <= vec2d.size() - 1 && col >= vec2d.get(row).size()) {
            row++;
        }
        if (vec2d.size() == 0 || row > vec2d.size() - 1 || (row == vec2d.size() - 1 && col > vec2d.get(vec2d.size() - 1).size() - 1)) {
            return false;
        }
        return true;
    }
}
```


**Solution 2, use java Iterator**:
```java
public class Vector2D {
    private Iterator<List<Integer>> row;
    private Iterator<Integer> col;
    public Vector2D(List<List<Integer>> vec2d) {
        this.row = vec2d.iterator();
    }

    public int next() {
        if (!hasNext()) {
            return -1;
        }
        return col.next();
    }

    public boolean hasNext() {
        while ((col == null || (!col.hasNext())) && row.hasNext()) {
            col = row.next().iterator();
        }
        return col != null && col.hasNext();
    }
}
```
<br>
<br>
###252 Meeting Rooms

>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.
>
>For example,
>Given [[0, 30],[5, 10],[15, 20]],
>return false.

```java
public boolean canAttendMeetings(Interval[] intervals) {
    if (intervals.length <= 1) {
        return true;
    }
    Arrays.sort(intervals, new Comparator<Interval>() {
       public int compare(Interval i1, Interval i2) {
           return i1.start - i2.start;
       } 
    });
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i].start < intervals[i - 1].end) {
            return false;
        }
    }
    return true;
}
```




<br>
<br>

###253 Meeting Rooms II

>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
>
>For example,
>Given [[0, 30],[5, 10],[15, 20]],
>return 2.

**Solution 1** Use treemap to store the timeline. Start an interval, room++, end of a interval room--. Store the max room numbers during the process.

```java
public int minMeetingRooms(Interval[] intervals) {
    TreeMap<Integer, Integer> roomsMap = new TreeMap<>();
    for (Interval interval : intervals) {
        Integer start = roomsMap.get(interval.start);
        roomsMap.put(interval.start, start == null ? 1 : start + 1);
        Integer end = roomsMap.get(interval.end);
        roomsMap.put(interval.end, end == null ? -1 : end - 1);
    }
    int res = 0;
    int temp = 0;
    for (Map.Entry<Integer, Integer> entry : roomsMap.entrySet()) {
        temp += entry.getValue();
        res = Math.max(res, temp);
    }
    return res;
}
```

**Solution**: combine unoverlapping intervals. The total number of result intervals is the min room number.

Note that in the below solution, when use priorityqueue and modify the value of top elements, we can not just modify it. We need to poll, change, offer again. Otherwise, simply change the value the priorityqueue will not reajust the order. 

```java
    public int minMeetingRooms(Interval[] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        Arrays.sort(intervals, new Comparator<Interval>() {
           public int compare(Interval i1, Interval i2) {
               return i1.start - i2.start;
           } 
        });
        PriorityQueue<Interval> minHeap = new PriorityQueue<>(new Comparator<Interval>() {
            public int compare(Interval el1, Interval el2) {
                return el1.end - el2.end;
            }
        });
        minHeap.offer(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            Interval cur = minHeap.poll();
            if (intervals[i].start >= cur.end) {
                cur.end = intervals[i].end;
            } else {
                minHeap.offer(intervals[i]);
            }
            minHeap.offer(cur);
        }
        return minHeap.size();
    }
```

<br>
<br>

###254 Factor Combinations

>Numbers can be regarded as product of its factors. For example,
>
>8 = 2 x 2 x 2;
>  = 2 x 4.
>Write a function that takes an integer n and return all possible combinations of its factors.
>
>Note: 
>Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2].
>You may assume that n is always positive.
>Factors should be greater than 1 and less than n.
>Examples: 
>input: 1
>output: 
>[]
>input: 37
>utput: 
>[]
>input: 12
>output:
>[
>  [2, 6],
>  [2, 2, 3],
>  [3, 4]
>]
>input: 32
>output:
>[
>  [2, 16],
>  [2, 2, 8],
> [2, 2, 2, 4],
> [2, 2, 2, 2, 2],
>  [2, 4, 4],
>  [4, 8]
>]

**Idea**: dfs and take care of the ascending order.

```java
public List<List<Integer>> getFactors(int n) {
    List<List<Integer>> res = new ArrayList<>();
    factors(res, n, new ArrayList<Integer>(), 2);
    return res;
}
private void factors(List<List<Integer>> res, int n, List<Integer> cur, int start) {
    if (n <= 1) {
        if (cur.size() > 1) {
            res.add(new ArrayList<Integer>(cur));
        }
        return;
    }
    for (int i = start; i <= n; i++) {
        if (n % i == 0) {
            cur.add(i);
            factors(res, n / i, cur, i);
            cur.remove(cur.size() - 1);
        }
    }
}
```

<br>
<br>

###255 Verify Preorder Sequence in Binary Search Tree

>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.
>
>You may assume each number in the sequence is unique.
>
>Follow up:
Could you do it using only constant space complexity?


**Idea**:

Let's begin with an example:

Here is a valid perorder sequence [4, 2, 1, 3, 5, 7].

In this BST, 4 is the root, 2, 1, 3, is the left subtree, 5, 7 is the right subtree

In subtree 2, 1, 3 : 2 is the root, 1 is left subtree, 3 is right subtree.

In subtree 5 7: 5 is root, 7 is the right subtree.

Thus a naive solution is recursively check if we can divide it into subtree and the subtree also satisfy the BST rules.

Here is the solution for this method. 

This solution use recursion, thus is not constant space. If tree is balanced, then time is O(nlgn). Otherwise, the worst case can be O(n^2)

```java
public boolean verifyPreorder(int[] preorder) {
    if (preorder == null || preorder.length <= 1) {
        return true;
    }
    return verify(preorder, 0, preorder.length - 1);
}

private boolean verify(int[] preorder, int start, int end) {
    if (start >= end) {
        return true;
    }
    int i = start + 1;
    while (i <= end && preorder[i] < preorder[start]) {
        i++;
    }
    int pos = i;
    while (i <= end && preorder[i] > preorder[start]) {
        i++;
    }
    if (i != end + 1) {
        return false;
    }
    return verify(preorder, start + 1, pos - 1) && verify(preorder, pos, end);
}

```

**A constant space solution**: This method will change the original input.

```java
public boolean verifyPreorder(int[] preorder) {
    if (preorder == null || preorder.length <= 1) {
        return true;
    }
    int i = -1;
    int lower = Integer.MIN_VALUE;
    for (int num : preorder) {
        if (num < lower)  {
            return false;
        }
        while (i >= 0 && num > preorder[i]) {
            lower = preorder[i--];
        }
        preorder[++i] = num;
    }
    return true;
}
```



<br>
<br>

###256 Paint House

>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.
>
>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

**DP**: we can also reduce the O(n) space to O(1)

```java
public int minCost(int[][] costs) {
    if (costs.length == 0) {
        return 0;
    }
    int[][] dp = new int[costs.length][3];
    for (int i = 0; i < costs.length; i++) {
        if (i == 0) {
            dp[i][0] = costs[i][0];
            dp[i][1] = costs[i][1];
            dp[i][2] = costs[i][2];
        } else {
            dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0];
            dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1];
            dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][0]) + costs[i][2];
        }
    }
    return Math.min(Math.min(dp[costs.length - 1][0], dp[costs.length - 1][1]), dp[costs.length - 1][2]);
}
```

**O(1) space:**

```java
public int minCost(int[][] costs) {
    if (costs.length == 0) {
        return 0;
    }
    int num1 = costs[0][0];
    int num2 = costs[0][1];
    int num3 = costs[0][2];
    for (int i = 1; i < costs.length; i++) {
        int saveNum1 = num1;
        int saveNum2 = num2;
        num1 = Math.min(num2, num3) + costs[i][0];
        num2 = Math.min(saveNum1, num3) + costs[i][1];
        num3 = Math.min(saveNum2, saveNum1) + costs[i][2];
    }
    return Math.min(Math.min(num1, num2), num3);
}
```


<br>
<br>

###257 Binary Tree Paths

>Given a binary tree, return all root-to-leaf paths.

<pre>
For example, given the following binary tree:

   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:

["1->2->5", "1->3"]
</pre>

**Solution 1** DFS, use StringBuilder store path

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    paths(res, root, new StringBuilder());
    return res;
}
private void paths(List<String> res, TreeNode root, StringBuilder sb) {
    if (root == null) {
        return;
    }
    sb.append(sb.length() == 0 ? root.val : "->" + root.val);
    if (root.left == null && root.right == null) {
        res.add(sb.toString());
        return;
    }
    if (root.left != null) {
        int index = sb.length();
        paths(res, root.left, sb);
        sb = new StringBuilder(sb.substring(0, index));
    }
    if (root.right != null) {
        int index = sb.length();
        paths(res, root.right, sb);
    }
}
```


**Solution 2** DFS, use String store path

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    paths(res, root, "");
    return res;
}
private void paths(List<String> res, TreeNode root, String s) {
    if (root == null) {
        return;
    }
    s += s.length() == 0 ? root.val : "->" + root.val;
    if (root.left == null && root.right == null) {
        res.add(s) ;
        return;
    }
    paths(res, root.left, s);
    paths(res, root.right, s);
}
```

**Solution 3** : DFS

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    if (root.left == null && root.right == null) {
        res.add(root.val + "") ;
        return res;
    }
    for (String s : binaryTreePaths(root.left)) {
        res.add(root.val + "->" + s);
    }
    for (String s : binaryTreePaths(root.right)) {
        res.add(root.val + "->" + s);
    }
    return res;
}
```


<br>
<br>

###258 Add Digits

>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
>
>For example:
>
>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
>
>Follow up:
>Could you do it without any loop/recursion in O(1) runtime?


**Solution**: with loop:

```java
public int addDigits(int num) {
    while (num >= 10) {
        int temp = 0;
        while (num > 0) {
            temp += num % 10;
            num /= 10;
        }
        num = temp;
    }
    return num;
}
```

**It can be calculated without loop or recursion**: https://en.wikipedia.org/wiki/Digital_root

It helps to see the digital root of a positive integer as the position it holds with respect to the largest multiple of 9 less than it. For example, the digital root of 11 is 2, which means that 11 is the second number after 9. Likewise, the digital root of 2035 is 1, which means that 2035 − 1 is a multiple of 9. If a number produces a digital root of exactly 9, then the number is a multiple of 9.

Thus we get the following solution:

```java
public int addDigits(int num) {
    return (num - 1) % 9 + 1;
}
```


<br>
<br>

###259 3Sum Smaller

>Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.
>
>For example, given nums = [-2, 0, 1, 3], and target = 2.
>
>Return 2. Because there are two triplets which sums are less than 2:
>
>[-2, 0, 1]
>[-2, 0, 3]
>Follow up:
>Could you solve it in O(n2) runtime?

**Idea**: three pointers. current i, l= i + 1, r = length - 1. Just need to take care when nums[i] + nums[l] + nums[r] < target, the result count should plus r - l other than 1.

```java
public int threeSumSmaller(int[] nums, int target) {
    int res = 0;
    Arrays.sort(nums);
    for (int i = 0; i <= nums.length - 3; i++) {
        res += getCount(nums, i, target);
    }
    return res;
}
private int getCount(int[] nums, int i, int target) {
    int l = i + 1;
    int r = nums.length - 1;
    int res = 0;
    while (l < r) {
        if (nums[i] + nums[l] + nums[r] < target) {
            res += r - l;
            l++;
        } else {
            r--;
        }
    }
    return res;
}
```

<br>
<br>
###260 Single Number III

>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
>
>For example:
>
>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].
>
>Note:
>The order of the result is not important. So in the above example, [5, 3] is also correct.
Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?

**Idea**: find a bit that the two numbers differ. This can be done by xor all numbers. Then partition the numbers into two group based on this different bit, the two numbers we need to find must in two different groups and all pairs should in the same group. 

```java
public int[] singleNumber(int[] nums) {
    int xor = 0;
    for (int num : nums) {
        xor ^= num;
    }
    int bit = Integer.lowestOneBit(xor);
    int[] res = new int[2];
    for (int num : nums) {
        if ((num & bit) == 0) {
            res[0] ^= num;
        } else {
            res[1] ^= num;
        }
    }
    return res;
}
```


<br>
<br>


###261 Graph Valid Tree

>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
>
>for example:
>
>Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
>
>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.

**Idea**: Use[Union find](http://www.wishyouhappy.net/2015/10/22/Union%20Find/) to check if cycle exist. Also, check if edges = nodes - 1. 



```java
public boolean validTree(int n, int[][] edges) {
    int[] ids = new int[n];
    for (int i = 0; i < n; i++) {
        ids[i] = i;
    }
    for (int i = 0; i < edges.length; i++) {
        int root1 = root(ids, edges[i][0]);
        int root2 = root(ids, edges[i][1]);
        if (root1 == root2) { //find
            return false;
        }
        ids[root1] = root2; //union
    }
    return n - 1 == edges.length;
}
private int root(int[] ids, int i) {
    while (i != ids[i]) {
        i = ids[i];
    }
    return i;
}
```

<br>
<br>

###263 Ugly Number

>Write a program to check whether a given number is an ugly number.
>
>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
>
>Note that 1 is typically treated as an ugly number.

**Recursion**:

```java
public boolean isUgly(int num) {
    if (num <= 0) {
        return false;
    } else if (num <= 3) {
        return true;
    }
    return (num % 2 == 0 && isUgly(num / 2)) || (num % 3 == 0 && isUgly(num / 3))
            || (num % 5 == 0 && isUgly(num / 5));
}
```

**Iterative**:

```java
public boolean isUgly(int num) {
    if (num <= 0) {
        return false;
    }
    int[] factors = {2, 3, 5};
    for (int i : factors) {
        while (num % i == 0) {
            num /= i;
        }
    }
    return num == 1;
}
```


<br>
<br>

###264 Ugly Number II

>Write a program to find the n-th ugly number.
>
>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
>
>Note that 1 is typically treated as an ugly number.

**Idea**: select current smallest ugly element from base2 * 2, base3 * 3, base5 * 5.

**Note**: need to ne careful, since 2 * 3 == 3 * 2, etc. when increase the base2, base3, base5's indices, we should use if, if, other than if else if. Otherwise, we would have duplicate ugly number.

```java
public int nthUglyNumber(int n) {
    if (n <= 0) {
        throw new IllegalArgumentException("Input parameter is not valid");
    }
    int i = 0;
    int j = 0;
    int k = 0;
    List<Integer> res = new ArrayList<>();
    res.add(1);
    while (res.size() < n) {
        int next = Math.min(res.get(i) * 2, Math.min(res.get(j) * 3, res.get(k) * 5));
        res.add(next);
        if (res.get(i) * 2 == next) {
            i++;
        }
        if (res.get(j) * 3 == next) {
            j++;
        }
        if (res.get(k) * 5 == next) {
            k++;
        }
    }
    return res.get(res.size() - 1);
}
```


<br>
<br>
###265 Paint House II

>There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.
>
>The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.
>
>Note:
>All costs are positive integers.
>
>Follow up:
>Could you solve it in O(nk) runtime?

**Solution based on paint house**: time O(n * k^2)

```java
public int minCostII(int[][] costs) {
    if (costs.length == 0) {
        return 0;
    }
    int[][] dp = new int[costs.length][costs[0].length];
    for (int i = 0; i < costs.length; i++) {
        for (int j = 0; j < costs[0].length; j++) {
            dp[i][j] = i == 0 ? costs[i][j] : getMin(dp, i - 1, j) + costs[i][j];
        }
    }
    return getMin(dp, dp.length - 1, dp[0].length);
}
private int getMin(int[][] dp, int house, int color) {
    int res = Integer.MAX_VALUE;
    for (int i = 0; i < dp[house].length; i++) {
        if (i == color) {
            continue;
        }
        res = Math.min(res, dp[house][i]);
    }
    return res;
}
```

**O(n * k) solution**: Use two variable to maintain min and second min, so we don't need to get the minimum for each loop. 

```java
public int minCostII(int[][] costs) {
    if (costs.length == 0) {
        return 0;
    }
    int minIndex = -1;
    int nextMinIndex = -1;
    int[][] dp = new int[costs.length][costs[0].length];
    for (int i = 0; i < costs.length; i++) {
        int preMinIndex = minIndex;
        int preNextMinIndex = nextMinIndex;
        minIndex = -1;
        nextMinIndex = -1;
        for (int j = 0; j < costs[0].length; j++) {
            if (i == 0) {
                dp[i][j] = costs[i][j];
            } else {
                if (j == preMinIndex) {
                    dp[i][j] = dp[i - 1][preNextMinIndex] + costs[i][j];
                } else {
                    dp[i][j] = dp[i - 1][preMinIndex] + costs[i][j];
                }
            } 
            if (minIndex < 0 || dp[i][j] < dp[i][minIndex]) {
                nextMinIndex = minIndex;
                minIndex = j;
            } else if (nextMinIndex < 0 || dp[i][j] < dp[i][nextMinIndex]) {
                nextMinIndex = j;
            }
        }
    }
    return dp[dp.length - 1][minIndex];
}
```


<br>
<br>
###266 Palindrome Permutation

>Given a string, determine if a permutation of the string could form a palindrome.
>
>For example,
>"code" -> False, "aab" -> True, "carerac" -> True.

**For a valid palindrome, the character appear odd times should only be one in the string.**

```java
public boolean canPermutePalindrome(String s) {
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        Integer count = map.get(s.charAt(i));
        if (count == null) {
            map.put(s.charAt(i), 1);
        } else {
            map.put(s.charAt(i), count + 1);
        }
    }
    int num = 0;
    for (Map.Entry<Character, Integer> entry : map.entrySet()) {
        if (entry.getValue() % 2 != 0) {
            num++;
        }
        if (num >= 2) {
            return false;
        }
    }
    return true;
}

```

<br>
<br>

###267 Palindrome Permutation II

>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.
>
>For example:
>
>Given s = "aabb", return ["abba", "baab"].
>
>Given s = "abc", return [].

**Idea**: First check if it can form a palindrome. Then use dfs to generate palindrome. Remember one the odd number character should always appear in middle. 

```java
    public List<String> generatePalindromes(String s) {
        List<String> res = new ArrayList<>();
        Map<Character, Integer> map = new HashMap<>();
        StringBuilder sb = new StringBuilder();
        if (canPermutePalindrome(s, map, sb)) {
            if (sb.length() != 0) {
                map.put(sb.charAt(0), map.get(sb.charAt(0)) - 1);
            }
            getPalindromes(map, res, sb, s.length());
        }
        return res;
    }
    private void getPalindromes(Map<Character, Integer> map, List<String> res, StringBuilder sb, int len) {
        if (sb.length() == len) {
            res.add(sb.toString());
            return;
        }
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() <= 0) {
                continue;
            }
            entry.setValue(entry.getValue() - 2);
            sb.insert(0, entry.getKey()).append(entry.getKey());
            getPalindromes(map, res, sb, len);
            sb.deleteCharAt(0).deleteCharAt(sb.length() - 1);
            entry.setValue(entry.getValue() + 2);
        }
    }
    private boolean canPermutePalindrome(String s, Map<Character, Integer> map, StringBuilder sb) {
        for (int i = 0; i < s.length(); i++) {
            Integer count = map.get(s.charAt(i));
            if (count == null) {
                map.put(s.charAt(i), 1);
            } else {
                map.put(s.charAt(i), count + 1);
            }
        }
        int num = 0;
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() % 2 != 0) {
                num++;
                sb.append(entry.getKey());
            }
            if (num >= 2) {
                return false;
            }
        }
        return true;
    }
```


<br>
<br>
###268 Missing Number

>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
>
>For example,
Given nums = [0, 1, 3] return 2.
>
>Note:
>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

**Solution 1**: Move number to right index. 

```java
public int missingNumber(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        if (i != nums[i]) {
            if (nums[i] < nums.length) {
                int temp = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = temp;
                i--;
            } 
        }
    }
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != i) {
            return i;
        }
    }
    return nums.length;
}
```

**Solution 2**: Xor, same idea with single number.

```java
public int missingNumber(int[] nums) {
    int res = 0;
    for (int i = 0; i < nums.length; i++) {
        res ^= nums[i];
        res ^= i;
    }
    return res ^ nums.length;
}
```

**Solution 3**: Sum

```java
public int missingNumber(int[] nums) {
    int res = 0;
    for (int num : nums) {
        res += num;
    }
    return nums.length * (nums.length + 1) / 2 - res;
}
```
<br>
<br>


###269 Alien Dictionary
>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.
>
>For example,
>Given the following words in dictionary,
>
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]
>
>The correct order is: "wertf".
>
>Note:
>You may assume all letters are in lowercase.
>If the order is invalid, return an empty string.
>There may be multiple valid order of letters, return any one of them is fine.

**Topological sort**: Remember to check if the order is valid!


```java
    public String alienOrder(String[] words) {
        Map<Character, Set<Character>> graph = new HashMap<>();
        for (int i = 0; i < words.length; i++) {
            for (int j = 0; j < words[i].length(); j++) {
                if (!graph.containsKey(words[i].charAt(j))) {
                    graph.put(words[i].charAt(j), new HashSet<Character>());
                }
            }
            setOrder(graph, words, i);
        }
        return topologicalSort(graph);
    }
    
    private String topologicalSort(Map<Character, Set<Character>> graph) {
        Map<Character, Integer> inDegree = new HashMap<>();
        for (Map.Entry<Character, Set<Character>> entry : graph.entrySet()) {
            for (char node : entry.getValue()) {
                Integer in = inDegree.get(node);
                inDegree.put(node, in == null ? 1 : in + 1);
            }
        }
        Queue<Character> queue = new LinkedList<>();
        for (Map.Entry<Character, Set<Character>> entry : graph.entrySet()) {
            if (!inDegree.containsKey(entry.getKey())) {
                queue.offer(entry.getKey());
            }
        }
        StringBuilder sb = new StringBuilder();
        while (!queue.isEmpty()) {
            char node = queue.poll();
            sb.append(node);
            for (char neighbor : graph.get(node)) {
                inDegree.put(neighbor, inDegree.get(neighbor) - 1);
                if (inDegree.get(neighbor) == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        //Check if valid
        for (int val : inDegree.values()) {
            if (val != 0) {
                return "";
            }
        }
        return sb.toString();
    }
    
    private void setOrder(Map<Character, Set<Character>> graph, String[] words, int index) {
        if (index <= 0) {
            return;
        }
        for (int i = 0, len1 = words[index].length(), len2 = words[index - 1].length(); i < len1 && i < len2; i++) {
            char c1 = words[index - 1].charAt(i);
            char c2 = words[index].charAt(i);
            if (c1 != c2) {
                if (!graph.get(c1).contains(c2)) {
                    graph.get(c1).add(c2);
                }
                break;
            }
        }
    }
```
<br>
<br>
###270 Closest Binary Search Tree Value

>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.
>
>Given target value is a floating point.
You are guaranteed to have only one unique value in the BST that is closest to the target.

**Binary search**:

```java
public int closestValue(TreeNode root, double target) {
    int res = root.val;
    while (root != null) { 
        if (Math.abs(target - res) > Math.abs(target - root.val)) {
            res = root.val;
        }
        if (root.val < target) {
            root = root.right;
        } else {
            root = root.left;
        }
    }
    return res;
}
```

<br>
<br>
###271 Encode and Decode Strings

>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.
>
>Machine 1 (sender) has the function:
>

<pre>
string encode(vector<string> strs) {
  // ... your code
  return encoded_string;
}
Machine 2 (receiver) has the function:
vector<string> decode(string s) {
  //... your code
  return strs;
}

</pre>
>So Machine 1 does:
>
>string encoded_string = encode(strs);
and Machine 2 does:
>
>vector<string> strs2 = decode(encoded_string);
>strs2 in Machine 2 should be the same as strs in Machine 1.
>
>Implement the encode and decode methods.
>
>Note:
>The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.
>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.
Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.

**Idea**: The solution below is simply concat the strings and record the length.

- The first character stores the length of (length of string)
- Then store the length of string
- Store the actual string.

We can increase the number of characters to store the length of the (length of string) if in some use cases the length is really long.

```java
public class Codec {
    // Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for (String s : strs) {
            long len = s.length();
            sb.append(getDigits(len)).append("" + len).append(s);
        }
        return sb.toString();
    }
    
    private int getDigits(long len) {
        if (len == 0) {
            return 1;
        }
        int res = 0;
        while (len > 0) {
            res++;
            len /= 10;
        }
        return res;
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> res = new ArrayList<>();
        int i = 0;
        while (i < s.length()) {
            int digits = s.charAt(i++) - '0';
            int len = 0;
            for (int j = 0; j < digits; j++) {
                len = len * 10 + s.charAt(i + j) - '0';
            }
            res.add(s.substring(i + digits, i + digits + len));
            i += digits + len;
        }
        return res;
    }
}
```

<br>
<br>
###272 Closest Binary Search Tree Value II

>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.
>
>Note:
>Given target value is a floating point.
>You may assume k is always valid, that is: k ≤ total nodes.
>You are guaranteed to have only one unique set of k values in the BST that are closest to the target.
>Follow up:
>ssume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?

**Solution 1**: Inorder traverse, then find the element closest to the target. From the element closest to target, use two pointers to move left and right separately.

**Solution 2**: Traverse the tree inorder and reverse inorder to find tree nodes smaller than target and tree nodes larger or equal than the target. Then use two pointers like the solution 1 to get the k nodes.

**Solution 3**: Each time get the largest element smaller than target and smallest element larger than target, compare these two values and add one to result, until we get the k nodes. If we have parent pointer, this is a good approach. If tree is balanced, the time complexity is K * log(n)

**Here is code for solution 2**:

```java
public List<Integer> closestKValues(TreeNode root, double target, int k) {
    Deque<Integer> preStack = new LinkedList<>();
    Deque<Integer> sucStack = new LinkedList<>();
    inorder(root, target, preStack, false);
    inorder(root, target, sucStack, true);
    List<Integer> res = new ArrayList<>();
    while (k-- > 0) {
        if (preStack.isEmpty()) {
            res.add(sucStack.pop());
        } else if (sucStack.isEmpty()) {
            res.add(preStack.pop());
        } else if (Math.abs(target - preStack.peek()) < Math.abs(target - sucStack.peek())){
            res.add(preStack.pop());
        } else {
            res.add(sucStack.pop());
        }
    }
    return res;
}
private void inorder(TreeNode root, double target, Deque<Integer> stack, boolean reverse) {
    if (root == null) {
        return;
    }
    inorder(reverse ? root.right : root.left, target, stack, reverse);
    if ((!reverse && root.val > target) || (reverse && root.val <= target)) {
        return;
    }
    stack.push(root.val);
    inorder(reverse ? root.left : root.right, target, stack, reverse);
}
```



<br>
<br>
###273 Integer to English Words
>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.
>
>For example,
>123 -> "One Hundred Twenty Three"
>12345 -> "Twelve Thousand Three Hundred Forty Five"
>1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

Note: 

- Each word is separated with space
- Take care of Zeros, it has different ways to handle space.
- Remember to trim the unnecessary spaces.

```java
public String numberToWords(int num) {
    if (num == 0) {
        return "Zero";
    }
    String[] thousands = {"", "Thousand", "Million", "Billion"};
    String res = "";
    int i = 0;
    while (num > 0) {
        if (num % 1000 != 0) {
            res = hundredToString(num % 1000) + thousands[i] + " " + res;
        }
        num /= 1000;
        i++;
    }
    return res.trim();
}
private String hundredToString(int num) {
    String[] twenty = {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight",                     "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen",
                       "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    String[] ten = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String res = "";
    if (num / 100 != 0) {
        res += twenty[num / 100] + " Hundred ";
        num %= 100;
    }
    if (num / 10 >= 2) {
        res += ten[num / 10];
        num %= 10;
        res += num == 0 ? " " : " " + twenty[num % 10] + " ";
    } else {
        res += num == 0 ? "" : twenty[num] + " ";
    }
    return res;
}
```

<br>
<br>



###274 H-Index

>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."

For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.

Note: If there are several possible values for h, the maximum one is taken as the h-index.

**Solution 1**: sort. Time: O(n * logn)

```java
public int hIndex(int[] citations) {
    Arrays.sort(citations);
    int res = citations.length;
    for (int i = 0; i < citations.length; i++) {
        if (citations[i] < res) {
            res--;
        } else {
            break;
        }
    }
    return res;
}
```

**Solution 2**: Binary search. Time: O(n * logn)

```java
public int hIndex(int[] citations) {
    if (citations.length == 0) {
        return 0;
    }
    int l = 0; 
    int r = citations.length;
    while (true) {
        int mid = l + (r - l) / 2;
        int less = getH(citations, mid);
        int more = getH(citations, mid + 1);
        if (less >= mid && more <= mid) {
            return mid;
        } else if (less < mid) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
}
private int getH(int[] citations, int num) {
    int count = 0;
    for (int i : citations) {
        if (i >= num) {
            count++;
        }
    }
    return count;
}
```

**Solution 3**: Use additional array to sort the array.

```java
public int hIndex(int[] citations) {
    int[] arr = new int[citations.length + 1];
    for (int num : citations) {
        if (num > citations.length) {
            arr[citations.length]++;
        } else {
            arr[num]++;
        }
    }
    int res = 0;
    int h = 0;
    for (int i = arr.length - 1; i >= 0; i--) {
        h += arr[i];
        if (h >= i) {
            return i;
        }
    }
    return 0;
}
```


<br>
<br>
###275 H-Index II

>Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?

**Idea**: binary search.

```java
public int hIndex(int[] citations) {
    if (citations.length == 0) {
        return 0;
    }
    int l = 0; 
    int r = citations.length - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (citations[mid] == citations.length - mid) {
            return citations[mid]; 
        } else if (citations[mid] > citations.length - mid) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return citations.length -  l;
}
```

<br>
<br>

###276 Paint Fence

>There is a fence with n posts, each post can be painted with one of the k colors.
>
>You have to paint all the posts such that no more than two adjacent fence posts have the same color.
>
>Return the total number of ways you can paint the fence.
>
>Note:
>n and k are non-negative integers.

**Idea**:

- if current post use different color with previous, then we have (k - 1) color choices, no matter if previous and previous privous have the same color

- if current post use same color with previous post, the only choice is that the previous's color is different with previous previous color.

```java
public int numWays(int n, int k) {
    if (n <= 0) {
        return 0;
    } else if (n == 1) {
        return k;
    }
    int diff = k * (k - 1);
    int same = k;
    for (int i = 3; i <= n; i++) {
        int temp = diff;
        diff = (diff + same) * (k - 1);
        same = temp;
    }
    return diff + same;
}
```


<br>
<br>


###277 Find the Celebrity

>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
>
>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).
>
>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.
>
>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

**Idea**: First find the possible celebrity, then check if it is celebrity.

```java
public int findCelebrity(int n) {
    int candidate = 0;
    for (int i = 1; i <= n - 1; i++) {
        if (knows(candidate, i)) {
            candidate = i;
        }
    }
    for (int i = 0; i <= n - 1; i++) {
        if (i != candidate && (!knows(i, candidate) || knows(candidate, i))) {
            return -1;
        }
    }
    return candidate;
}

```

<br>
<br>
###278 First Bad Version](#278-first-bad-version)

>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
>
>Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.
>
>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.


**Idea**: binary search

```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        if (n <= 0) {
            throw new IllegalArgumentException("Input is not valid");
        }
        int l = 1;
        int r = n;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (super.isBadVersion(mid)) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}
```


<br>
<br>

###279 Perfect Squares](#279-perfect-squares)

>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.
>
>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

**DP solution**: Time : (n * log n)

```java
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int j = 1 ; j * j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}
```


<br>
<br>
###280 Wiggle Sort](#280-wiggle-sort)

>Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....
>
>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].

**Idea**: swap adjacent elements if not fullfil the rules.

```java
public void wiggleSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        if ((i % 2 == 1 && nums[i] < nums[i - 1]) || (i % 2 == 0 && nums[i] > nums[i - 1])) {
            int temp = nums[i - 1];
            nums[i - 1] = nums[i];
            nums[i] = temp;
        }
    }
}
```

A good way to replace "i % 2 == 1 && nums[i] < nums[i - 1]) || (i % 2 == 0 && nums[i] > nums[i - 1]" from Stefan:

```java
    public void wiggleSort(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            if (i % 2 == 1 == nums[i] < nums[i - 1]) {
                int temp = nums[i - 1];
                nums[i - 1] = nums[i];
                nums[i] = temp;
            }
        }
    }
```

<br>
<br>
###281 Zigzag Iterator](#281-zigzag-iterator)

>Given two 1d vectors, implement an iterator to return their elements alternately.
>
>For example, given two 1d vectors:
>
>v1 = [1, 2]
>v2 = [3, 4, 5, 6]
>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].
>
>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?
>
>Clarification for the follow up question - Update (2015-09-18):
>The "Zigzag" order is not clearly defined and is ambiguous for k > 2 cases. If "Zigzag" does not look right to you, replace "Zigzag" with "Cyclic". For example, given the following input:
>
>[1,2,3]
>[4,5,6,7]
>[8,9]
>It should return [1,4,8,2,5,9,3,6,7].


**Primitive solution**: use two pointers point to the current index of two lists.

```java
public class ZigzagIterator {
    private int index1;
    private int index2;
    private List<Integer> v1;
    private List<Integer> v2;
    private boolean nextV1 = true;
    
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        this.v1 = v1;
        this.v2 = v2;
        index1 = 0;
        index2 = 0;
    }

    public int next() {
        if (!hasNext()) {
            return -1;
        }
        if (nextV1) {
            if (index1 < v1.size()) {
                nextV1 = false;
                return v1.get(index1++);
            } else {
                nextV1 = false;
                return v2.get(index2++);
            }
        } else {
            if (index2 < v2.size()) {
                nextV1 = true;
                return v2.get(index2++);
            } else {
                nextV1 = true;
                return v1.get(index1++);
            }
        }
    }

    public boolean hasNext() {
        return !(index1 == v1.size() && index2 == v2.size());
    }
}
```

**Solution using java iterator**:

```java
public class ZigzagIterator {
    private Iterator<Integer> i1;
    private Iterator<Integer> i2;
    
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        i1 = v1.iterator();
        i2 = v2.iterator();
    }

    public int next() {
        if (!hasNext()) {
            return -1;
        }
        if (i1.hasNext()) {
            Iterator<Integer> temp = i1;
            i1 = i2;
            i2 = temp;
        }
        return i2.next();
    }

    public boolean hasNext() {
        return i1.hasNext() || i2.hasNext();
    }
}
```
<br>
<br>
###282 Expression Add Operators](#282-expression-add-operators)

>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.
>

<pre>
Examples: 
"123", 6 -> ["1+2+3", "1*2*3"] 
"232", 8 -> ["2*3+2", "2+3*2"]
"105", 5 -> ["1*0+5","10-5"]
"00", 0 -> ["0+0", "0-0", "0*0"]
"3456237490", 9191 -> []
</pre>

**Idea**: dfs. 

```java
    public List<String> addOperators(String num, int target) {
        List<String> res = new ArrayList<>();
        dfs(res, num, target, 0, "", 0, 0);
        return res;
    }
    /**
     * index: index of num string
     * s: result string formula
     * val: current value before index
     * preNum: previous num in the formula
     **/
    private void dfs(List<String> res, String num, int target, int index, String s, long val, long preNum) {
        if (index == num.length()) {
            if (val == target) {
                res.add(s);
            }
            return;
        }
        for (int i = index; i < num.length(); i++) {
            /**Start zeros is not vaid except 0, eg, 05**/
            if (i > index && num.charAt(index) == '0') {
                break;
            }
            long temp = Long.parseLong(num.substring(index, i + 1));
            if (index == 0) {
                dfs(res, num, target, i + 1, "" + temp, temp, temp);
            } else {
                dfs(res, num, target, i + 1, s + "+" + temp, val + temp, temp);
                dfs(res, num, target, i + 1, s + "-" + temp, val - temp, -temp);
                dfs(res, num, target, i + 1, s + "*" + temp, preNum * temp + val - preNum, preNum * temp);
            }
        }
    }
```
<br>
<br>
###283 Move Zeroes](#283-move-zeroes)
>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
>
>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
>
>Note:
>You must do this in-place without making a copy of the array.
Minimize the total number of operations.

```java
public void moveZeroes(int[] nums) {
    int i = 0;
    for (int num : nums) {
        if (num != 0) {
            nums[i++] = num;
        }
    }
    for (int j = i; j < nums.length; j++) {
        nums[j] = 0;
    }
}

```


<br>
<br>
###284 Peeking Iterator](#284-peeking-iterator)

>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().
>
>Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].
>
>Call next() gets you 1, the first element in the list.
>
>Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.
>
>You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.
>
>Follow up: How would you extend your design to be generic and work with all types, not just integer?

**Idea**: store the next element.

```java
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html
class PeekingIterator implements Iterator<Integer> {
    private Integer next;
    private Iterator<Integer> iterator;

    public PeekingIterator(Iterator<Integer> iterator) {
        this.iterator = iterator;
        // initialize any member here.
        if (this.iterator.hasNext()) {
            next = this.iterator.next();
        }
    }

    // Returns the next element in the iteration without advancing the iterator.
    public Integer peek() {
        return next;
    }

    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    @Override
    public Integer next() {
        Integer res = next;
        if (iterator.hasNext()) {
            next = iterator.next();
        } else {
            next = null;
        }
        return res;
    }

    @Override
    public boolean hasNext() {
        return next != null;
    }
}

```

<br>
<br>
###285 Inorder Successor in BST](#285-inorder0-successor-in-bst)
>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

>Note: If the given node has no in-order successor in the tree, return null.

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    if (p.right != null) {
        TreeNode temp = p.right;
        while (temp.left != null) {
            temp = temp.left;
        }
        return temp;
    } 
    return succ(root, p);
}
private TreeNode succ(TreeNode root, TreeNode p) {
    if (root == p) {
        return null;
    } else if (root.val < p.val) {
        return succ(root.right, p);
    } else {
        TreeNode left = succ(root.left, p);
        return left == null ? root : left;
    }
}
```

<br>
<br>
###286 Walls and Gates](#286-walls-and-gates)

>You are given a m x n 2D grid initialized with these three possible values.

<pre>
-1 - A wall or an obstacle.
0 - A gate.
INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

For example, given the 2D grid:
INF  -1  0  INF
INF INF INF  -1
INF  -1 INF  -1
  0  -1 INF INF
After running your function, the 2D grid should be:
  3  -1   0   1
  2   2   1  -1
  1  -1   2  -1
  0  -1   3   4
</pre>

**Idea**: Best first search

```java
public void wallsAndGates(int[][] rooms) {
    if (rooms.length == 0 || rooms[0].length == 0) {
        return;
    }
    Queue<int[]> queue = new LinkedList<>();
    for (int i = 0; i < rooms.length; i++) {
        for (int j = 0; j < rooms[0].length; j++) {
            if (rooms[i][j] == 0) {
                queue.offer(new int[] {i, j});
            }
        }
    }
    bfs(rooms, queue);
}
private void bfs(int[][] rooms, Queue<int[]> queue) {
    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        if (cur[0] > 0 && rooms[cur[0] - 1][cur[1]] == Integer.MAX_VALUE) {
            rooms[cur[0] - 1][cur[1]] = rooms[cur[0]][cur[1]] + 1;
            queue.offer(new int[] {cur[0] - 1, cur[1]});
        }
        if (cur[0] < rooms.length - 1 && rooms[cur[0] + 1][cur[1]] == Integer.MAX_VALUE) {
            rooms[cur[0] + 1][cur[1]] = rooms[cur[0]][cur[1]] + 1;
            queue.offer(new int[] {cur[0] + 1, cur[1]});
        }
        if (cur[1] > 0 && rooms[cur[0]][cur[1] - 1] == Integer.MAX_VALUE) {
            rooms[cur[0]][cur[1] - 1] = rooms[cur[0]][cur[1]] + 1;
            queue.offer(new int[] {cur[0], cur[1] - 1});
        }
        if (cur[1] < rooms[0].length - 1 && rooms[cur[0]][cur[1] + 1] == Integer.MAX_VALUE) {
            rooms[cur[0]][cur[1] + 1] = rooms[cur[0]][cur[1]] + 1;
            queue.offer(new int[] {cur[0], cur[1] + 1});
        }
    }
}
```

<br>
<br>
###287 Find the Duplicate Number](#287-find-the-duplicate-number)

>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
>
>Note:
>You must not modify the array (assume the array is read only).
>You must use only constant, O(1) extra space.
>Your runtime complexity should be less than O(n2).
>There is only one duplicate number in the array, but it could be repeated more than once.


**Solution 1**: binary search

```java
public int findDuplicate(int[] nums) {
    int l = 1;
    int r = nums.length - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        int count = getCount(nums, mid);
        if (count > mid) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
/**Get numbers <= mid**/
private int getCount(int[] nums, int mid) {
    int res = 0;
    for (int num : nums) {
        if (num <= mid) {
            res++;
        }
    }
    return res;
}
```

**Solution 2**: find begin point in linkedlist with cycle.

Explaination: [link1](http://keithschwarz.com/interesting/code/?dir=find-duplicate)
              [link2](https://leetcode.com/discuss/61086/java-time-and-space-solution-similar-find-loop-in-linkedlist)



```java
public int findDuplicate(int[] nums) {
    int i = 0;
    int j = 0;
    do {
        i = nums[i];
        j = nums[nums[j]];
    } while (i != j);
    i = 0;
    while (i != j) {
        i = nums[i];
        j = nums[j];
    }
    return i;
}
```

<br>
<br>
###288 Unique Word Abbreviation](#288-unique-word-abbreviation)
An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:
<pre>
>a) it                      --> it    (no abbreviation)

     1
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
d) l|ocalizatio|n          --> l10n
Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.

Example: 
Given dictionary = [ "deer", "door", "cake", "card" ]

isUnique("dear") -> false
isUnique("cart") -> true
isUnique("cane") -> false
isUnique("make") -> true
</pre>

**Idea**: HashMap

```java
public class ValidWordAbbr {
    private Map<String, String> map;
    public ValidWordAbbr(String[] dictionary) {
        map = new HashMap<>();
        for (String s : dictionary) {
            String abbr = getAbbr(s);
            if (!map.containsKey(abbr)) {
                map.put(abbr, s);
            } else {
                map.put(abbr, abbr);
            }
        }
    }

    public boolean isUnique(String word) {
        String abbr = getAbbr(word);
        return !map.containsKey(abbr) || map.get(abbr).equals(word) ;
    }
    
    private String getAbbr(String s) {
        if (s.length() <= 2) {
            return s;
        } else {
            return s.charAt(0) + "" + (s.length() - 2) + "" + s.charAt(s.length() - 1);
        }
    }
}

```


<br>
<br>
###289 Game of Life](#289-game-of-life)

>According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."
>
>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
>
>Any live cell with fewer than two live neighbors dies, as if caused by under-population.
>Any live cell with two or three live neighbors lives on to the next generation.
>Any live cell with more than three live neighbors dies, as if by over-population..
>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
>Write a function to compute the next state (after one update) of the board given its current state.
>
>Follow up: 
>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.
>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?


**Solution 1** Use an additional array to store the pre state, then calculate the next state by the given rules.

Time : O(m * n), Space O(m * n)

```java

public void gameOfLife(int[][] board) {
    if (board.length == 0 || board[0].length == 0) {
        return;
    }
    int[][] pre = new int[board.length][board[0].length];
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            pre[i][j] = board[i][j];
        }
    }
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            int live = getLive(pre, i, j);
            if (pre[i][j] == 0 && live == 3) {
                board[i][j] = 1;
            } else if ((pre[i][j] == 1 && live > 3) || live < 2) {
                board[i][j] = 0;
            }
        }
    }
}
private int getLive(int[][] board, int row, int col) {
    int live = 0;
    for (int i = Math.max(0, row - 1); i <= Math.min(row + 1, board.length - 1); i++) {
        for (int j = Math.max(0, col - 1); j <= Math.min(col + 1, board[0].length - 1); j++) {
            live += board[i][j] & 1;
        }
    }
    return live - (board[row][col] & 1);
}
```

**Solution 2**: Use the second bit of each int to store the next state, and convert it back after all finished.

```java
public void gameOfLife(int[][] board) {
    if (board.length == 0 || board[0].length == 0) {
        return;
    }
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            int live = getLive(board, i, j);
            if (live == 3 || (live == 2 && board[i][j] == 1)) {
                board[i][j] |= 2;
            }
        }
    }
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            board[i][j] >>= 1;
        }
    }
}
private int getLive(int[][] board, int row, int col) {
    int live = 0;
    for (int i = Math.max(0, row - 1); i <= Math.min(row + 1, board.length - 1); i++) {
        for (int j = Math.max(0, col - 1); j <= Math.min(col + 1, board[0].length - 1); j++) {
            live += board[i][j] & 1;
        }
    }
    return live - (board[row][col] & 1);
}
```

<br>
<br>
###290 Word Pattern](#290-word-pattern)
>Given a pattern and a string str, find if str follows the same pattern.
>
>Here follow means a full match, such that there is a **bijection** between a letter in pattern and a non-empty word in str.
>
>Examples:
>pattern = "abba", str = "dog cat cat dog" should return true.
>
>pattern = "abba", str = "dog cat cat fish" should return false.
>
>pattern = "aaaa", str = "dog cat cat dog" should return false.
>
>pattern = "abba", str = "dog dog dog dog" should return false.
>
>Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.

**Note that it requires bijection, thus we need to check the match between a->b and b->a**

```java
public boolean wordPattern(String pattern, String str) {
    String[] strs = str.split(" ");
    if (strs.length != pattern.length()) {
        return false;
    }
    Map<Character, String> map = new HashMap<>();
    for (int i = 0; i < pattern.length(); i++) {
        String temp = map.get(pattern.charAt(i));
        if (temp == null) {
            if (map.containsValue(strs[i])) {
                return false;
            }
            map.put(pattern.charAt(i), strs[i]);
        } else {
            if (!temp.equals(strs[i])) {
                return false;
            }
        }
    } 
    return true;
}
```
<br>
<br>
###291 Word Pattern II](#291-word-pattern-ii)
>Given a pattern and a string str, find if str follows the same pattern.
>
>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.
>
>Examples:
>pattern = "abab", str = "redblueredblue" should return true.
>pattern = "aaaa", str = "asdasdasdasd" should return true.
>pattern = "aabb", str = "xyzabcxzyabc" should return false.
>Notes:
>You may assume both pattern and str contains only lowercase letters.


```java
public boolean wordPatternMatch(String pattern, String str) {
    Map<Character, String> map = new HashMap<>();
    return match(pattern, str, 0, 0, map);
}

private boolean match(String pattern, String str, int p, int s, Map<Character, String> map) {
    if (p == pattern.length() || s == str.length()) {
        return s == str.length() && p == pattern.length();
    }
    String temp = map.get(pattern.charAt(p));
    if (temp != null) {
        if (!str.startsWith(temp, s)) {
            return false;
        }
        return match(pattern, str, p + 1, s + temp.length(), map);
    }
    for (int i = s; i < str.length(); i++) {
        String cur = str.substring(s, i + 1);
        if (map.containsValue(cur)) {
            continue;
        }
        map.put(pattern.charAt(p), cur);
        if (match(pattern, str, p + 1, i + 1, map)) {
                return true;
        }
        map.remove(pattern.charAt(p));
    }
    return false;
}

```


<br>
<br>
###292 Nim Game](#292-nim-game)

>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.
>
>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.
>
>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.

**Idea**:

- 1 : true

- 2 : true

- 3 : true

- 4 : false;

- 5 : true;

- 6 : true;

- 7 : true;

- 8 : false;

- 9 : true;

......


**Solution 1**: 

```java
    public boolean canWinNim(int n) {
        return !(n % 4 == 0);
    }
```

<br>
<br>

###293 Flip Game](#293-flip-game)

>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two **consecutive** "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.
>
>Write a function to compute all possible states of the string after one valid move.
>
>For example, given s = "++++", after one move, it may become one of the following states:
>
[
  "--++",
  "+--+",
  "++--"
]

```java
public List<String> generatePossibleNextMoves(String s) {
    List<String> res = new ArrayList<>();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '+' && (i < s.length() - 1 && s.charAt(i + 1) == '+')) {
            res.add(s.substring(0, i) + "--" + s.substring(i + 2));
        }
    }
    return res;
}
```

<br>
<br>
###294 Flip Game II](#294-flip-game)

>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.
>
>Write a function to determine if the starting player can guarantee a win.
>
>For example, given s = "++++", return true. The starting player can guarantee a win by flipping the middle "++" to become "+--+".

**Idea**: Try all possible moves in the Flip Game I, if one case dfs return true, return true.

```java
public boolean canWin(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '+' && (i < s.length() - 1 && s.charAt(i + 1) == '+')) {
             if (!canWin(s.substring(0, i) + "--" + s.substring(i + 2))) {
                 return true;
             }
        }
    }
    return false;
}
```
<br>
<br>
###295 Find Median from Data Stream](#295-find-median-from-data-stream)

>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
>
>Examples: 
>[2,3,4] , the median is 3
>
>[2,3], the median is (2 + 3) / 2 = 2.5
>
>Design a data structure that supports the following two operations:
>
>void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.
For example:
>
add(1)
add(2)
findMedian() -> 1.5
add(3) 
findMedian() -> 2

**Idea**: use two heaps, store the smaller half and larger half. Also, size difference of these two should be <= 1.

```java
class MedianFinder {
    private PriorityQueue<Integer> minQueue = new PriorityQueue<>(); /*Larger half*/
    private PriorityQueue<Integer> maxQueue = new PriorityQueue(10, Collections.reverseOrder()); /*Smaller half*/
    
    // Adds a number into the data structure.
    public void addNum(int num) {
        if (minQueue.isEmpty() || num >= minQueue.peek()) {
            minQueue.offer(num);
        } else{
            maxQueue.offer(num);
        }
        if (maxQueue.size() > minQueue.size()) {
            minQueue.offer(maxQueue.poll());
        } else if (minQueue.size() - maxQueue.size() > 1) {
            maxQueue.offer(minQueue.poll());
        }
    }

    // Returns the median of current data stream
    public double findMedian() {
        int size = minQueue.size() + maxQueue.size();
        if (size == 0) {
            return 0.0;
        } else if (size % 2 == 0) {
            return (minQueue.peek() + maxQueue.peek()) / (double) 2;
        } else {
            return (double) minQueue.peek();
        }
    }
};
```


<br>
<br>
###296 Best Meeting Point](#296-best-meeting-point)

>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

<pre>
For example, given three people living at (0,0), (0,4), and (2,2):

1 - 0 - 0 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0
The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.

</pre>

**Idea**: Because distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|. So we can calculate the x distance and y distance seperately. 

So this problem reduced to find a point in one dimensional line, so that other points to it's distance is minimum.

```java
    public int minTotalDistance(int[][] grid) {
        List<Integer> rows = new ArrayList<>();
        List<Integer> cols = new ArrayList<>();
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    rows.add(i);
                    cols.add(j);
                }
            }
        }
        return getDistance(rows) + getDistance(cols);
    }
    private int getDistance(List<Integer> list) {
        Collections.sort(list);
        int l = 0;
        int r = list.size() - 1;
        int res = 0;
        while (l < r) {
            res += list.get(r--) - list.get(l++);
        }
        return res;
    }
```




<br>
<br>

##Similar questions from other sources.

###1 Search a 2D Matrix II

> Write an efficient algorithm that searches for a value in an n x m table (two-dimensional array). This table is sorted along the rows and columns — that is,

> Integers in each row are sorted from left to right.

> Integers in each column are sorted from up to bottom.

<pre>
eg:


1 4 7
2 5 8
3 6 9

</pre>


**Idea**:

**Solution 1**: We can use the idea in solution 1 of * [74 Search a 2D Matrix](https://github.com/wishyouhappy/leetcode#74-search-a-2d-matrix). We search from the upright, each time we can ignore one row or one column. Thus the overall time complexity if O(m+n)

**Solution 2**: Use divide and conquer to solve this problem. For each element in the matrix,if we treat it as a center element, we can divide the matrix into 4 submatrix. There are three ways to apply partition, row-based, column-based and diagonal. 

Considering the three cases int he following picture:

![matrix](https://wishyouhappy.github.io/pictures/matrix.png)

- 1) column-based: we search from the middle column,  if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 6-11, then we search from the upright and bottomleft sub-matrix

- 2) row-based: we search from the middle row, if we need to find 8, then we first search on the hightlighted row, we find that 8 is between 6-10, then we search from the upright and bottomleft sub-matrix

- 3) diagonal: **note that if you want to use diagonal method, the matrix need to have a square matrix**. if we need to find 10, then we first search on the hightlighted column, we find that 10 is between 7-13, then we search from the upright and bottomleft sub-matrix


**Solution 3**: Improve the method in solution 2. We can apply binary search to three ways described above. 

** Java Solution**:

**Solution 1**: Time complexity: O(m + n)

```java 
	 public boolean searchMatrix(int[][] matrix, int target) {
		 if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			 return false;
		 }
		 int i = 0;
		 int j = matrix[0].length - 1;
		 int row = matrix.length;
		 while(i < row && j >= 0) {
			 if (matrix[i][j] == target) {
				 return true;
			 } else if (matrix[i][j] > target) {
				 j--;
			 } else {
				 i++;
			 }
		 }
		 return false;
	 }
```


**Solution 2**: Time complexity O(nlgn)

1) In the code below, we apply search on the diagonal direction.**matrix must be square**

```java

	 public boolean searchMatrix1(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix1(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int currentRow = t;
		 int currentCol = l;
		 while(currentRow <= b && currentCol <= r && matrix[currentRow][currentCol] <= target) {
			 if (matrix[currentRow][currentCol] == target) {
				 return true;
			 }
			 currentRow++;
			 currentCol++;
		 }
		 return helper(matrix, target, l, currentCol - 1, currentRow, b) || helper(matrix, target,currentCol, r, t, currentRow - 1);
		 
	 }

```


2) row-based

```java
	 public boolean searchMatrix(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int midRow = t + (b - t) / 2;
		 int currentCol = l;
		 while(currentCol <= r && matrix[midRow][currentCol] <= target) {
			 if (matrix[midRow][currentCol] == target) {
				 return true;
			 }
			 currentCol++;
		 }
		 return helper(matrix, target, l, currentCol - 1, midRow + 1, b) || helper(matrix, target,currentCol, r, t, midRow - 1);
		 
	 }


```


**Solution 3**: Time complexity:O(n)

Take row-based as an example

```java
	 public boolean searchMatrix(int[][] matrix, int target) {
		 return helper(matrix, target, 0, matrix[0].length - 1, 0, matrix.length - 1);
	 }
	 
	 /* l r u b stands for left, right, top, bottom.*/ 
	 public boolean searchMatrix(int[][] matrix, int target, int l, int r, int t, int b) {
		 if (l > r || t > b) {
			 return false;
		 }
		 int midRow = t + (b - t) / 2;
		 int currentCol = l;
		 int right = r;
		 while(currentCol <= r && matrix[midRow][currentCol] <= target) {
			 int mid = currentCol + (right - currentCol) / 2;
			 if (matrix[midRow][mid] == target) {
				 return true;
			 } else if (matrix[midRow][mid] > target) {
				 right = mid - 1;
			 } else {
				 currentCol = mid + 1;
			 }
		 }
		 return helper(matrix, target, l, currentCol - 1, midRow + 1, b) || helper(matrix, target,currentCol, r, t, midRow - 1);
		 
	 }

```



###2 First Bad Version

>*From lintcode*

> The code base version is an integer start from 1 to n. One day, someone committed a bad version in the code case, so it caused this version and the following versions are all failed in the unit tests. Find the first bad version.

>You can call isBadVersion to help you determine which version is the first bad one. The details interface can be found in the code's annotation part.

>Example
Given n=5:

>Call isBadVersion(3), get false;

>Call isBadVersion(5), get true;

>Call isBadVersion(4), get true;

>Here we are 100% sure that the 4th version is the first bad version.

>Note
Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is VersionControl.isBadVersion(v)

>Challenge
You should call isBadVersion as few as possible.


**Idea**: Since the bad version causes it's later version fail to the test, thus if version i is ok, then versions after i must be ok. Thus, we can use binary search to search the first bad version. 

**Code**:

```java

/**
 * public class VersionControl {
 *     public static boolean isBadVersion(int k);
 * }
 * you can use VersionControl.isBadVersion(k) to judge wether 
 * the kth code version is bad or not.
*/
class Solution {
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    public int findFirstBadVersion(int n) {
        // write your code here
        if (n <= 0) {
            return -1;
        }
        
        int l = 1;
        int r = n;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (VersionControl.isBadVersion(mid)) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }


```

<br>
<br>


###3 Compare Strings

> Compare two strings A and B, determine whether A contains all of the characters in B.

> The characters in string A and B are all Upper Case letters.

<pre>
Example
For A = "ABCD", B = "ACD", return true.

For A = "ABCD", B = "AABC", return false.

**"ABCDE", "DB" return true**

</pre>

Note
**The characters of B in A are not necessary continuous or ordered.**


**Idea**: 
- The question does not require that the appear sequence in A and B sould be the same, thus we need fisrt sort tehe string before we compare. 
- When compare, since it does not require the characters should be continuous in A, thus for each begin index in A, we need to walk through the end to check if B exists. Here is a example solution below in O(n^2) time. 


**Solution**:

```java
public class Solution {
    /**
     * @param A : A string includes Upper Case letters
     * @param B : A string includes Upper Case letter
     * @return :  if string A contains all of the characters in B return true else return false
     */
    public boolean compareStrings(String A, String B) {
        // write your code here
        if (A == null || B == null) {
            return false;
        }
        if (B.length() == 0) {
            return true;
        }
        char[] arrA = A.toCharArray();
        char[] arrB = B.toCharArray();
        Arrays.sort(arrA);
        Arrays.sort(arrB);
        
        for (int i = 0; i <= A.length() - B.length(); i++) {
            int temp = 0;
            int j = 0;
            while (j < B.length() && i + temp < A.length()) {
                if (arrA[i + temp] == arrB[j]) {
                    temp++;
                    j++;
                } else {
                    temp++;
                }
            }
            if (j > B.length() - 1) {
                return true;
            }
        }
        return false;
    }
}
```

<br>
<br>



###4 Longest Common Substring

>Given two strings, find the longest common substring. Return the length of it. From lintcode

>Example, Given A = "ABCD", B = "CBCE", return 2.

Note: The characters in substring should occur continuously in original string. This is different with subsequence.

Challenge O(n x m) time and memory.

**Idea**: 
The most straight forward way to solve this problem takes O(n^3) time, we compare from the begining of two string, when not equal, update the max, move the pointer of the second string to the next character. The time complexity is bad. 

Generally, there are two ways to solve the longest common substring problem. 

- Dynamic programming

- **suffix tree**

Using dynamix programming we can get the result in O(m * n) time, m, n is the length of the two strings.

Using suffix tree we can reduce the time complexity to O(m + n). 

Below is the solution of dynamic programming.

Want to know more about the solution of suffix tree, click on this two links: [longest common substring](http://algs4.cs.princeton.edu/63suffix/LongestCommonSubstring.java.html) , [suffix array](http://algs4.cs.princeton.edu/63suffix/SuffixArray.java.html)

**Solution**:

```java
public class Solution {
    /**
     * @param A, B: Two string.
     * @return: the length of the longest common substring.
     */
    public int longestCommonSubstring(String A, String B) {
        // write your code here
        if (A == null || B == null || A.length() == 0 || B.length() == 0) {
            return 0;
        }
        int maxLen = Math.max(A.length(), B.length());
        int[][] dp = new int[maxLen+1][maxLen+1];
        int res = 0;
        for (int i = 0; i < A.length(); i++) {
            for (int j = 0; j < B.length(); j++) {
                if (A.charAt(i) == B.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                    res = Math.max(res, dp[i+1][j+1]);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return res;
    }
}
```

<br>
<br>



###5 Insert in Sorted Linked List

**Idea**: We need to find insert position, then add the element into the linkedlist

- 1) if  head is null, return new ListNode as head
- 2) if insert value <= head.value, add element at the beginning, return new added list element
- 3) find insert position, insert element 



```java
  public ListNode insert(ListNode head, int value) {
    ListNode temp = new ListNode(value);
    if (head == null || head.value >= value) {
      temp.next = head;
      return temp;
    }
    ListNode pre = head;
    while (pre.next != null && pre.next.value < value) {
      pre = pre.next;
    }
    temp.next = pre.next;
    pre.next = temp;
    return head;
  }
}
```


<br>
<br>


###6 Is Bipartite

>Suppose a graph is repensented as list, check if this graph is bipartite. If you are not familiar with bipartite, click on this link: [bipartite](http://en.wikipedia.org/wiki/Bipartite_graph).

**Idea**: In bipartite graph, we can divide the graph into two groups and inside each group, there is no edge between nodes in that group. 

Let's give an example, suppose group red and blue, if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. Thus we can traverse the graph to check if this condition is always true.

**Some notes**:

- 1) In graph traversal, unlike tree traversal, we need to record if a node is visited or not

- 2) In this problem, we also need to record the group information of each node. Let's use the above example: if node 1 is in group green, if node 2 is neighbor of node 1, then node 2 must in group red. And if node 2 has neighbor node 3, and node3 is red, then the graph is not a bipartite. 


**Solution**:

```java
/**
 * public class GraphNode {
 *   public int key;
 *   public List<GraphNode> neighbors;
 *   public GraphNode(int key) {
 *     this.key = key;
 *     this.neighbors = new ArrayList<GraphNode>();
 *   }
 * }
 */
public class Solution {
  public boolean isBipartite(List<GraphNode> graph) {
    if (graph.size() == 0) {
      return true;
    }
    Map<GraphNode, Integer> map = new HashMap<>();
    for (GraphNode node : graph) {
      Queue<GraphNode> queue = new LinkedList<>();
      if (!map.containsKey(node)) {
        queue.offer(node);
        map.put(node, 0);
      } else {
        continue;
      }
      while (!queue.isEmpty()) {
        GraphNode temp = queue.poll();
        int color = map.get(temp);
        for (GraphNode neib : temp.neighbors) {
          if (!map.containsKey(neib)) {
            map.put(neib, color == 0 ? 1 : 0);
            queue.offer(neib);
          } else if (map.get(neib) == color) {
            return false;
          } 
        }
      }
    }
    return true;
  }
}
```

<br>
<br>
###7 Lowest Common Ancestor

>Given two nodes in a binary tree, find their lowest common ancestor.

**Idea**: Use recursion

1) base case : root == null, root == one or root == two
2) expect from left child : left child returns one or two
   expect from right child : right child returns one or two.
3) In current level: 
    a. if left child returns one or two and right child returns one or two, indicates that we have found the lowest common ancester, returns root.
    b. if one side returns one or two, return the not null one.
 


```java
  public TreeNode lowestCommonAncestor(TreeNode root,
      TreeNode one, TreeNode two) {
    if (root == null) {
      return null;
    }
    if (root == one || root == two) {
      return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, one, two);
    TreeNode right = lowestCommonAncestor(root.right, one, two);
    if (left != null && right != null) {
      return root;
    }
    return left == null ? right : left;
  }
```

<br>

**Related**: What if the TreeNode has parant pointer?

**Idea**: Calculate the height from root to two nodes, find the difference, then use these height to find their common ancestor.

```java
  public TreeNodeP lowestCommonAncestor(TreeNodeP one, TreeNodeP two) {
    int heightOne = getHeight(one);
    int heightTwo = getHeight(two);
    int diff = heightOne - heightTwo;
    return diff < 0 ? getAncestor(one, two, -diff) : getAncestor(two, one, diff);
  }
  
  private TreeNodeP getAncestor(TreeNodeP one, TreeNodeP two, int diff) {
    while (diff > 0) {
      two = two.parent;
      diff--;
    }
    while (one != two) {
      one = one.parent;
      two = two.parent;
    }
    return one;
  }
  private int getHeight(TreeNodeP node) {
    int res = 0;
    while (node != null) {
      res++;
      node = node.parent;
    }
    return res;
  }

```

<br>

**Related**: Lowest common ancestor of k nodes.

```java
  public TreeNode lowestCommonAncestor(TreeNode root, List<TreeNode> nodes) {
    if (root == null) {
      return null;
    }
    for (TreeNode node : nodes) {
      if (root == node) {
        return root;
      }
    }
    TreeNode left = lowestCommonAncestor(root.left, nodes);
    TreeNode right = lowestCommonAncestor(root.right, nodes);
    if (left != null && right != null) {
      return root;
    }
    return left != null ? left : right;
  }

```
<br>
<br>

###8 Median Tracker
> Unlimited flow of numbers, return median sofar.

**Idea**: minHeap and maxHeap

minHeap stores the larger half

MaxHeap stores the smaller half

size difference of minHeap and maxHeap should <= 1.

**Solution**:

```java
  private PriorityQueue<Integer> minQue;
  private PriorityQueue<Integer> maxQue;
  public Solution() {
    minQue = new PriorityQueue<Integer>(); // for larger half
    maxQue = new PriorityQueue<Integer>(10, Collections.reverseOrder()); // for smaller half
  }
  
  public void read(int value) {
    // minQue.size >= maxQue.size, minQue.size - maxQue.size <= 1
    if (minQue.isEmpty() || value >= minQue.peek()) {
      minQue.offer(value);
    } else {
      maxQue.offer(value);
    }
    //if maxQue.size > minQue.size, poll one from maxQue to minQue
    if (maxQue.size() > minQue.size()) {
      minQue.offer(maxQue.poll());
    } else if (minQue.size() - maxQue.size() > 1) {
      maxQue.offer(minQue.poll());
    }
  }
  
  public Double median() {
    int size = minQue.size() + maxQue.size();
    if (size == 0) {
      return null;
    } else if (size % 2 == 0) {
      return (minQue.peek() + maxQue.peek())/(double)2;
    } else {
      return (double)minQue.peek();
    }
  }
```


<br>

<br>
###9 95 Percentile

>Find 95 percentile. Suppose the maximum length  is 4096 and lengths is not null and not empty.

**Idea**:

Count sort, then find 95% or 5%.

**Solution**:

```java
  public int percentile95(List<Integer> lengths) {
    int[] arr = new int[4097];
    for (Integer i: lengths) {
      arr[i]++;
    }
    int percentile = (int)(0.05 * lengths.size());
    int count = 0;
    int res = 4097;
    while (count <= percentile) {
      count += arr[--res];
    }
    return res;
  }
```


<br>
<br>

###10 Perfect shuffle

> shuffle the array such that all permutations are equally likely to be generated.

**Idea**: Random chooce a index, swap it with the current element. So the probability will be the same.

**Solution**:


```java

  public void shuffle(int[] array) {
    for (int i = array.length - 1; i >= 0; i--) {
      int random = (int) (Math.random() * (i + 1));
      swap(array, i, random);
    }
  }
  
  private void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

```

<br>
<br>


###11 Reservoir sample
>Unlimited flow, return a random number read so far.

**Idea**: Save it at probability 1/n.

**Solution**:

```java
public class Solution {
  private Integer res;
  private int count;
  public Solution() {
    res = null;
    count = 0;
  }
  
  public void read(int value) {
    count++;
    int temp = (int) (Math.random() * count);
    if (temp == 0) {
      res = value;
    }
  }
  
  
  public Integer sample() {
    return res;
  }
}
```
<br>
<br>

###12 Random7 Using Random5

>Given random5() which generates[0, 4], implement random7().

**Idea**:

RandomFive.random5() * 5 + RandomFive.random5() generates[0, 24] in equal probability.

Then match to [0, 6]. We can use %, but the probability is not equal, thus we could only includes [0, 20]

**Solution**:

```java
  public int random7() {
    int res = 0;
    while (true) {
      res = RandomFive.random5() * 5 + RandomFive.random5() ;
      if (res <= 20) {
        break;
      } 
    }
    return res % 7;
  }
```
<br>
<br>


###13 Random1000 using random5


> Given random5() which generates[0, 4], implement random1000().


**Idea**:

Create random10() to generate [0, 9] equally, then use random10() to generate three digits of Random1000.

**Solution**:


```java
  public int random1000() {
    return random10() * 100 + random10() * 10 + random10();
  }
  
  private int random10() {
    return  random2() * 5 + RandomFive.random5();
  }
  
  private int random2() {
    return (int) (Math.random() * 2);
  }
```

<br>

<br>

###14 Array deduplication

> Deduplication in place, for each group keep only one of them.

**Solution**:

```java

  public int[] dedup(int[] array) {
    if (array == null || array.length <= 1) {
      return array;
    }
    int l = 0;
    int r = 1;
    while (r < array.length) {
      if (array[l] != array[r]) {
        array[++l] = array[r];
      }
      r++;
    }
    return Arrays.copyOfRange(array, 0, l + 1);
  }
```
<br>

**Related**: Keep two duplicates.

```java
  public int[] dedup(int[] array) {
    if (array == null || array.length <= 2) {
      return array;
    }
    int l = 1;
    int r = 2;
    while (r < array.length) {
      if (array[r] != array[l - 1]) {
        array[++l] = array[r];
      }
      r++;
    }
    return Arrays.copyOfRange(array, 0, l + 1);
  }

```

<br>

**Related**: Keep zero.

```java
  public int[] dedup(int[] array) {
    if (array == null || array.length == 0) {
      return array;
    }
    int l = 0;
    boolean isDup = false;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[l]) {
        isDup = true;
      } else if (isDup == true) {
        array[l] = array[i];
        isDup = false;
      } else {
        array[++l] = array[i];
      }
    }
    return isDup ? Arrays.copyOfRange(array, 0, l) : Arrays.copyOfRange(array, 0, l + 1);
  }

```

**Related**: deduplication recursive.

> For example: [1, 2, 3, 3, 3, 2, 2, 1, 2, 2] , result should be []

**Solution**:

```java
  public int[] dedup(int[] array) {
    if (array == null || array.length == 0) {
      return array;
    }
    int l = -1;
   for (int r = 0; r < array.length; r++) {
      if (l == -1 || array[r] != array[l]) {
        array[++l] = array[r];
      } else {
        while (r + 1 < array.length && array[r + 1] == array[l]) {
          r++;
        }
        l--;
      }
    }
    return Arrays.copyOfRange(array, 0, l + 1);
  }

```

<br>
<br>


###15 Move 0s to the end

>Move all the 0s to the right end of the array.

> No need to keep relative order


**Solution**:

```java
  public int[] moveZero(int[] array) {
    int start = 0;
    int end = array.length - 1;
    while (start <= end) {
      if (array[start] == 0) {
        while (end >= 0 && array[end] == 0) {
          end--;
        }
        if (end < start) {
            break;
        }
        array[start] = array[end];
        array[end] = 0;
        end--;
      }
      start++;
    }
    return array;
  } 
```

<br>

**Related**:


> Need to keep the relative order


**Idea**: Traverse from left, keep the relative order of non-zero element, then fill the rest to 0s.

**Solution**:

```java
  public int[] moveZero(int[] array) {
    if (array == null || array.length == 0) {
      return array;
    }
    int l = 0;
    int r = 0;
    while (r < array.length) {
      if (array[r] != 0) {
        array[l++] = array[r];
      }
      r++;
    }
    while(l < array.length) {
      array[l++] = 0;
    }
    return array;
  }
```

<br>
<br>

###16 Largest and Samllest

>Return the largest number and the smallest number using the smallest comparison.

**Idea**:

The most straightforward way is 2n comparing times.

Compare in pair, so the compare time is 3/2 * n

**Solution**:

```java
  public int[] largestAndSmallest(int[] array) {
    int[] res = new int[2];
    res[0] = Integer.MIN_VALUE;
    res[1] = Integer.MAX_VALUE;
    int l = 0;
    int r = array.length - 1;
    while (l <= r) {
      boolean isSmaller = array[l] < array[r];
      if (isSmaller) {
        res[0] = Math.max(array[r], res[0]);
        res[1] = Math.min(array[l], res[1]);
      } else {
        res[0] = Math.max(array[l], res[0]);
        res[1] = Math.min(array[r], res[1]);
      }
      l++;
      r--;
    }
    return res;
  }
```

<br>

**Related**: Largest and second largest.

> Find the largest and second largest element in least comparison.

**Idea**: Compare two and two, record the element that smaller then that element when compare. 

After the first round of comparison, we get a binary tree, and the root is the largest, then we find the second largest in the list we record. 


**Time complexity : n + log(n). 

where n is the time complexity for two two compare, log(n) is the time complexity for find the second largest. Since the height of the tree is log(n), thus the time is log(n) to find the second largest.



**Solution**:

```java
  public int[] largestAndSecond(int[] array) {
    int[] res = new int[2];
    if (array == null || array.length < 2) {
      return res;
    }
    List<Pair> list = new ArrayList<Pair>();
    for (int i = 0; i < array.length; i++) {
      list.add(new Pair(i, array[i]));
    }
    Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
    while (list.size() > 1) {
      List<Pair> next = new ArrayList<Pair>();
      for (int i = 0; i < list.size(); i += 2) {
        if (i == list.size() - 1) {
          next.add(list.get(i));
        } else {
          Pair e1 = list.get(i);
          Pair e2 = list.get(i + 1);
          if (e1.value <= e2.value) {
            next.add(e2);
            if (!map.containsKey(e2.index)) {
              map.put(e2.index, new ArrayList<Integer>());
            } 
            map.get(e2.index).add(e1.value);
          } else {
            next.add(e1);
            if (!map.containsKey(e1.index)) {
              map.put(e1.index, new ArrayList<Integer>());
            }
            map.get(e1.index).add(e2.value);
          }
        }
      }
      list = next;
    }
    res[0] = list.get(0).value;
    res[1] = getSecondLargest(map.get(list.get(0).index));
    return res;
  }

```


<br>
<br>


###17 Sort in specific order

> Given two arrays, A1 and A2, sort A1 in such a way that the relative order among the elements will be same as those are in A2.

**Idea**:

Create an comparator, sort according the rules in comparator.

- If e1, e2 both exist in A2, then we sort them according to their indexs in A2

- If only e1 in A2, then e1 < e2

- If only e2 in A2, then e2 < e1

- Otherwise, compare them in the natural order.

Preprocess: We need a hashmap t record the index of each element in A2. 

**Note**: 

- this hashmap should be **final**, because it needs to be used into the comparator

- we needs to convert int[] to Integer[], because we used the Arrays.sort(), it needs a T[].

**Time complexity: O(nlgn)

**Solution**:

```java
  public int[] sortSpecial(int[] A1, int[] A2) {
    if (A1 == null || A1.length == 0) {
      return A1;
    }
    final Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < A2.length; i++) {
      if (!map.containsKey(A2[i])) {
        map.put(A2[i], i);
      }
    }
    Comparator<Integer> comp = new Comparator<Integer>() {
      public int compare(Integer arg1, Integer arg2) {
        if (map.containsKey(arg1) && map.containsKey(arg2)) {
          return map.get(arg1) - map.get(arg2);
        } else if (map.containsKey(arg1)) {
          return -1;
        } else if (map.containsKey(arg2)) {
          return 1;
        } else {
          return arg1 - arg2;
        }
      }
    };
    Integer[] arr = convertToIntegerArray(A1);
    Arrays.sort(arr, comp);
    return convertBackToIntArray(arr);
  }
  
  private Integer[] convertToIntegerArray(int[] arr) {
    Integer[] res = new Integer[arr.length];
    for (int i = 0; i < arr.length; i++) {
      res[i] = Integer.valueOf(arr[i]);
    }
    return res;
  }
  
  private int[] convertBackToIntArray(Integer[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
      res[i] = arr[i];
    }
    return res;
  }

```
<br>
<br>


###18 Closest number in binary search tree
> Given a binary search tree and a target value, return the number that is closest to target.


**Solution**:


```java
  public int closest(TreeNode root, int target) {
    if (root == null) {
      return -1;
    }
    int res = root.key;
    while (root != null) {
      if (Math.abs(target - root.key) < Math.abs(target - res)) {
        res = root.key;
      }
      if (target > root.key) {
        root = root.right;
      } else if (target == root.key) {
        return root.key;
      } else {
        root = root.left;
      }
    }
    return res;
  }

```

<br>

**Related**: Largest Number Smaller In Binary Search Tree

**Idea**: Update result only when go to the right subtree.

**Solution**:


```java
public int largestSmaller(TreeNode root, int target) {
    if (root == null) {
      return Integer.MIN_VALUE;
    }
    int res = Integer.MIN_VALUE;
    while (root != null) {
      if (target > root.key) {
        res = root.key;
        root = root.right;
      } else {
        root = root.left;
      }
    }
    return res;
}

```

###19 Delete In Binary Search Tree

> Delete a node in binary search tree.

```java

```


<br>
<br>

###19 Delete In Binary Search Tree


> Given a binary search tree, delete a node, the structure of BST should be maintianed. Suppose there is no duplicates in the BST.

**Idea**: First we need to find the node we need to delete. Then there are three cases:

- Target does not has child, just delete it.

- Target has only one child, set target.parent.left/right = child.left/right

- Target has two children, if target.right.left == null, just set target.right.left = target.left. Otherwise, find the smallest element as the new root in target's right subtree.

**Solution**:



```java
/**
 * public class TreeNode {
 *   public int key;
 *   public TreeNode left;
 *   public TreeNode right;
 *   public TreeNode(int key) {
 *     this.key = key;
 *   }
 * }
 */
public class Solution {
  public TreeNode delete(TreeNode root, int key) {
    if(root == null) {
      return null;
    } else if (key < root.key) {
      root.left = delete(root.left, key);
      return root;
    } else if (key > root.key) {
      root.right = delete(root.right, key);
      return root;
    } else {
      return deleteNode(root, key);
    }
  }
  
  private TreeNode deleteNode(TreeNode root, int key) {
    if (root.left == null) {
      return root.right;
    } else if (root.right == null) {
      return root.left;
    } else if (root.right.left == null) {
      root.right.left = root.left;
      return root.right;
    } else {
      TreeNode newRoot = getNewRoot(root.right);
      newRoot.left = root.left;
      newRoot.right = root.right;
      return newRoot;
    }
  }
  
  private TreeNode getNewRoot(TreeNode root) {
    TreeNode pre = null;
    while (root.left != null) {
      pre = root;
      root = root.left;
    }
    TreeNode res = root;
    pre.left = pre.left.right;
    return res;
  }
  
  
}

```


<br>
<br>

###20 Cutting wood


> Cutting wood into pieces, where the cutting positions are defined in an int array A and the cost of each cut is the length of the stick segment being cut. Determine the minimum total cost to cut.


**Idea**:

Fill cuts array with start and end. For example wood length 5, cuts[] = {1, 3}, we fill it to {0, 1, 3, 5}

then cost[i][j] = cut[j] - cut[i] + min(cut[i][k] + cut[k][j])

**Fill it from bottom to top, left to right**

Time: o(N ^ 3)


**Solution**:


```java
  public int minCost(int[] cuts, int length) {
    int[] arr = new int[cuts.length + 2];
    int[][] cost = new int[arr.length][arr.length];
    arr[0] = 0;
    for (int i = 0; i < cuts.length; i++) {
      arr[i + 1] = cuts[i];
    }
    arr[arr.length - 1] = length;
    for (int i = 1; i < arr.length; i++) {
      for (int j = i - 1; j >= 0; j--) {
        if (j == i - 1) {
          cost[j][i] = 0;
        } else {
          cost[j][i] = Integer.MAX_VALUE;
          for (int k = j + 1; k < i; k++) {
            cost[j][i] = Math.min(cost[j][i], cost[j][k] + cost[k][i]);
          }
          cost[j][i] += arr[i] - arr[j];
        }
      }
    }
    return cost[0][arr.length - 1];
  }

```

<br>
<br>

###21 Merge stone

> Give a list of piles of stones, each pile of stones has a certain weight represent as an integer array. Each time we can merge two adjacent piles into one larger pile, the cost is the sum of the weights of the two piles. Determine the minimum total cost to merge the piles of stones until we have only one pile left. 

eg : {4, 3, 3, 4}, the minimum cost is 28.

**Idea**:

Pretty like the cutting wood. 

induction rule:  min[j][i] = Math.min(min[j][k] + min[k + 1][i] + sum[j][i], min[j][i]);

**Solution**:

```java
public int minCost(int[] stones) {
  if (stones == null || stones.length == 0) {
      return 0;
  }
  int[][] min = new int[stones.length][stones.length];
  int[][] sum = new int[stones.length][stones.length];
  for (int i = 0; i < stones.length; i++) {
      for (int j = i; j >= 0; j--) {
          if (j == i) {
              sum[j][i] = stones[j];
              min[j][i] = 0; 
          } else {
              sum[j][i] = sum[j][i - 1] + stones[i];
              min[j][i] = Integer.MAX_VALUE;
              for (int k = j; k < i; k++) {
                  min[j][i] = Math.min(min[j][k] + min[k + 1][i] + sum[j][i], min[j][i]);
              }
          }
      }
  }
  return min[0][stones.length - 1];
}

```

<br>
<br>

###22 Binary Tree Path Sum To Target

> Binary tree, the two nodes can be the same node and they can only be on the path from root to one of the leaf nodes, from any node to any node, check if sum to target exists.

**Idea**: Record the prefix nodes from root of each node, each time visit a node, check if there is a path sum to target sum.

**Time complexity**: if tree is balanced, O(nlogn), Worst case, O(n ^ 2).


**Solution**:

```java
  public boolean exist(TreeNode root, int target) {
    return exist(root, new ArrayList<Integer>(), target);
  }
  
  private boolean exist(TreeNode root, List<Integer> prefixList, int target) {
    if (root == null) {
      return false;
    }
    prefixList.add(root.key);
    if (checkSum(prefixList, target)) {
      return true;
    }
    if (exist(root.left, prefixList, target)) {
      return true;
    }
    prefixList.remove(prefixList.size() - 1);
    prefixList.add(root.key);
    if (exist(root.right, prefixList, target)) {
      return true;
    }
    prefixList.remove(prefixList.size() - 1);
    return false;
  }
  
  private boolean checkSum(List<Integer> prefixList, int target) {
    int sum = 0;
    for (int i = prefixList.size() - 1; i >= 0; i--) {
      sum += prefixList.get(i);
      if (sum == target) {
        return true;
      }
    }
    return false;
  }
```


<br>
<br>


###23 Common Elements in Three Sorted Array

>Find all common elements in 3 sorted arrays.

```java

  public List<Integer> common(int[] a, int[] b, int[] c) {
    List<Integer> res = new ArrayList<Integer>();
    if (a == null || a.length == 0 || b == null || b.length == 0 || c == null || c.length == 0) {
      return res;
    }
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < a.length && j < b.length && k < c.length) {
      if (a[i] == b[j] && a[i] == c[k]) {
        res.add(a[i++]);
        j++;
        k++;
      } else if (a[i] < b[j]) {
        i++;
      } else if (b[j] < c[k]) {
        j++;
      } else {
        k++;
      }
    }
    return res;
  }
```


    List<List<Integer>> res = new ArrayList<List<Integer>>();
    combinations(target, coins, 0, new ArrayList<Integer>(), res);
    return res;
  }
  private void combinations(int target, int[] coins, int index, List<Integer> cur, List<List<Integer>> res) {
    if (index == coins.length - 1) {
      if (target % coins[coins.length - 1] == 0) {
        cur.add(target / coins[coins.length - 1]);
        res.add(new ArrayList<Integer>(cur));
        cur.remove(cur.size() - 1);
      }
      return;
    }
    for (int i = 0, num = target/ coins[index]; i <= num; i++) {
      cur.add(i);
      combinations(target - i * coins[index], coins, index + 1, cur, res);
      cur.remove(cur.size() - 1);
    }

<br>
<br>

###24 Kth smallest number in sorted matrix

<pre>
int[][] matrix = { {1,  3,   5,   7},
                   {2,  4,   8,   9},
                   {3,  5,   11,  15},
                   {6,  8,   13,  18} };

</pre>
**Idea**: Dijkstra algorithm

**Time**: O(klogk)

```java
  class Node {
    int val;
    int row;
    int col;
    public Node(int row, int col, int val) {
      this.val = val;
      this.row = row;
      this.col = col;
    }
  }
  public int kthSmallest(int[][] matrix, int k) {
    PriorityQueue<Node> queue = new PriorityQueue<Node>(10, new Comparator<Node>() {
      public int compare(Node e1, Node e2) {
        return e1.val - e2.val;
      }
    });
    boolean[][] visited = new boolean[matrix.length][matrix[0].length];
    queue.offer(new Node(0, 0, matrix[0][0]));
    visited[0][0] = true;
    while (true) {
      Node temp = queue.poll();
      k--;
      if (k == 0) {
        return temp.val;
      }
      if (temp.row < matrix.length - 1 && !visited[temp.row + 1][temp.col]) {
        queue.offer(new Node(temp.row + 1, temp.col, matrix[temp.row + 1][temp.col]));
        visited[temp.row + 1][temp.col] = true;
      }
      if (temp.col < matrix[0].length - 1 && !visited[temp.row][temp.col + 1]) {
        queue.offer(new Node(temp.row, temp.col + 1, matrix[temp.row][temp.col + 1]));
        visited[temp.row][temp.col + 1] = true;
      }
    }
  }
```



###25 String Abbreviation Matching

>Word “book” can be abbreviated to 4, b3, b2k, etc. Given a string and an abbreviation, return if the string matches the abbreviation.

>Assumptions:

>The original string only contains alphabetic characters.
Examples:

>pattern “s11d” matches input “sophisticated” since “11” matches eleven chars “ophisticate”.

**Idea**:

Recursion: if pattern[i] is char, then compare patter[i] and pattern[j]
otherwise, recursion to match(pattern, input, i + num's length, j + num's value);

**Solution**:


```java
  public boolean match(String input, String pattern) {
    if (input == null || pattern == null) {
      return false;
    }
    return match(input.toCharArray(), pattern, 0, 0);
  }
  private boolean match(char[] input, String pattern, int ii, int pi) {
    if (ii == input.length && pi == pattern.length()) {
      return true;
    }
    if (ii >= input.length || pi >= pattern.length()) {
      return false;
    }
    if (!isNum(pattern.charAt(pi))) {
      return input[ii] == pattern.charAt(pi) ? match(input, pattern, ii + 1, pi + 1) : false;
    } else {
      int temp = pi;
      while (pi < pattern.length() && isNum(pattern.charAt(pi))) {
        pi++;
      }
      int count = Integer.parseInt(pattern.substring(temp, pi));
      return match(input, pattern, ii + count, pi);
    }
  }
  private boolean isNum(char c) {
    return c >= '0' && c <= '9';
  }

```


<br>

<br>

###26 Permutation Index

> Given a permutation which contains no repeated number, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.

**Idea**: Refer to 60 Permutation Sequence


**Solution**:

```java
 public long permutationIndex(int[] A) {
    if(A == null || A.length == 0) {
        return 0;
    }
    long res = 1;
    long factor = 1;
    for (int i = A.length - 1; i >= 0; i--) {
        int count = 0;
        for (int j = i + 1; j < A.length; j++) {
            if (A[i] > A[j]) {
                count++;
            }
        }
        res += count * factor;
        factor *= (A.length - i);
    }
    return res;
}
```

<br>
<br>


###27 Permutation Index II

>Given a permutation which may contain repeated numbers,
find its index in all the permutations of these numbers,
which are ordered in lexicographical order. The index begins at 1.
>
>Example
Given the permutation [1, 4, 2, 2], return 3.

**Idea**:
In this problem, we need to handle duplicates. If there is one duplicate, the factor reduces to factor/2

**Revised Solution**: Move map out of for loop. Time is better.

```java
  public long permutationIndexII(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    long res = 1;
    long factor = 1;
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = A.length - 1; i >= 0; i--) {
        int count = 0;
        Integer val = map.get(A[i]);
        if (val == null) {
            map.put(A[i], 1);
        } else {
            map.put(A[i], val + 1);
        }
        for (int j = i + 1; j < A.length; j++) {
            if (A[i] > A[j]) {
                count++;
            }
        }
        res += count * factor / duplicatesFactor(map);
        factor *= (A.length - i);
    }
    return res;
}
private long duplicatesFactor(Map<Integer, Integer> map) {
    long res = 1;
    for (int val : map.values()) {
        res *= getFactor(val);
    }
    return res;
}
private long getFactor(int num) {
    long res = 1;
    for (int i = 1; i <= num; i++) {
        res *= i;
    }
    return res;
}
```

**First try**:

```java
    public long permutationIndexII(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        long res = 1;
        long factor = 1;
        for (int i = A.length - 1; i >= 0; i--) {
            Map<Integer, Integer> map = new HashMap<>();
            int count = 0;
            map.put(A[i], 1);
            for (int j = i + 1; j < A.length; j++) {
                Integer val = map.get(A[j]);
                if (val == null) {
                    map.put(A[j], 1);
                } else {
                    map.put(A[j], val + 1);
                }
                if (A[i] > A[j]) {
                    count++;
                }
            }
            res += count * factor / duplicatesFactor(map);
            factor *= (A.length - i);
        }
        return res;
    }
    private long duplicatesFactor(Map<Integer, Integer> map) {
        long res = 1;
        for (int val : map.values()) {
            res *= getFactor(val);
        }
        return res;
    }
    private long getFactor(int num) {
        long res = 1;
        for (int i = 1; i <= num; i++) {
            res *= i;
        }
        return res;
    }
```

Initiate factor array, thus we don't need to calculate it each time.

```java
public long permutationIndexII(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    long res = 1;
    long factor = 1;
    long[] factorsArr = getFactors(A.length);
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = A.length - 1; i >= 0; i--) {
        int count = 0;
        Integer val = map.get(A[i]);
        if (val == null) {
            map.put(A[i], 1);
        } else {
            map.put(A[i], val + 1);
        }
        for (int j = i + 1; j < A.length; j++) {
            if (A[i] > A[j]) {
                count++;
            }
        }
        res += count * factor / duplicatesFactor(map, factorsArr);
        factor *= (A.length - i);
    }
    return res;
}
private long duplicatesFactor(Map<Integer, Integer> map, long[] factorsArr) {
    long res = 1;
    for (int val : map.values()) {
        res *= factorsArr[val];
    }
    return res;
}

private long[] getFactors(int num) {
    long[] res = new long[num + 1];
    long temp = 1;
    for (int i = 1; i <= num; i++) {
        temp *= i;
        res[i] = temp;
    }
    return res;
}

```

<br>
<br>
###28 SellTicket

>N ticket windows, ith window has ai tickets available.
>The price of a ticket is equal to the number of tikcets remaining in that window at that time.
>Waht is the maximum amount of money the railway station can earn from selling the first m tickets.

<pre>
Input n m
a1 a2 ...an

output 
S

sample input 
2 4
2 5
sample out
14

</pre>


**Solution 1**: Priority queue

Time : m*lgn

```java
public long sellTicket1(int[] arr, long m) {
    long res = 0;
    PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {
            public int compare(Integer el1, Integer el2) {
                return el2 - el1;
            }
    });
    for (int num : arr) {
        queue.offer(num);
    }
    long tickets = m;
    while (tickets > 0) {
        int count = queue.poll();
        res += count;
        queue.offer(count - 1);
        tickets--;
    }
    return res;
}
```

**Solution 2**:  Find x so that when sells all ai >= x, sum (x + 1) < m < sum(x)

```java
public  long sellTicket(int[] arr, long m) {
    long res = 0;
    int threshold = 0;
    int l = 0;
    int r = 0;
    for (int num : arr) {
        r = Math.max(num, r);
    }
    while (l <= r) {
        threshold = l + (r - l) / 2;
        long sum1 = getSum(threshold, arr);
        long sum2 = getSum(threshold + 1, arr);
        if (sum2 <= m && m <= sum1) {
            break;
        } else if (sum1 < m) {
            r = threshold;
        } else {
            l = threshold;
        }
    }
    long tickets = 0;
    for (int num : arr) {
        if (num >= threshold) {
            tickets += num - threshold + 1;
            res += ((long) (threshold + num) * (long) (num - threshold + 1)) / 2;
        }
    }
    res -= (tickets - m) * threshold;
    return res;
} 

private long getSum(int threshold, int[] arr) {
    long res = 0;
    for (int num : arr) {
        res += num - threshold >= 0 ? num - threshold + 1 : 0;
    }
    return res;
}
```


<br>

<br>

###29 Uneaten leaves


>K caterpillars are eating their way through N leaves, each caterpillar falls from leaf to leaf in a unique sequence, all caterpillars start at a twig at position 0 and falls onto the leaves at position between 1 and N. Each caterpillar j has as associated jump number Aj. A caterpillar with jump number j eats leaves at positions that are multiple of j. It will proceed in the order j, 2j, 3j…. till it reaches the end of the leaves and it stops and build its cocoon. Given a set A of K elements K<-15, N<=10^9, we need to determine the number of uneaten leaves.


**Brute force**: O(kn)

```java
public int countUneatenLeaves(int[] jumpNumber, int numberLeaves) {
    int catArraySize = jumpNumber.length;
    int countEaten = 0;
    Map<Integer,Integer> mapPosition = new HashMap<>();
    for (int i = 0; i < catArraySize; i++){
        int catervalue = jumpNumber[i];
        for (int j = 1; j * catervalue <= numberLeaves; j++){
            if (!mapPosition.containsKey(jumpNumber[i] * j)) {
                mapPosition.put(jumpNumber[i] * j, 1);
                countEaten++;
            }
        }
    }
    return numberLeaves - countEaten;
}
}
```

**Inclusive and exclusive**: k * 2 ^ k

For example if caterpillars : [2, 4, 5];

|S| = |S2| + |S4| + |S5| - |S24| - |S25| - |S45| + |S245|

http://www.iarcs.org.in/inoi/contests/sep2004/Advanced-2-solution.php


<br>
<br>

###30 Longest Chain
eg a, abcd, bcd, abd, cd, c)： each time we can delete a char to go to the next word of the chain.
longest chain:  abcd-- bcd -- cd -- c, thus we should return 4.

Revised.

```java
public int longest_chain(String[] w) {
    Set<String> dict = new HashSet<>();
    Map<String, Integer> map = new HashMap<>();
    for (String s : w) {
        dict.add(s);
    }
    int res = 0;
    for (String s : w) {
        res = Math.max(res, getChainLen(s, dict, map));
    }
    return res;
}

private int getChainLen(String s, Set<String> dict, Map<String, Integer> map) {
    if (map.containsKey(s)) {
        return map.get(s);
    }
    int res = 1;
    for (int i = 0; i < s.length(); i++) {
        StringBuilder sb = new StringBuilder(s);
        String next = sb.deleteCharAt(i).toString();
        if (dict.contains(next)) {
            res = Math.max(res, getChainLen(next, dict, map) + 1);
        }
    }
    map.put(s, res);
    return res;
}
```

First try.

```java
 public int longest_chain(String[] w) {
    Set<String> dict = new HashSet<>();
    Map<String, Integer> map = new HashMap<>();
    for (String s : w) {
        dict.add(s);
    }
    int res = 0;
    for (String s : w) {
        int length = getChainLen(s, dict, map);
        map.put(s, length);
        res = Math.max(res, length);
    }
    return res;
}

private int getChainLen(String s, Set<String> dict, Map<String, Integer> map) {
    for (int i = 0; i < s.length(); i++) {
        StringBuilder sb = new StringBuilder(s);
        sb.deleteCharAt(i);
        String next = sb.toString();
        if (dict.contains(next)) {
            if (map.containsKey(next)) {
                return map.get(next) + 1;
            }
            return getChainLen(next, dict, map) + 1;
        }
    }
    return 1;
}

```

<br>
<br>

###31 Friend Circle

>Problem Statement
>
>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature, i.e., if A is friend of B and B is friend of C, then A is also friend of C. A friend circle is a group of students who are directly or indirectly friends.
>
>You are given a N×N−matrix M which consists of characters Y or N. If M[i][j]=Y, then ith and jth students are friends with each other, otherwise not. You have to print the total number of friend circles in the class.
>
>Input Format 
>First line of the input contains an integer N - (size of the matrix), followed by N lines each having N characters.
>
>Output Format 
>Print the maximum number of friend circles.
>
>Constraints 
>1≤N≤300 
>Each element of matrix friends will be Y or N. 
>Number of rows and columns will be equal in the matrix.

>M[i][i]=Y, where 0≤i<N 
>M[i][j] = M[j][i], where 0<=i<j<N

**Solution 1**: flood

```java
 static int friendCircles(String[] friends) {
    int res = 0;
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < friends.length; i++) {
        if (friends[i].contains("Y")) {
            res++;
            friends[i] = replaceY(friends[i], queue);
            while (!queue.isEmpty()) {
                int next = queue.poll();
                friends[next] = replaceY(friends[next], queue);
            }
        }
    }
    return res;
}

static String replaceY(String row, Queue<Integer> queue) {
    int index = 0;
    while ((index = row.indexOf("Y")) != -1) {
        queue.offer(index);
        row = row.replaceFirst("Y", "N");
    }
    return row;
}
```


**Union find set**: http://www.geeksforgeeks.org/union-find/


<br>
<br>

###32 Stock Max

[question source](https://www.hackerrank.com/challenges/stockmax)
<pre>

Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next N days.

Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy?

Input

The first line contains the number of test cases T. T test cases follow:

The first line of each test case contains a number N. The next line contains N integers, denoting the predicted price of WOT shares for the next N days.

Output

Output T lines, containing the maximum profit which can be obtained for the corresponding test case.

Constraints

1 <= T <= 10 
1 <= N <= 50000

All share prices are between 1 and 100000

Sample Input

3
3
5 3 2
3
1 2 100
4
1 3 1 2
Sample Output

0
197
3
Explanation

For the first case, you cannot obtain any profit because the share price never rises. 
For the second case, you can buy one share on the first two days, and sell both of them on the third day. 
For the third case, you can buy one share on day 1, sell one on day 2, buy one share on day 3, and sell one share on day 4.

</pre>

**Idea** to get the max profit, we need to buy the stocks that has latter stocks with higher price than it.

For example: 1 3 1 5 9 : we need to buy 1 3 1 5 and sell at 9. Thus we can calculate the max profit from the end of the array.

Here is the solution:

```java
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    static long getProfit(int[] prices) {
        long res = 0;
        long max = Integer.MIN_VALUE;
        for (int i = prices.length - 1; i >= 0; i--) {
            max = Math.max(max, prices[i]);
            res += (max - prices[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner in = new Scanner(System.in);
        int cases = in.nextInt();
        for (int i = 0; i < cases; i++) {
            int n = in.nextInt();
            int[] prices = new int[n];
            for (int j = 0; j < n; j++) {
                prices[j] = in.nextInt();
            }
            System.out.println(getProfit(prices));
        }
    }
}

```



<br>
<br>

###33 Flipping bits

>You are given an integer array with N elements: d[0], d[1], ... d[N - 1]. 
>
>You can perform AT MOST one move on the array: choose any two integers [L, R], and flip all the elements between (and including) the L-th and R-th bits. L and R represent the left-most and right-most index of the bits marking the boundaries of the segment which you have decided to flip.
>
>What is the maximum number of '1'-bits (indicated by S) which you can obtain in the final bit-string? 

> Example: 1 0 0 1 0 0 1 0 Result : 6 . We can get a maximum of 6 ones in the given binary array by performing either of the following operations: Flip [1, 5] ==> 1 1 1 0 1 1 1 0

**Idea**: Same with maximum subarray, one dimensional dp.

```java
public int flipBits(int[] a) {
    int initial = 0; /* initial number of 1s*/
    int resIncreased = 0; /* Increased 1s */
    int temp = 0;
    for (int i : a) {
        if (i == 0) {
            temp++;
        } else {
            initial++;
            temp--;
        }
        temp = Math.max(0, temp);
        resIncreased = Math.max(temp, resIncreased);
    }
    return initial + resIncreased;
}
```

<br>
<br>

###34 Hamming distance

>Given int array, calcaulate sum of hamming distance of all pairs in O(n) time.

**Idea**:

For each digit, we find the count of 0s and 1s, then multiply. The final result is the sum of multiply result of 32 bits.


<br>
<br>

###35 Find a pair with given sum in a Balanced BST

>Given a Balanced Binary Search Tree and a target sum, write a function that returns true if there is a pair with sum equals to target sum, otherwise return false. **Expected time complexity is O(n) and only O(Logn)** extra space can be used. Any modification to Binary Search Tree is not allowed. Note that height of a Balanced BST is always O(Logn).

http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/

**Idea**: traverse the binary tree both inorder and reverse-inorder. 
- If current-inorder + current-reverse == sum, return true;
- If current-inorder + current-reverse < sum, we continue visit the next element in inorder;
- otherwise we visit the next element in reverse-inorder.

```java
public boolean findPair(TreeNode root, int target) {
    Deque<TreeNode> stackInorder = new LinkedList<>();
    Deque<TreeNode> stackReverse = new LinkedList<>();
    TreeNode p1 = root;
    TreeNode p2 = root;
    boolean turn1 = true;
    boolean turn2 = true;
    int val1 = 0;
    int val2 = 0;
    while (true) {
        while (turn1 && (p1 != null || !stackInorder.isEmpty())) {
            if (p1 != null) {
                stackInorder.push(p1);
                p1 = p1.left;
            } else {
                p1 = stackInorder.pop();
                val1 = p1.key;
                p1 = p1.right;
                turn1 = false;
            }
        }
        while (turn2 && (p2 != null || !stackReverse.isEmpty())) {
            if (p2 != null) {
                stackReverse.push(p2);
                p2 = p2.right;
            } else {
                p2 = stackReverse.pop();
                val2 = p2.key;
                p2 = p2.left;
                turn2 = false;
            }
        }
        if (val1 != val2 && val1 + val2 == target) {
            return true;
        } else if (val1 + val2 < target) {
            turn1 = true;
        } else {
            turn2 = true;
        }
        if (val1 >= val2) {
            return false;
        }
    }
}
```
<br>
<br>

###36 Sliding window maximum

>Given array A, sliding window size of w moving from left to the right. Return array B, B[i] is the maximum number in the window. For example, given [1, 3, 2, 5, 8, 9, 4, 7, 3], window size k = 3, return [3, 5, 8, 9, 9, 9, 7, 7, 3]

**Idea**: Deque, when new element enters, check from the right of the deque, if it smaller than the new element, remove it from the queue. After all smaller elements are removed, we insert the new element to the deque.

Here to maintain the size of sliding window, we store index in the deque other than the real value.

```java
public int[] slidingMaximum(int[] A, int w) {
    Deque<Integer> deque = new LinkedList<>();
    for (int i = 0; i < w; i++) {
        while (!deque.isEmpty() && A[deque.peekLast()] <= A[i]) {
            deque.pollLast();
        }
        deque.offerLast(i);
    }
    int[] res = new int[A.length];
    for (int i = w; i < A.length; i++) {
        res[i - w] = A[deque.peekFirst()];
        while (!deque.isEmpty() && A[deque.peekLast()] <= A[i]) {
            deque.pollLast();
        }
        while (!deque.isEmpty() && deque.peekFirst() <= i - w) {
            deque.pollFirst();
        }
        deque.offerLast(i);
    }
    for (int i = w; i > 0; i--) {
        res[A.length - i] = A[deque.peekFirst()];
        if (deque.peekFirst() <= (A.length - i)) {
            deque.pollFirst();
        }
    }
    return res;
}
```